// SPDX-FileCopyrightText: 2024 Helge Eichhorn <git@helgeeichhorn.de>
// SPDX-License-Identifier: MPL-2.0

// Auto-generated by `lox-gen`. Do not edit!

use crate::DynOrigin;
use crate::Elements;
use crate::MeanRadius;
use crate::NaifId;
use crate::Origin;
use crate::PointMass;
use crate::Radii;
use crate::RotationalElement;
use crate::RotationalElementType;
use crate::RotationalElements;
use crate::Spheroid;
use crate::TriaxialEllipsoid;
use crate::TryMeanRadius;
use crate::TryPointMass;
use crate::TryRotationalElements;
use crate::TrySpheroid;
use crate::TryTriaxialEllipsoid;
use crate::UndefinedOriginPropertyError;
use lox_core::elements::GravitationalParameter;
use lox_core::units::Distance;
use std::fmt::Display;
use std::fmt::Formatter;
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Sun;
impl Origin for Sun {
    fn id(&self) -> NaifId {
        NaifId(10i32)
    }
    fn name(&self) -> &'static str {
        "Sun"
    }
}
impl Display for Sun {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for Sun {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(132712440041.27942f64)
    }
}
impl TriaxialEllipsoid for Sun {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(695700f64),
            Distance::kilometers(695700f64),
            Distance::kilometers(695700f64),
        )
    }
}
impl Spheroid for Sun {}
const RIGHT_ASCENSION_SUN: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 4.993910588731375f64,
    c1: 0f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
const DECLINATION_SUN: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: 1.1147417932487782f64,
    c1: 0f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
const ROTATION_SUN: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 1.4691483511587469f64,
    c1: 0.24756448241988369f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
impl RotationalElements for Sun {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_SUN.angle(t),
            DECLINATION_SUN.angle(t),
            ROTATION_SUN.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_SUN.angle_dot(t),
            DECLINATION_SUN.angle_dot(t),
            ROTATION_SUN.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Mercury;
impl Origin for Mercury {
    fn id(&self) -> NaifId {
        NaifId(199i32)
    }
    fn name(&self) -> &'static str {
        "Mercury"
    }
}
impl Display for Mercury {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for Mercury {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(22031.868551400003f64)
    }
}
impl MeanRadius for Mercury {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(2439.4f64)
    }
}
impl TriaxialEllipsoid for Mercury {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(2440.53f64),
            Distance::kilometers(2440.53f64),
            Distance::kilometers(2438.26f64),
        )
    }
}
impl Spheroid for Mercury {}
const RIGHT_ASCENSION_MERCURY: RotationalElement<5usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 4.904554967017021f64,
    c1: -0.0005724679946541401f64,
    c2: 0f64,
    c: [0f64, 0f64, 0f64, 0f64, 0f64],
    theta0: [
        3.0506799486005773f64,
        6.101359897201155f64,
        2.868854538622146f64,
        5.919534488968053f64,
        2.6870291303890443f64,
    ],
    theta1: [
        2608.7878923240937f64,
        5217.575784648187f64,
        7826.363676972282f64,
        10435.151569296375f64,
        13043.939461620466f64,
    ],
};
const DECLINATION_MERCURY: RotationalElement<5usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: 1.0719026867585775f64,
    c1: -0.00008552113334772214f64,
    c2: 0f64,
    c: [0f64, 0f64, 0f64, 0f64, 0f64],
    theta0: [
        3.0506799486005773f64,
        6.101359897201155f64,
        2.868854538622146f64,
        5.919534488968053f64,
        2.6870291303890443f64,
    ],
    theta1: [
        2608.7878923240937f64,
        5217.575784648187f64,
        7826.363676972282f64,
        10435.151569296375f64,
        13043.939461620466f64,
    ],
};
const ROTATION_MERCURY: RotationalElement<5usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 5.752584270622286f64,
    c1: 0.10713722462923113f64,
    c2: 0f64,
    c: [
        0.0001862714861495712f64,
        -0.000019601618296223117f64,
        -0.00000192684349420174f64,
        -0.00000044313909708136026f64,
        -0.00000009965830028887623f64,
    ],
    theta0: [
        3.0506799486005773f64,
        6.101359897201155f64,
        2.868854538622146f64,
        5.919534488968053f64,
        2.6870291303890443f64,
    ],
    theta1: [
        2608.7878923240937f64,
        5217.575784648187f64,
        7826.363676972282f64,
        10435.151569296375f64,
        13043.939461620466f64,
    ],
};
impl RotationalElements for Mercury {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_MERCURY.angle(t),
            DECLINATION_MERCURY.angle(t),
            ROTATION_MERCURY.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_MERCURY.angle_dot(t),
            DECLINATION_MERCURY.angle_dot(t),
            ROTATION_MERCURY.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Venus;
impl Origin for Venus {
    fn id(&self) -> NaifId {
        NaifId(299i32)
    }
    fn name(&self) -> &'static str {
        "Venus"
    }
}
impl Display for Venus {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for Venus {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(324858.592f64)
    }
}
impl MeanRadius for Venus {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(6051.8f64)
    }
}
impl TriaxialEllipsoid for Venus {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(6051.8f64),
            Distance::kilometers(6051.8f64),
            Distance::kilometers(6051.8f64),
        )
    }
}
impl Spheroid for Venus {}
const RIGHT_ASCENSION_VENUS: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 4.760560067739733f64,
    c1: 0f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
const DECLINATION_VENUS: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: 1.1721631256393916f64,
    c1: 0f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
const ROTATION_VENUS: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 2.7960174616949156f64,
    c1: -0.025854762996317376f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
impl RotationalElements for Venus {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_VENUS.angle(t),
            DECLINATION_VENUS.angle(t),
            ROTATION_VENUS.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_VENUS.angle_dot(t),
            DECLINATION_VENUS.angle_dot(t),
            ROTATION_VENUS.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Earth;
impl Origin for Earth {
    fn id(&self) -> NaifId {
        NaifId(399i32)
    }
    fn name(&self) -> &'static str {
        "Earth"
    }
}
impl Display for Earth {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for Earth {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(398600.43550702266f64)
    }
}
impl MeanRadius for Earth {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(6371.0084f64)
    }
}
impl TriaxialEllipsoid for Earth {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(6378.1366f64),
            Distance::kilometers(6378.1366f64),
            Distance::kilometers(6356.7519f64),
        )
    }
}
impl Spheroid for Earth {}
const RIGHT_ASCENSION_EARTH: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 0f64,
    c1: -0.011187560505283653f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
const DECLINATION_EARTH: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: 1.5707963267948966f64,
    c1: -0.009721483933608416f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
const ROTATION_EARTH: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 3.3186912127896577f64,
    c1: 6.3003876824396166f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
impl RotationalElements for Earth {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_EARTH.angle(t),
            DECLINATION_EARTH.angle(t),
            ROTATION_EARTH.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_EARTH.angle_dot(t),
            DECLINATION_EARTH.angle_dot(t),
            ROTATION_EARTH.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Mars;
impl Origin for Mars {
    fn id(&self) -> NaifId {
        NaifId(499i32)
    }
    fn name(&self) -> &'static str {
        "Mars"
    }
}
impl Display for Mars {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for Mars {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(42828.37362069909f64)
    }
}
impl MeanRadius for Mars {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(3389.5f64)
    }
}
impl TriaxialEllipsoid for Mars {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(3396.19f64),
            Distance::kilometers(3396.19f64),
            Distance::kilometers(3376.2f64),
        )
    }
}
impl Spheroid for Mars {}
const RIGHT_ASCENSION_MARS: RotationalElement<15usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 5.5373921900749785f64,
    c1: -0.001907216743164288f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0.000001186823891356144f64,
        0.000004153883619746505f64,
        0.0000009075712110370513f64,
        0.00000015707963267948966f64,
        0.007313924403529878f64,
    ],
    theta0: [
        3.328804809897935f64,
        0.37470342287773584f64,
        5.809517398292802f64,
        6.892873571600945f64,
        3.3097152567180146f64,
        2.120032883264378f64,
        4.032588225058434f64,
        4.387288948439982f64,
        3.8045796985836846f64,
        3.424288764152381f64,
        3.4730520762801462f64,
        3.9495523217086292f64,
        4.357448194643978f64,
        4.645778664015252f64,
        1.3857704297725961f64,
    ],
    theta1: [
        277.80594525842264f64,
        555.6129894920322f64,
        334.05422022489097f64,
        668.125936040531f64,
        719340.2120445863f64,
        11.523153020184504f64,
        11.536473384554899f64,
        23.047098122619843f64,
        668.1113614443373f64,
        334.05316148477937f64,
        334.0469780000094f64,
        668.1268926511307f64,
        1002.1807129125305f64,
        1336.235189496269f64,
        0.008801023466045386f64,
    ],
};
const DECLINATION_MARS: RotationalElement<20usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: 0.9500266243444937f64,
    c1: -0.0010170216810942417f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0.000000890117918517108f64,
        0.000002460914245312005f64,
        0.0000005410520681182422f64,
        0.00000008726646259971648f64,
        0.02777297060138025f64,
    ],
    theta0: [
        3.328804809897935f64,
        0.37470342287773584f64,
        5.809517398292802f64,
        6.892873571600945f64,
        3.3097152567180146f64,
        2.120032883264378f64,
        4.032588225058434f64,
        4.387288948439982f64,
        3.8045796985836846f64,
        3.424288764152381f64,
        3.4730520762801462f64,
        3.9495523217086292f64,
        4.357448194643978f64,
        4.645778664015252f64,
        1.3857704297725961f64,
        2.136869016190709f64,
        0.751510868094019f64,
        1.0064158213753553f64,
        1.3871248750853138f64,
        2.9029314796567682f64,
    ],
    theta1: [
        277.80594525842264f64,
        555.6129894920322f64,
        334.05422022489097f64,
        668.125936040531f64,
        719340.2120445863f64,
        11.523153020184504f64,
        11.536473384554899f64,
        23.047098122619843f64,
        668.1113614443373f64,
        334.05316148477937f64,
        334.0469780000094f64,
        668.1268926511307f64,
        1002.1807129125305f64,
        1336.235189496269f64,
        0.008801023466045386f64,
        334.054984682245f64,
        668.1273150051017f64,
        1002.1811764929237f64,
        1336.2354112473317f64,
        0.008801023466045386f64,
    ],
};
const ROTATION_MARS: RotationalElement<26usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 3.0726497570349416f64,
    c1: 6.12422041248567f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0.000002530727415391778f64,
        0.0000027401669256310974f64,
        0.0000006981317007977319f64,
        0.000000017453292519943295f64,
        0.000000017453292519943295f64,
        0.010202182516192693f64,
    ],
    theta0: [
        3.328804809897935f64,
        0.37470342287773584f64,
        5.809517398292802f64,
        6.892873571600945f64,
        3.3097152567180146f64,
        2.120032883264378f64,
        4.032588225058434f64,
        4.387288948439982f64,
        3.8045796985836846f64,
        3.424288764152381f64,
        3.4730520762801462f64,
        3.9495523217086292f64,
        4.357448194643978f64,
        4.645778664015252f64,
        1.3857704297725961f64,
        2.136869016190709f64,
        0.751510868094019f64,
        1.0064158213753553f64,
        1.3871248750853138f64,
        2.9029314796567682f64,
        2.252727410236719f64,
        0.6344650043848296f64,
        0.9890544553471146f64,
        1.1757236496733376f64,
        1.8289772979888115f64,
        1.664898441223219f64,
    ],
    theta1: [
        277.80594525842264f64,
        555.6129894920322f64,
        334.05422022489097f64,
        668.125936040531f64,
        719340.2120445863f64,
        11.523153020184504f64,
        11.536473384554899f64,
        23.047098122619843f64,
        668.1113614443373f64,
        334.05316148477937f64,
        334.0469780000094f64,
        668.1268926511307f64,
        1002.1807129125305f64,
        1336.235189496269f64,
        0.008801023466045386f64,
        334.054984682245f64,
        668.1273150051017f64,
        1002.1811764929237f64,
        1336.2354112473317f64,
        0.008801023466045386f64,
        334.05659172556966f64,
        668.130317528175f64,
        1002.1842799588599f64,
        1336.2285297823557f64,
        1670.2877519268022f64,
        0.008801023466045386f64,
    ],
};
impl RotationalElements for Mars {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_MARS.angle(t),
            DECLINATION_MARS.angle(t),
            ROTATION_MARS.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_MARS.angle_dot(t),
            DECLINATION_MARS.angle_dot(t),
            ROTATION_MARS.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Jupiter;
impl Origin for Jupiter {
    fn id(&self) -> NaifId {
        NaifId(599i32)
    }
    fn name(&self) -> &'static str {
        "Jupiter"
    }
}
impl Display for Jupiter {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for Jupiter {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(126686531.9003704f64)
    }
}
impl MeanRadius for Jupiter {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(69911f64)
    }
}
impl TriaxialEllipsoid for Jupiter {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(71492f64),
            Distance::kilometers(71492f64),
            Distance::kilometers(66854f64),
        )
    }
}
impl Spheroid for Jupiter {}
const RIGHT_ASCENSION_JUPITER: RotationalElement<15usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 4.6784701644349695f64,
    c1: -0.00011342894808711148f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0.0000020420352248333656f64,
        0.000016371188383706813f64,
        0.000024993114888558796f64,
        0.0000005235987755982989f64,
        0.00003752457891787809f64,
    ],
    theta0: [
        1.2796754075622423f64,
        0.42970006184100396f64,
        4.9549897464119015f64,
        6.2098814785958245f64,
        2.092649773141201f64,
        4.010766621082969f64,
        6.147922290150026f64,
        1.9783307071355725f64,
        2.5593508151244846f64,
        0.8594001236820079f64,
        1.734171606432425f64,
        3.0699533280603655f64,
        5.241627996900319f64,
        1.9898901100379935f64,
        0.864134346731335f64,
    ],
    theta1: [
        1596.503281347521f64,
        787.7927551311844f64,
        84.66068602648895f64,
        20.792107379008446f64,
        4.574507969477138f64,
        1.1222467090323538f64,
        41.58421475801689f64,
        105.9414855960558f64,
        3193.006562695042f64,
        1575.5855102623689f64,
        84.65553032387855f64,
        20.80363527871787f64,
        4.582318317879813f64,
        105.94580703128374f64,
        1.1222467090323538f64,
    ],
};
const DECLINATION_JUPITER: RotationalElement<15usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: 1.1256553894213766f64,
    c1: 0.00004211479485062318f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0.0000008726646259971648f64,
        0.000007051130178057092f64,
        0.000010768681484805013f64,
        -0.00000022689280275926283f64,
        0.00001616174887346749f64,
    ],
    theta0: [
        1.2796754075622423f64,
        0.42970006184100396f64,
        4.9549897464119015f64,
        6.2098814785958245f64,
        2.092649773141201f64,
        4.010766621082969f64,
        6.147922290150026f64,
        1.9783307071355725f64,
        2.5593508151244846f64,
        0.8594001236820079f64,
        1.734171606432425f64,
        3.0699533280603655f64,
        5.241627996900319f64,
        1.9898901100379935f64,
        0.864134346731335f64,
    ],
    theta1: [
        1596.503281347521f64,
        787.7927551311844f64,
        84.66068602648895f64,
        20.792107379008446f64,
        4.574507969477138f64,
        1.1222467090323538f64,
        41.58421475801689f64,
        105.9414855960558f64,
        3193.006562695042f64,
        1575.5855102623689f64,
        84.65553032387855f64,
        20.80363527871787f64,
        4.582318317879813f64,
        105.94580703128374f64,
        1.1222467090323538f64,
    ],
};
const ROTATION_JUPITER: RotationalElement<15usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 4.973315703557842f64,
    c1: 15.193719457141356f64,
    c2: 0f64,
    c: [
        0f64, 0f64, 0f64, 0f64, 0f64, 0f64, 0f64, 0f64, 0f64, 0f64, 0f64, 0f64, 0f64, 0f64, 0f64,
    ],
    theta0: [
        1.2796754075622423f64,
        0.42970006184100396f64,
        4.9549897464119015f64,
        6.2098814785958245f64,
        2.092649773141201f64,
        4.010766621082969f64,
        6.147922290150026f64,
        1.9783307071355725f64,
        2.5593508151244846f64,
        0.8594001236820079f64,
        1.734171606432425f64,
        3.0699533280603655f64,
        5.241627996900319f64,
        1.9898901100379935f64,
        0.864134346731335f64,
    ],
    theta1: [
        1596.503281347521f64,
        787.7927551311844f64,
        84.66068602648895f64,
        20.792107379008446f64,
        4.574507969477138f64,
        1.1222467090323538f64,
        41.58421475801689f64,
        105.9414855960558f64,
        3193.006562695042f64,
        1575.5855102623689f64,
        84.65553032387855f64,
        20.80363527871787f64,
        4.582318317879813f64,
        105.94580703128374f64,
        1.1222467090323538f64,
    ],
};
impl RotationalElements for Jupiter {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_JUPITER.angle(t),
            DECLINATION_JUPITER.angle(t),
            ROTATION_JUPITER.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_JUPITER.angle_dot(t),
            DECLINATION_JUPITER.angle_dot(t),
            ROTATION_JUPITER.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Saturn;
impl Origin for Saturn {
    fn id(&self) -> NaifId {
        NaifId(699i32)
    }
    fn name(&self) -> &'static str {
        "Saturn"
    }
}
impl Display for Saturn {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for Saturn {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(37931206.23436167f64)
    }
}
impl MeanRadius for Saturn {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(58232f64)
    }
}
impl TriaxialEllipsoid for Saturn {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(60268f64),
            Distance::kilometers(60268f64),
            Distance::kilometers(54364f64),
        )
    }
}
impl Spheroid for Saturn {}
const RIGHT_ASCENSION_SATURN: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 0.7084116900919784f64,
    c1: -0.0006283185307179586f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
const DECLINATION_SATURN: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: 1.457995697238503f64,
    c1: -0.00006981317007977319f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
const ROTATION_SATURN: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 0.6789330790257941f64,
    c1: 14.151023151973554f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
impl RotationalElements for Saturn {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_SATURN.angle(t),
            DECLINATION_SATURN.angle(t),
            ROTATION_SATURN.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_SATURN.angle_dot(t),
            DECLINATION_SATURN.angle_dot(t),
            ROTATION_SATURN.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Uranus;
impl Origin for Uranus {
    fn id(&self) -> NaifId {
        NaifId(799i32)
    }
    fn name(&self) -> &'static str {
        "Uranus"
    }
}
impl Display for Uranus {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for Uranus {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(5793951.256527211f64)
    }
}
impl MeanRadius for Uranus {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(25362f64)
    }
}
impl TriaxialEllipsoid for Uranus {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(25559f64),
            Distance::kilometers(25559f64),
            Distance::kilometers(24973f64),
        )
    }
}
impl Spheroid for Uranus {}
const RIGHT_ASCENSION_URANUS: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 4.4909241515991285f64,
    c1: 0f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
const DECLINATION_URANUS: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: -0.2648537139901395f64,
    c1: 0f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
const ROTATION_URANUS: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 3.557155548489643f64,
    c1: -8.746893698960328f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
impl RotationalElements for Uranus {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_URANUS.angle(t),
            DECLINATION_URANUS.angle(t),
            ROTATION_URANUS.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_URANUS.angle_dot(t),
            DECLINATION_URANUS.angle_dot(t),
            ROTATION_URANUS.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Neptune;
impl Origin for Neptune {
    fn id(&self) -> NaifId {
        NaifId(899i32)
    }
    fn name(&self) -> &'static str {
        "Neptune"
    }
}
impl Display for Neptune {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for Neptune {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(6835103.145462294f64)
    }
}
impl MeanRadius for Neptune {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(24622f64)
    }
}
impl TriaxialEllipsoid for Neptune {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(24764f64),
            Distance::kilometers(24764f64),
            Distance::kilometers(24341f64),
        )
    }
}
impl Spheroid for Neptune {}
const RIGHT_ASCENSION_NEPTUNE: RotationalElement<8usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 5.224817648770225f64,
    c1: 0f64,
    c2: 0f64,
    c: [
        0.012217304763960306f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
    ],
    theta0: [
        6.245660728261709f64,
        5.653470513060032f64,
        3.848625533572696f64,
        6.183177941040311f64,
        1.3144074596769295f64,
        0.6171484235051949f64,
        2.4890140462691135f64,
        3.104068074671915f64,
    ],
    theta1: [
        0.9130864514733535f64,
        1092.6913034790819f64,
        961.0515899766616f64,
        812.7038395448996f64,
        455.6949957202075f64,
        250.02539666519567f64,
        49.29857005183183f64,
        0.9130864514733535f64,
    ],
};
const DECLINATION_NEPTUNE: RotationalElement<8usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: 0.7585200929167356f64,
    c1: 0f64,
    c2: 0f64,
    c: [
        -0.00890117918517108f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
    ],
    theta0: [
        6.245660728261709f64,
        5.653470513060032f64,
        3.848625533572696f64,
        6.183177941040311f64,
        1.3144074596769295f64,
        0.6171484235051949f64,
        2.4890140462691135f64,
        3.104068074671915f64,
    ],
    theta1: [
        0.9130864514733535f64,
        1092.6913034790819f64,
        961.0515899766616f64,
        812.7038395448996f64,
        455.6949957202075f64,
        250.02539666519567f64,
        49.29857005183183f64,
        0.9130864514733535f64,
    ],
};
const ROTATION_NEPTUNE: RotationalElement<8usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 4.362939157550385f64,
    c1: 9.444670799468602f64,
    c2: 0f64,
    c: [
        -0.008377580409572781f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
    ],
    theta0: [
        6.245660728261709f64,
        5.653470513060032f64,
        3.848625533572696f64,
        6.183177941040311f64,
        1.3144074596769295f64,
        0.6171484235051949f64,
        2.4890140462691135f64,
        3.104068074671915f64,
    ],
    theta1: [
        0.9130864514733535f64,
        1092.6913034790819f64,
        961.0515899766616f64,
        812.7038395448996f64,
        455.6949957202075f64,
        250.02539666519567f64,
        49.29857005183183f64,
        0.9130864514733535f64,
    ],
};
impl RotationalElements for Neptune {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_NEPTUNE.angle(t),
            DECLINATION_NEPTUNE.angle(t),
            ROTATION_NEPTUNE.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_NEPTUNE.angle_dot(t),
            DECLINATION_NEPTUNE.angle_dot(t),
            ROTATION_NEPTUNE.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Pluto;
impl Origin for Pluto {
    fn id(&self) -> NaifId {
        NaifId(999i32)
    }
    fn name(&self) -> &'static str {
        "Pluto"
    }
}
impl Display for Pluto {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for Pluto {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(869.6138177608748f64)
    }
}
impl MeanRadius for Pluto {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(1188.3f64)
    }
}
impl TriaxialEllipsoid for Pluto {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(1188.3f64),
            Distance::kilometers(1188.3f64),
            Distance::kilometers(1188.3f64),
        )
    }
}
impl Spheroid for Pluto {}
const RIGHT_ASCENSION_PLUTO: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 2.3211657321048187f64,
    c1: 0f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
const DECLINATION_PLUTO: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: -0.10756464180041053f64,
    c1: 0f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
const ROTATION_PLUTO: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 5.283024379324235f64,
    c1: 0.9837115923543857f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
impl RotationalElements for Pluto {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_PLUTO.angle(t),
            DECLINATION_PLUTO.angle(t),
            ROTATION_PLUTO.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_PLUTO.angle_dot(t),
            DECLINATION_PLUTO.angle_dot(t),
            ROTATION_PLUTO.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct SolarSystemBarycenter;
impl Origin for SolarSystemBarycenter {
    fn id(&self) -> NaifId {
        NaifId(0i32)
    }
    fn name(&self) -> &'static str {
        "Solar System Barycenter"
    }
}
impl Display for SolarSystemBarycenter {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for SolarSystemBarycenter {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(132712440041.27942f64)
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct MercuryBarycenter;
impl Origin for MercuryBarycenter {
    fn id(&self) -> NaifId {
        NaifId(1i32)
    }
    fn name(&self) -> &'static str {
        "Mercury Barycenter"
    }
}
impl Display for MercuryBarycenter {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for MercuryBarycenter {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(22031.868551400003f64)
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct VenusBarycenter;
impl Origin for VenusBarycenter {
    fn id(&self) -> NaifId {
        NaifId(2i32)
    }
    fn name(&self) -> &'static str {
        "Venus Barycenter"
    }
}
impl Display for VenusBarycenter {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for VenusBarycenter {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(324858.592f64)
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct EarthBarycenter;
impl Origin for EarthBarycenter {
    fn id(&self) -> NaifId {
        NaifId(3i32)
    }
    fn name(&self) -> &'static str {
        "Earth Barycenter"
    }
}
impl Display for EarthBarycenter {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for EarthBarycenter {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(403503.2356254802f64)
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct MarsBarycenter;
impl Origin for MarsBarycenter {
    fn id(&self) -> NaifId {
        NaifId(4i32)
    }
    fn name(&self) -> &'static str {
        "Mars Barycenter"
    }
}
impl Display for MarsBarycenter {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for MarsBarycenter {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(42828.3758157561f64)
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct JupiterBarycenter;
impl Origin for JupiterBarycenter {
    fn id(&self) -> NaifId {
        NaifId(5i32)
    }
    fn name(&self) -> &'static str {
        "Jupiter Barycenter"
    }
}
impl Display for JupiterBarycenter {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for JupiterBarycenter {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(126712764.09999998f64)
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct SaturnBarycenter;
impl Origin for SaturnBarycenter {
    fn id(&self) -> NaifId {
        NaifId(6i32)
    }
    fn name(&self) -> &'static str {
        "Saturn Barycenter"
    }
}
impl Display for SaturnBarycenter {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for SaturnBarycenter {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(37940584.8418f64)
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UranusBarycenter;
impl Origin for UranusBarycenter {
    fn id(&self) -> NaifId {
        NaifId(7i32)
    }
    fn name(&self) -> &'static str {
        "Uranus Barycenter"
    }
}
impl Display for UranusBarycenter {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for UranusBarycenter {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(5794556.3999999985f64)
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct NeptuneBarycenter;
impl Origin for NeptuneBarycenter {
    fn id(&self) -> NaifId {
        NaifId(8i32)
    }
    fn name(&self) -> &'static str {
        "Neptune Barycenter"
    }
}
impl Display for NeptuneBarycenter {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for NeptuneBarycenter {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(6836527.100580399f64)
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct PlutoBarycenter;
impl Origin for PlutoBarycenter {
    fn id(&self) -> NaifId {
        NaifId(9i32)
    }
    fn name(&self) -> &'static str {
        "Pluto Barycenter"
    }
}
impl Display for PlutoBarycenter {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for PlutoBarycenter {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(975.5f64)
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Moon;
impl Origin for Moon {
    fn id(&self) -> NaifId {
        NaifId(301i32)
    }
    fn name(&self) -> &'static str {
        "Moon"
    }
}
impl Display for Moon {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for Moon {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(4902.80011845755f64)
    }
}
impl MeanRadius for Moon {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(1737.4f64)
    }
}
impl TriaxialEllipsoid for Moon {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(1737.4f64),
            Distance::kilometers(1737.4f64),
            Distance::kilometers(1737.4f64),
        )
    }
}
impl Spheroid for Moon {}
const RIGHT_ASCENSION_MOON: RotationalElement<13usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 4.712299968592838f64,
    c1: 0.000054105206811824215f64,
    c2: 0f64,
    c: [
        -0.06769608569710406f64,
        -0.0021013764194011725f64,
        0.0012217304763960308f64,
        -0.0003001966313430247f64,
        0f64,
        0.0001256637061435917f64,
        0f64,
        0f64,
        0f64,
        -0.00009075712110370513f64,
        0f64,
        0f64,
        0.00007504915783575618f64,
    ],
    theta0: [
        2.1824469631563095f64,
        4.364876473020098f64,
        4.537995681525416f64,
        3.0826877913349846f64,
        6.240058221362807f64,
        5.438253962996612f64,
        2.355548718369107f64,
        4.827877416989155f64,
        0.5973563897875792f64,
        0.2641381289968218f64,
        2.0899096062155698f64,
        4.188109526378113f64,
        0.4372573375021394f64,
    ],
    theta1: [
        -33.781483888495835f64,
        -67.56296777699167f64,
        8294.909972626925f64,
        8504.459388212737f64,
        628.3019668015924f64,
        16833.15084472816f64,
        8328.69145651542f64,
        209.54947933396397f64,
        1114.6285779726247f64,
        -101.3444516654875f64,
        2.301053255936537f64,
        104.77473966698199f64,
        8261.12848873843f64,
    ],
};
const DECLINATION_MOON: RotationalElement<13usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: 1.161328121643011f64,
    c1: 0.00022689280275926284f64,
    c2: 0f64,
    c: [
        0.02691123173650057f64,
        0.0004171336912266448f64,
        -0.00048520153205442357f64,
        0.0001186823891356144f64,
        0f64,
        -0.00005061454830783555f64,
        0.000015707963267948964f64,
        0f64,
        0f64,
        0.000013962634015954637f64,
        0f64,
        0f64,
        -0.000015707963267948964f64,
    ],
    theta0: [
        2.1824469631563095f64,
        4.364876473020098f64,
        4.537995681525416f64,
        3.0826877913349846f64,
        6.240058221362807f64,
        5.438253962996612f64,
        2.355548718369107f64,
        4.827877416989155f64,
        0.5973563897875792f64,
        0.2641381289968218f64,
        2.0899096062155698f64,
        4.188109526378113f64,
        0.4372573375021394f64,
    ],
    theta1: [
        -33.781483888495835f64,
        -67.56296777699167f64,
        8294.909972626925f64,
        8504.459388212737f64,
        628.3019668015924f64,
        16833.15084472816f64,
        8328.69145651542f64,
        209.54947933396397f64,
        1114.6285779726247f64,
        -101.3444516654875f64,
        2.301053255936537f64,
        104.77473966698199f64,
        8261.12848873843f64,
    ],
};
const ROTATION_MOON: RotationalElement<13usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 0.668832858644503f64,
    c1: 0.22997083313948888f64,
    c2: -0.000000000000024434609527920614f64,
    c: [
        0.06215117466351808f64,
        0.00210835773640915f64,
        -0.0011205013797803594f64,
        0.0002757620218151041f64,
        0.0004398229715025711f64,
        -0.00011519173063162575f64,
        -0.00008203047484373349f64,
        -0.00008028514559173915f64,
        0.000048869219055841225f64,
        0.00009075712110370513f64,
        0.00006981317007977319f64,
        0.00003316125578789226f64,
        -0.0000767944870877505f64,
    ],
    theta0: [
        2.1824469631563095f64,
        4.364876473020098f64,
        4.537995681525416f64,
        3.0826877913349846f64,
        6.240058221362807f64,
        5.438253962996612f64,
        2.355548718369107f64,
        4.827877416989155f64,
        0.5973563897875792f64,
        0.2641381289968218f64,
        2.0899096062155698f64,
        4.188109526378113f64,
        0.4372573375021394f64,
    ],
    theta1: [
        -33.781483888495835f64,
        -67.56296777699167f64,
        8294.909972626925f64,
        8504.459388212737f64,
        628.3019668015924f64,
        16833.15084472816f64,
        8328.69145651542f64,
        209.54947933396397f64,
        1114.6285779726247f64,
        -101.3444516654875f64,
        2.301053255936537f64,
        104.77473966698199f64,
        8261.12848873843f64,
    ],
};
impl RotationalElements for Moon {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_MOON.angle(t),
            DECLINATION_MOON.angle(t),
            ROTATION_MOON.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_MOON.angle_dot(t),
            DECLINATION_MOON.angle_dot(t),
            ROTATION_MOON.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Phobos;
impl Origin for Phobos {
    fn id(&self) -> NaifId {
        NaifId(401i32)
    }
    fn name(&self) -> &'static str {
        "Phobos"
    }
}
impl Display for Phobos {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for Phobos {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(0.0007087546066894452f64)
    }
}
impl MeanRadius for Phobos {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(11.08f64)
    }
}
impl TriaxialEllipsoid for Phobos {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(13f64),
            Distance::kilometers(11.4f64),
            Distance::kilometers(9.1f64),
        )
    }
}
const RIGHT_ASCENSION_PHOBOS: RotationalElement<4usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 5.544399941316208f64,
    c1: -0.001892691938596266f64,
    c2: 0f64,
    c: [
        -0.031141630416121578f64,
        0.00038621064567151f64,
        -0.00017946365486924213f64,
        -0.00008300698656022431f64,
    ],
    theta0: [
        3.328804809897935f64,
        0.37470342287773584f64,
        5.809517398292802f64,
        6.892873571600945f64,
    ],
    theta1: [
        277.80594525842264f64,
        555.6129894920322f64,
        334.05422022489097f64,
        668.125936040531f64,
    ],
};
const DECLINATION_PHOBOS: RotationalElement<4usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: 0.9230395870244597f64,
    c1: -0.0010707081834185127f64,
    c2: 0f64,
    c: [
        -0.018765175709923063f64,
        0.00011669725164439606f64,
        -0.00011322648989388013f64,
        0.000049144282945955534f64,
    ],
    theta0: [
        3.328804809897935f64,
        0.37470342287773584f64,
        5.809517398292802f64,
        6.892873571600945f64,
    ],
    theta1: [
        277.80594525842264f64,
        555.6129894920322f64,
        334.05422022489097f64,
        668.125936040531f64,
    ],
};
const ROTATION_PHOBOS: RotationalElement<5usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 0.6141419961301966f64,
    c1: 19.702057793318815f64,
    c2: 0.00000000016643698911600935f64,
    c: [
        0.02485728795564792f64,
        -0.0003968499982587423f64,
        0.0000716825922415843f64,
        0.00011029852554073445f64,
        -0.019949113350295186f64,
    ],
    theta0: [
        3.328804809897935f64,
        0.37470342287773584f64,
        5.809517398292802f64,
        6.892873571600945f64,
        3.3097152567180146f64,
    ],
    theta1: [
        277.80594525842264f64,
        555.6129894920322f64,
        334.05422022489097f64,
        668.125936040531f64,
        719340.2120445863f64,
    ],
};
impl RotationalElements for Phobos {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_PHOBOS.angle(t),
            DECLINATION_PHOBOS.angle(t),
            ROTATION_PHOBOS.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_PHOBOS.angle_dot(t),
            DECLINATION_PHOBOS.angle_dot(t),
            ROTATION_PHOBOS.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Deimos;
impl Origin for Deimos {
    fn id(&self) -> NaifId {
        NaifId(402i32)
    }
    fn name(&self) -> &'static str {
        "Deimos"
    }
}
impl Display for Deimos {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for Deimos {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(0.00009615569648120313f64)
    }
}
impl MeanRadius for Deimos {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(6.2f64)
    }
}
impl TriaxialEllipsoid for Deimos {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(7.8f64),
            Distance::kilometers(6f64),
            Distance::kilometers(5.1f64),
        )
    }
}
const RIGHT_ASCENSION_DEIMOS: RotationalElement<10usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 5.526708263174914f64,
    c1: -0.0018357397507085887f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0.05396867424229676f64,
        0.004010877798556321f64,
        0.0011202666329959662f64,
        0.00044218562371099577f64,
        0.00013590791618817245f64,
    ],
    theta0: [
        3.328804809897935f64,
        0.37470342287773584f64,
        5.809517398292802f64,
        6.892873571600945f64,
        3.3097152567180146f64,
        2.120032883264378f64,
        4.032588225058434f64,
        4.387288948439982f64,
        3.8045796985836846f64,
        3.424288764152381f64,
    ],
    theta1: [
        277.80594525842264f64,
        555.6129894920322f64,
        334.05422022489097f64,
        668.125936040531f64,
        719340.2120445863f64,
        11.523153020184504f64,
        11.536473384554899f64,
        23.047098122619843f64,
        668.1113614443373f64,
        334.05316148477937f64,
    ],
};
const DECLINATION_DEIMOS: RotationalElement<10usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: 0.9339242922383507f64,
    c1: -0.0010435487658623783f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0.032102888827614605f64,
        0.002500240004017941f64,
        0.00033360380402252296f64,
        -0.0002587607695714273f64,
        0.00003358537079612689f64,
    ],
    theta0: [
        3.328804809897935f64,
        0.37470342287773584f64,
        5.809517398292802f64,
        6.892873571600945f64,
        3.3097152567180146f64,
        2.120032883264378f64,
        4.032588225058434f64,
        4.387288948439982f64,
        3.8045796985836846f64,
        3.424288764152381f64,
    ],
    theta1: [
        277.80594525842264f64,
        555.6129894920322f64,
        334.05422022489097f64,
        668.125936040531f64,
        719340.2120445863f64,
        11.523153020184504f64,
        11.536473384554899f64,
        23.047098122619843f64,
        668.1113614443373f64,
        334.05316148477937f64,
    ],
};
const ROTATION_DEIMOS: RotationalElement<10usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 1.3857797243489947f64,
    c1: 4.977013864082068f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        -0.047814137677880446f64,
        -0.006975837721323607f64,
        -0.0011455047921115052f64,
        -0.0005084039391304362f64,
        0.0002965593651818685f64,
    ],
    theta0: [
        3.328804809897935f64,
        0.37470342287773584f64,
        5.809517398292802f64,
        6.892873571600945f64,
        3.3097152567180146f64,
        2.120032883264378f64,
        4.032588225058434f64,
        4.387288948439982f64,
        3.8045796985836846f64,
        3.424288764152381f64,
    ],
    theta1: [
        277.80594525842264f64,
        555.6129894920322f64,
        334.05422022489097f64,
        668.125936040531f64,
        719340.2120445863f64,
        11.523153020184504f64,
        11.536473384554899f64,
        23.047098122619843f64,
        668.1113614443373f64,
        334.05316148477937f64,
    ],
};
impl RotationalElements for Deimos {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_DEIMOS.angle(t),
            DECLINATION_DEIMOS.angle(t),
            ROTATION_DEIMOS.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_DEIMOS.angle_dot(t),
            DECLINATION_DEIMOS.angle_dot(t),
            ROTATION_DEIMOS.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Io;
impl Origin for Io {
    fn id(&self) -> NaifId {
        NaifId(501i32)
    }
    fn name(&self) -> &'static str {
        "Io"
    }
}
impl Display for Io {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for Io {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(5959.915466180539f64)
    }
}
impl MeanRadius for Io {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(1821.49f64)
    }
}
impl TriaxialEllipsoid for Io {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(1829.4f64),
            Distance::kilometers(1819.4f64),
            Distance::kilometers(1815.7f64),
        )
    }
}
const RIGHT_ASCENSION_IO: RotationalElement<4usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 4.678355059970801f64,
    c1: -0.00015707963267948965f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0.0016406094968746698f64,
        0.0004188790204786391f64,
    ],
    theta0: [
        1.2796754075622423f64,
        0.42970006184100396f64,
        4.9549897464119015f64,
        6.2098814785958245f64,
    ],
    theta1: [
        1596.503281347521f64,
        787.7927551311844f64,
        84.66068602648895f64,
        20.792107379008446f64,
    ],
};
const DECLINATION_IO: RotationalElement<4usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: 1.1257373675363425f64,
    c1: 0.00005235987755982989f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0.0006981317007977319f64,
        0.00019198621771937625f64,
    ],
    theta0: [
        1.2796754075622423f64,
        0.42970006184100396f64,
        4.9549897464119015f64,
        6.2098814785958245f64,
    ],
    theta1: [
        1596.503281347521f64,
        787.7927551311844f64,
        84.66068602648895f64,
        20.792107379008446f64,
    ],
};
const ROTATION_IO: RotationalElement<4usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 3.4974652880714365f64,
    c1: 3.551552235248627f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        -0.0014835298641951802f64,
        -0.0003839724354387525f64,
    ],
    theta0: [
        1.2796754075622423f64,
        0.42970006184100396f64,
        4.9549897464119015f64,
        6.2098814785958245f64,
    ],
    theta1: [
        1596.503281347521f64,
        787.7927551311844f64,
        84.66068602648895f64,
        20.792107379008446f64,
    ],
};
impl RotationalElements for Io {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_IO.angle(t),
            DECLINATION_IO.angle(t),
            ROTATION_IO.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_IO.angle_dot(t),
            DECLINATION_IO.angle_dot(t),
            ROTATION_IO.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Europa;
impl Origin for Europa {
    fn id(&self) -> NaifId {
        NaifId(502i32)
    }
    fn name(&self) -> &'static str {
        "Europa"
    }
}
impl Display for Europa {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for Europa {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(3202.712099607295f64)
    }
}
impl MeanRadius for Europa {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(1560.8f64)
    }
}
impl TriaxialEllipsoid for Europa {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(1562.6f64),
            Distance::kilometers(1560.3f64),
            Distance::kilometers(1559.5f64),
        )
    }
}
const RIGHT_ASCENSION_EUROPA: RotationalElement<7usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 4.678878658746398f64,
    c1: -0.00015707963267948965f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0f64,
        0.01895427567665842f64,
        0.0010471975511965976f64,
        0.0002617993877991494f64,
        0.00015707963267948965f64,
    ],
    theta0: [
        1.2796754075622423f64,
        0.42970006184100396f64,
        4.9549897464119015f64,
        6.2098814785958245f64,
        2.092649773141201f64,
        4.010766621082969f64,
        6.147922290150026f64,
    ],
    theta1: [
        1596.503281347521f64,
        787.7927551311844f64,
        84.66068602648895f64,
        20.792107379008446f64,
        4.574507969477138f64,
        1.1222467090323538f64,
        41.58421475801689f64,
    ],
};
const DECLINATION_EUROPA: RotationalElement<7usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: 1.125911900461542f64,
    c1: 0.00005235987755982989f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0f64,
        0.008168140899333463f64,
        0.0004537856055185257f64,
        0.00012217304763960306f64,
        0.00003490658503988659f64,
    ],
    theta0: [
        1.2796754075622423f64,
        0.42970006184100396f64,
        4.9549897464119015f64,
        6.2098814785958245f64,
        2.092649773141201f64,
        4.010766621082969f64,
        6.147922290150026f64,
    ],
    theta1: [
        1596.503281347521f64,
        787.7927551311844f64,
        84.66068602648895f64,
        20.792107379008446f64,
        4.574507969477138f64,
        1.1222467090323538f64,
        41.58421475801689f64,
    ],
};
const ROTATION_EUROPA: RotationalElement<7usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 0.6287025031533974f64,
    c1: 1.7693227033738699f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0f64,
        -0.01710422666954443f64,
        -0.0009424777960769379f64,
        -0.0002443460952792061f64,
        -0.00013962634015954637f64,
    ],
    theta0: [
        1.2796754075622423f64,
        0.42970006184100396f64,
        4.9549897464119015f64,
        6.2098814785958245f64,
        2.092649773141201f64,
        4.010766621082969f64,
        6.147922290150026f64,
    ],
    theta1: [
        1596.503281347521f64,
        787.7927551311844f64,
        84.66068602648895f64,
        20.792107379008446f64,
        4.574507969477138f64,
        1.1222467090323538f64,
        41.58421475801689f64,
    ],
};
impl RotationalElements for Europa {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_EUROPA.angle(t),
            DECLINATION_EUROPA.angle(t),
            ROTATION_EUROPA.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_EUROPA.angle_dot(t),
            DECLINATION_EUROPA.angle_dot(t),
            ROTATION_EUROPA.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Ganymede;
impl Origin for Ganymede {
    fn id(&self) -> NaifId {
        NaifId(503i32)
    }
    fn name(&self) -> &'static str {
        "Ganymede"
    }
}
impl Display for Ganymede {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for Ganymede {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(9887.832752719638f64)
    }
}
impl MeanRadius for Ganymede {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(2631.2f64)
    }
}
impl TriaxialEllipsoid for Ganymede {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(2631.2f64),
            Distance::kilometers(2631.2f64),
            Distance::kilometers(2631.2f64),
        )
    }
}
impl Spheroid for Ganymede {}
const RIGHT_ASCENSION_GANYMEDE: RotationalElement<6usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 4.680973053848792f64,
    c1: -0.00015707963267948965f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0f64,
        -0.0006457718232379018f64,
        0.0075223690760955605f64,
        0.0015882496193148398f64,
    ],
    theta0: [
        1.2796754075622423f64,
        0.42970006184100396f64,
        4.9549897464119015f64,
        6.2098814785958245f64,
        2.092649773141201f64,
        4.010766621082969f64,
    ],
    theta1: [
        1596.503281347521f64,
        787.7927551311844f64,
        84.66068602648895f64,
        20.792107379008446f64,
        4.574507969477138f64,
        1.1222467090323538f64,
    ],
};
const DECLINATION_GANYMEDE: RotationalElement<6usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: 1.1269590980127384f64,
    c1: 0.00005235987755982989f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0f64,
        -0.00027925268031909274f64,
        0.003246312408709453f64,
        0.0006806784082777885f64,
    ],
    theta0: [
        1.2796754075622423f64,
        0.42970006184100396f64,
        4.9549897464119015f64,
        6.2098814785958245f64,
        2.092649773141201f64,
        4.010766621082969f64,
    ],
    theta1: [
        1596.503281347521f64,
        787.7927551311844f64,
        84.66068602648895f64,
        20.792107379008446f64,
        4.574507969477138f64,
        1.1222467090323538f64,
    ],
};
const ROTATION_GANYMEDE: RotationalElement<6usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 0.7690618815987814f64,
    c1: 0.8782079330731682f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0f64,
        0.0005759586531581288f64,
        -0.006789330790257942f64,
        -0.0014311699866353504f64,
    ],
    theta0: [
        1.2796754075622423f64,
        0.42970006184100396f64,
        4.9549897464119015f64,
        6.2098814785958245f64,
        2.092649773141201f64,
        4.010766621082969f64,
    ],
    theta1: [
        1596.503281347521f64,
        787.7927551311844f64,
        84.66068602648895f64,
        20.792107379008446f64,
        4.574507969477138f64,
        1.1222467090323538f64,
    ],
};
impl RotationalElements for Ganymede {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_GANYMEDE.angle(t),
            DECLINATION_GANYMEDE.angle(t),
            ROTATION_GANYMEDE.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_GANYMEDE.angle_dot(t),
            DECLINATION_GANYMEDE.angle_dot(t),
            ROTATION_GANYMEDE.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Callisto;
impl Origin for Callisto {
    fn id(&self) -> NaifId {
        NaifId(504i32)
    }
    fn name(&self) -> &'static str {
        "Callisto"
    }
}
impl Display for Callisto {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for Callisto {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(7179.283402579837f64)
    }
}
impl MeanRadius for Callisto {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(2410.3f64)
    }
}
impl TriaxialEllipsoid for Callisto {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(2410.3f64),
            Distance::kilometers(2410.3f64),
            Distance::kilometers(2410.3f64),
        )
    }
}
impl Spheroid for Callisto {}
const RIGHT_ASCENSION_CALLISTO: RotationalElement<8usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 4.690048765959163f64,
    c1: -0.00015707963267948965f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0f64,
        0f64,
        -0.001186823891356144f64,
        0.010297442586766544f64,
        0f64,
        0.00017453292519943296f64,
    ],
    theta0: [
        1.2796754075622423f64,
        0.42970006184100396f64,
        4.9549897464119015f64,
        6.2098814785958245f64,
        2.092649773141201f64,
        4.010766621082969f64,
        6.147922290150026f64,
        1.9783307071355725f64,
    ],
    theta1: [
        1596.503281347521f64,
        787.7927551311844f64,
        84.66068602648895f64,
        20.792107379008446f64,
        4.574507969477138f64,
        1.1222467090323538f64,
        41.58421475801689f64,
        105.9414855960558f64,
    ],
};
const DECLINATION_CALLISTO: RotationalElement<8usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: 1.1314969540679238f64,
    c1: 0.00005235987755982989f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0f64,
        0f64,
        -0.0005061454830783556f64,
        0.004433136300065597f64,
        0f64,
        -0.00006981317007977319f64,
    ],
    theta0: [
        1.2796754075622423f64,
        0.42970006184100396f64,
        4.9549897464119015f64,
        6.2098814785958245f64,
        2.092649773141201f64,
        4.010766621082969f64,
        6.147922290150026f64,
        1.9783307071355725f64,
    ],
    theta1: [
        1596.503281347521f64,
        787.7927551311844f64,
        84.66068602648895f64,
        20.792107379008446f64,
        4.574507969477138f64,
        1.1222467090323538f64,
        41.58421475801689f64,
        105.9414855960558f64,
    ],
};
const ROTATION_CALLISTO: RotationalElement<8usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 4.529303941850484f64,
    c1: 0.37648622085811195f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0f64,
        0f64,
        0.001064650843716541f64,
        -0.009302604913129777f64,
        0f64,
        -0.00015707963267948965f64,
    ],
    theta0: [
        1.2796754075622423f64,
        0.42970006184100396f64,
        4.9549897464119015f64,
        6.2098814785958245f64,
        2.092649773141201f64,
        4.010766621082969f64,
        6.147922290150026f64,
        1.9783307071355725f64,
    ],
    theta1: [
        1596.503281347521f64,
        787.7927551311844f64,
        84.66068602648895f64,
        20.792107379008446f64,
        4.574507969477138f64,
        1.1222467090323538f64,
        41.58421475801689f64,
        105.9414855960558f64,
    ],
};
impl RotationalElements for Callisto {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_CALLISTO.angle(t),
            DECLINATION_CALLISTO.angle(t),
            ROTATION_CALLISTO.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_CALLISTO.angle_dot(t),
            DECLINATION_CALLISTO.angle_dot(t),
            ROTATION_CALLISTO.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Amalthea;
impl Origin for Amalthea {
    fn id(&self) -> NaifId {
        NaifId(505i32)
    }
    fn name(&self) -> &'static str {
        "Amalthea"
    }
}
impl Display for Amalthea {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for Amalthea {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(0.1645634534798259f64)
    }
}
impl MeanRadius for Amalthea {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(83.5f64)
    }
}
impl TriaxialEllipsoid for Amalthea {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(125f64),
            Distance::kilometers(73f64),
            Distance::kilometers(64f64),
        )
    }
}
const RIGHT_ASCENSION_AMALTHEA: RotationalElement<10usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 4.678355059970801f64,
    c1: -0.00015707963267948965f64,
    c2: 0f64,
    c: [
        -0.014660765716752368f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0.00017453292519943296f64,
        0f64,
    ],
    theta0: [
        1.2796754075622423f64,
        0.42970006184100396f64,
        4.9549897464119015f64,
        6.2098814785958245f64,
        2.092649773141201f64,
        4.010766621082969f64,
        6.147922290150026f64,
        1.9783307071355725f64,
        2.5593508151244846f64,
        0.8594001236820079f64,
    ],
    theta1: [
        1596.503281347521f64,
        787.7927551311844f64,
        84.66068602648895f64,
        20.792107379008446f64,
        4.574507969477138f64,
        1.1222467090323538f64,
        41.58421475801689f64,
        105.9414855960558f64,
        3193.006562695042f64,
        1575.5855102623689f64,
    ],
};
const DECLINATION_AMALTHEA: RotationalElement<10usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: 1.125562834611143f64,
    c1: 0.00005235987755982989f64,
    c2: 0f64,
    c: [
        -0.006283185307179586f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
    ],
    theta0: [
        1.2796754075622423f64,
        0.42970006184100396f64,
        4.9549897464119015f64,
        6.2098814785958245f64,
        2.092649773141201f64,
        4.010766621082969f64,
        6.147922290150026f64,
        1.9783307071355725f64,
        2.5593508151244846f64,
        0.8594001236820079f64,
    ],
    theta1: [
        1596.503281347521f64,
        787.7927551311844f64,
        84.66068602648895f64,
        20.792107379008446f64,
        4.574507969477138f64,
        1.1222467090323538f64,
        41.58421475801689f64,
        105.9414855960558f64,
        3193.006562695042f64,
        1575.5855102623689f64,
    ],
};
const ROTATION_AMALTHEA: RotationalElement<10usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 4.043404278095263f64,
    c1: 12.612298185680531f64,
    c2: 0f64,
    c: [
        0.013264502315156905f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        -0.00017453292519943296f64,
        0f64,
    ],
    theta0: [
        1.2796754075622423f64,
        0.42970006184100396f64,
        4.9549897464119015f64,
        6.2098814785958245f64,
        2.092649773141201f64,
        4.010766621082969f64,
        6.147922290150026f64,
        1.9783307071355725f64,
        2.5593508151244846f64,
        0.8594001236820079f64,
    ],
    theta1: [
        1596.503281347521f64,
        787.7927551311844f64,
        84.66068602648895f64,
        20.792107379008446f64,
        4.574507969477138f64,
        1.1222467090323538f64,
        41.58421475801689f64,
        105.9414855960558f64,
        3193.006562695042f64,
        1575.5855102623689f64,
    ],
};
impl RotationalElements for Amalthea {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_AMALTHEA.angle(t),
            DECLINATION_AMALTHEA.angle(t),
            ROTATION_AMALTHEA.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_AMALTHEA.angle_dot(t),
            DECLINATION_AMALTHEA.angle_dot(t),
            ROTATION_AMALTHEA.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Himalia;
impl Origin for Himalia {
    fn id(&self) -> NaifId {
        NaifId(506i32)
    }
    fn name(&self) -> &'static str {
        "Himalia"
    }
}
impl Display for Himalia {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for Himalia {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(0.1515524299611265f64)
    }
}
impl MeanRadius for Himalia {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(85f64)
    }
}
impl TriaxialEllipsoid for Himalia {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(85f64),
            Distance::kilometers(85f64),
            Distance::kilometers(85f64),
        )
    }
}
impl Spheroid for Himalia {}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Elara;
impl Origin for Elara {
    fn id(&self) -> NaifId {
        NaifId(507i32)
    }
    fn name(&self) -> &'static str {
        "Elara"
    }
}
impl Display for Elara {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl MeanRadius for Elara {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(40f64)
    }
}
impl TriaxialEllipsoid for Elara {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(40f64),
            Distance::kilometers(40f64),
            Distance::kilometers(40f64),
        )
    }
}
impl Spheroid for Elara {}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Pasiphae;
impl Origin for Pasiphae {
    fn id(&self) -> NaifId {
        NaifId(508i32)
    }
    fn name(&self) -> &'static str {
        "Pasiphae"
    }
}
impl Display for Pasiphae {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl MeanRadius for Pasiphae {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(18f64)
    }
}
impl TriaxialEllipsoid for Pasiphae {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(18f64),
            Distance::kilometers(18f64),
            Distance::kilometers(18f64),
        )
    }
}
impl Spheroid for Pasiphae {}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Sinope;
impl Origin for Sinope {
    fn id(&self) -> NaifId {
        NaifId(509i32)
    }
    fn name(&self) -> &'static str {
        "Sinope"
    }
}
impl Display for Sinope {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl MeanRadius for Sinope {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(14f64)
    }
}
impl TriaxialEllipsoid for Sinope {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(14f64),
            Distance::kilometers(14f64),
            Distance::kilometers(14f64),
        )
    }
}
impl Spheroid for Sinope {}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Lysithea;
impl Origin for Lysithea {
    fn id(&self) -> NaifId {
        NaifId(510i32)
    }
    fn name(&self) -> &'static str {
        "Lysithea"
    }
}
impl Display for Lysithea {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl MeanRadius for Lysithea {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(12f64)
    }
}
impl TriaxialEllipsoid for Lysithea {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(12f64),
            Distance::kilometers(12f64),
            Distance::kilometers(12f64),
        )
    }
}
impl Spheroid for Lysithea {}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Carme;
impl Origin for Carme {
    fn id(&self) -> NaifId {
        NaifId(511i32)
    }
    fn name(&self) -> &'static str {
        "Carme"
    }
}
impl Display for Carme {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl MeanRadius for Carme {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(15f64)
    }
}
impl TriaxialEllipsoid for Carme {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(15f64),
            Distance::kilometers(15f64),
            Distance::kilometers(15f64),
        )
    }
}
impl Spheroid for Carme {}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Ananke;
impl Origin for Ananke {
    fn id(&self) -> NaifId {
        NaifId(512i32)
    }
    fn name(&self) -> &'static str {
        "Ananke"
    }
}
impl Display for Ananke {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl MeanRadius for Ananke {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(10f64)
    }
}
impl TriaxialEllipsoid for Ananke {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(10f64),
            Distance::kilometers(10f64),
            Distance::kilometers(10f64),
        )
    }
}
impl Spheroid for Ananke {}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Leda;
impl Origin for Leda {
    fn id(&self) -> NaifId {
        NaifId(513i32)
    }
    fn name(&self) -> &'static str {
        "Leda"
    }
}
impl Display for Leda {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl MeanRadius for Leda {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(5f64)
    }
}
impl TriaxialEllipsoid for Leda {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(5f64),
            Distance::kilometers(5f64),
            Distance::kilometers(5f64),
        )
    }
}
impl Spheroid for Leda {}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Thebe;
impl Origin for Thebe {
    fn id(&self) -> NaifId {
        NaifId(514i32)
    }
    fn name(&self) -> &'static str {
        "Thebe"
    }
}
impl Display for Thebe {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for Thebe {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(0.030148f64)
    }
}
impl MeanRadius for Thebe {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(49.3f64)
    }
}
impl TriaxialEllipsoid for Thebe {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(58f64),
            Distance::kilometers(49f64),
            Distance::kilometers(42f64),
        )
    }
}
const RIGHT_ASCENSION_THEBE: RotationalElement<10usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 4.678355059970801f64,
    c1: -0.00015707963267948965f64,
    c2: 0f64,
    c: [
        0f64,
        -0.03682644721708035f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0.0006981317007977319f64,
    ],
    theta0: [
        1.2796754075622423f64,
        0.42970006184100396f64,
        4.9549897464119015f64,
        6.2098814785958245f64,
        2.092649773141201f64,
        4.010766621082969f64,
        6.147922290150026f64,
        1.9783307071355725f64,
        2.5593508151244846f64,
        0.8594001236820079f64,
    ],
    theta1: [
        1596.503281347521f64,
        787.7927551311844f64,
        84.66068602648895f64,
        20.792107379008446f64,
        4.574507969477138f64,
        1.1222467090323538f64,
        41.58421475801689f64,
        105.9414855960558f64,
        3193.006562695042f64,
        1575.5855102623689f64,
    ],
};
const DECLINATION_THEBE: RotationalElement<10usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: 1.125562834611143f64,
    c1: 0.00005235987755982989f64,
    c2: 0f64,
    c: [
        0f64,
        -0.0158824961931484f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0.00017453292519943296f64,
    ],
    theta0: [
        1.2796754075622423f64,
        0.42970006184100396f64,
        4.9549897464119015f64,
        6.2098814785958245f64,
        2.092649773141201f64,
        4.010766621082969f64,
        6.147922290150026f64,
        1.9783307071355725f64,
        2.5593508151244846f64,
        0.8594001236820079f64,
    ],
    theta1: [
        1596.503281347521f64,
        787.7927551311844f64,
        84.66068602648895f64,
        20.792107379008446f64,
        4.574507969477138f64,
        1.1222467090323538f64,
        41.58421475801689f64,
        105.9414855960558f64,
        3193.006562695042f64,
        1575.5855102623689f64,
    ],
};
const ROTATION_THEBE: RotationalElement<10usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 0.1494001839707146f64,
    c1: 9.31482937374367f64,
    c2: 0f64,
    c: [
        0f64,
        0.033335788713091695f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        -0.0006981317007977319f64,
    ],
    theta0: [
        1.2796754075622423f64,
        0.42970006184100396f64,
        4.9549897464119015f64,
        6.2098814785958245f64,
        2.092649773141201f64,
        4.010766621082969f64,
        6.147922290150026f64,
        1.9783307071355725f64,
        2.5593508151244846f64,
        0.8594001236820079f64,
    ],
    theta1: [
        1596.503281347521f64,
        787.7927551311844f64,
        84.66068602648895f64,
        20.792107379008446f64,
        4.574507969477138f64,
        1.1222467090323538f64,
        41.58421475801689f64,
        105.9414855960558f64,
        3193.006562695042f64,
        1575.5855102623689f64,
    ],
};
impl RotationalElements for Thebe {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_THEBE.angle(t),
            DECLINATION_THEBE.angle(t),
            ROTATION_THEBE.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_THEBE.angle_dot(t),
            DECLINATION_THEBE.angle_dot(t),
            ROTATION_THEBE.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Adrastea;
impl Origin for Adrastea {
    fn id(&self) -> NaifId {
        NaifId(515i32)
    }
    fn name(&self) -> &'static str {
        "Adrastea"
    }
}
impl Display for Adrastea {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for Adrastea {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(0.000139f64)
    }
}
impl MeanRadius for Adrastea {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(8.2f64)
    }
}
impl TriaxialEllipsoid for Adrastea {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(10f64),
            Distance::kilometers(8f64),
            Distance::kilometers(7f64),
        )
    }
}
const RIGHT_ASCENSION_ADRASTEA: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 4.678355059970801f64,
    c1: -0.00015707963267948965f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
const DECLINATION_ADRASTEA: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: 1.125562834611143f64,
    c1: 0.00005235987755982989f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
const ROTATION_ADRASTEA: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 0.5810201079889122f64,
    c1: 21.066100687650238f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
impl RotationalElements for Adrastea {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_ADRASTEA.angle(t),
            DECLINATION_ADRASTEA.angle(t),
            ROTATION_ADRASTEA.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_ADRASTEA.angle_dot(t),
            DECLINATION_ADRASTEA.angle_dot(t),
            ROTATION_ADRASTEA.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Metis;
impl Origin for Metis {
    fn id(&self) -> NaifId {
        NaifId(516i32)
    }
    fn name(&self) -> &'static str {
        "Metis"
    }
}
impl Display for Metis {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for Metis {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(0.002501f64)
    }
}
impl MeanRadius for Metis {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(21.5f64)
    }
}
impl TriaxialEllipsoid for Metis {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(30f64),
            Distance::kilometers(20f64),
            Distance::kilometers(17f64),
        )
    }
}
const RIGHT_ASCENSION_METIS: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 4.678355059970801f64,
    c1: -0.00015707963267948965f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
const DECLINATION_METIS: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: 1.125562834611143f64,
    c1: 0.00005235987755982989f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
const ROTATION_METIS: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 6.040410008227175f64,
    c1: 21.3149160457997f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
impl RotationalElements for Metis {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_METIS.angle(t),
            DECLINATION_METIS.angle(t),
            ROTATION_METIS.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_METIS.angle_dot(t),
            DECLINATION_METIS.angle_dot(t),
            ROTATION_METIS.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Callirrhoe;
impl Origin for Callirrhoe {
    fn id(&self) -> NaifId {
        NaifId(517i32)
    }
    fn name(&self) -> &'static str {
        "Callirrhoe"
    }
}
impl Display for Callirrhoe {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Themisto;
impl Origin for Themisto {
    fn id(&self) -> NaifId {
        NaifId(518i32)
    }
    fn name(&self) -> &'static str {
        "Themisto"
    }
}
impl Display for Themisto {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Magaclite;
impl Origin for Magaclite {
    fn id(&self) -> NaifId {
        NaifId(519i32)
    }
    fn name(&self) -> &'static str {
        "Magaclite"
    }
}
impl Display for Magaclite {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Taygete;
impl Origin for Taygete {
    fn id(&self) -> NaifId {
        NaifId(520i32)
    }
    fn name(&self) -> &'static str {
        "Taygete"
    }
}
impl Display for Taygete {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Chaldene;
impl Origin for Chaldene {
    fn id(&self) -> NaifId {
        NaifId(521i32)
    }
    fn name(&self) -> &'static str {
        "Chaldene"
    }
}
impl Display for Chaldene {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Harpalyke;
impl Origin for Harpalyke {
    fn id(&self) -> NaifId {
        NaifId(522i32)
    }
    fn name(&self) -> &'static str {
        "Harpalyke"
    }
}
impl Display for Harpalyke {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Kalyke;
impl Origin for Kalyke {
    fn id(&self) -> NaifId {
        NaifId(523i32)
    }
    fn name(&self) -> &'static str {
        "Kalyke"
    }
}
impl Display for Kalyke {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Iocaste;
impl Origin for Iocaste {
    fn id(&self) -> NaifId {
        NaifId(524i32)
    }
    fn name(&self) -> &'static str {
        "Iocaste"
    }
}
impl Display for Iocaste {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Erinome;
impl Origin for Erinome {
    fn id(&self) -> NaifId {
        NaifId(525i32)
    }
    fn name(&self) -> &'static str {
        "Erinome"
    }
}
impl Display for Erinome {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Isonoe;
impl Origin for Isonoe {
    fn id(&self) -> NaifId {
        NaifId(526i32)
    }
    fn name(&self) -> &'static str {
        "Isonoe"
    }
}
impl Display for Isonoe {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Praxidike;
impl Origin for Praxidike {
    fn id(&self) -> NaifId {
        NaifId(527i32)
    }
    fn name(&self) -> &'static str {
        "Praxidike"
    }
}
impl Display for Praxidike {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Autonoe;
impl Origin for Autonoe {
    fn id(&self) -> NaifId {
        NaifId(528i32)
    }
    fn name(&self) -> &'static str {
        "Autonoe"
    }
}
impl Display for Autonoe {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Thyone;
impl Origin for Thyone {
    fn id(&self) -> NaifId {
        NaifId(529i32)
    }
    fn name(&self) -> &'static str {
        "Thyone"
    }
}
impl Display for Thyone {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Hermippe;
impl Origin for Hermippe {
    fn id(&self) -> NaifId {
        NaifId(530i32)
    }
    fn name(&self) -> &'static str {
        "Hermippe"
    }
}
impl Display for Hermippe {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Aitne;
impl Origin for Aitne {
    fn id(&self) -> NaifId {
        NaifId(531i32)
    }
    fn name(&self) -> &'static str {
        "Aitne"
    }
}
impl Display for Aitne {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Eurydome;
impl Origin for Eurydome {
    fn id(&self) -> NaifId {
        NaifId(532i32)
    }
    fn name(&self) -> &'static str {
        "Eurydome"
    }
}
impl Display for Eurydome {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Euanthe;
impl Origin for Euanthe {
    fn id(&self) -> NaifId {
        NaifId(533i32)
    }
    fn name(&self) -> &'static str {
        "Euanthe"
    }
}
impl Display for Euanthe {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Euporie;
impl Origin for Euporie {
    fn id(&self) -> NaifId {
        NaifId(534i32)
    }
    fn name(&self) -> &'static str {
        "Euporie"
    }
}
impl Display for Euporie {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Orthosie;
impl Origin for Orthosie {
    fn id(&self) -> NaifId {
        NaifId(535i32)
    }
    fn name(&self) -> &'static str {
        "Orthosie"
    }
}
impl Display for Orthosie {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Sponde;
impl Origin for Sponde {
    fn id(&self) -> NaifId {
        NaifId(536i32)
    }
    fn name(&self) -> &'static str {
        "Sponde"
    }
}
impl Display for Sponde {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Kale;
impl Origin for Kale {
    fn id(&self) -> NaifId {
        NaifId(537i32)
    }
    fn name(&self) -> &'static str {
        "Kale"
    }
}
impl Display for Kale {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Pasithee;
impl Origin for Pasithee {
    fn id(&self) -> NaifId {
        NaifId(538i32)
    }
    fn name(&self) -> &'static str {
        "Pasithee"
    }
}
impl Display for Pasithee {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Hegemone;
impl Origin for Hegemone {
    fn id(&self) -> NaifId {
        NaifId(539i32)
    }
    fn name(&self) -> &'static str {
        "Hegemone"
    }
}
impl Display for Hegemone {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Mneme;
impl Origin for Mneme {
    fn id(&self) -> NaifId {
        NaifId(540i32)
    }
    fn name(&self) -> &'static str {
        "Mneme"
    }
}
impl Display for Mneme {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Aoede;
impl Origin for Aoede {
    fn id(&self) -> NaifId {
        NaifId(541i32)
    }
    fn name(&self) -> &'static str {
        "Aoede"
    }
}
impl Display for Aoede {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Thelxinoe;
impl Origin for Thelxinoe {
    fn id(&self) -> NaifId {
        NaifId(542i32)
    }
    fn name(&self) -> &'static str {
        "Thelxinoe"
    }
}
impl Display for Thelxinoe {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Arche;
impl Origin for Arche {
    fn id(&self) -> NaifId {
        NaifId(543i32)
    }
    fn name(&self) -> &'static str {
        "Arche"
    }
}
impl Display for Arche {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Kallichore;
impl Origin for Kallichore {
    fn id(&self) -> NaifId {
        NaifId(544i32)
    }
    fn name(&self) -> &'static str {
        "Kallichore"
    }
}
impl Display for Kallichore {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Helike;
impl Origin for Helike {
    fn id(&self) -> NaifId {
        NaifId(545i32)
    }
    fn name(&self) -> &'static str {
        "Helike"
    }
}
impl Display for Helike {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Carpo;
impl Origin for Carpo {
    fn id(&self) -> NaifId {
        NaifId(546i32)
    }
    fn name(&self) -> &'static str {
        "Carpo"
    }
}
impl Display for Carpo {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Eukelade;
impl Origin for Eukelade {
    fn id(&self) -> NaifId {
        NaifId(547i32)
    }
    fn name(&self) -> &'static str {
        "Eukelade"
    }
}
impl Display for Eukelade {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Cyllene;
impl Origin for Cyllene {
    fn id(&self) -> NaifId {
        NaifId(548i32)
    }
    fn name(&self) -> &'static str {
        "Cyllene"
    }
}
impl Display for Cyllene {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Kore;
impl Origin for Kore {
    fn id(&self) -> NaifId {
        NaifId(549i32)
    }
    fn name(&self) -> &'static str {
        "Kore"
    }
}
impl Display for Kore {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Herse;
impl Origin for Herse {
    fn id(&self) -> NaifId {
        NaifId(550i32)
    }
    fn name(&self) -> &'static str {
        "Herse"
    }
}
impl Display for Herse {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Dia;
impl Origin for Dia {
    fn id(&self) -> NaifId {
        NaifId(553i32)
    }
    fn name(&self) -> &'static str {
        "Dia"
    }
}
impl Display for Dia {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Mimas;
impl Origin for Mimas {
    fn id(&self) -> NaifId {
        NaifId(601i32)
    }
    fn name(&self) -> &'static str {
        "Mimas"
    }
}
impl Display for Mimas {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for Mimas {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(2.503488768152587f64)
    }
}
impl MeanRadius for Mimas {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(198.2f64)
    }
}
impl TriaxialEllipsoid for Mimas {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(207.8f64),
            Distance::kilometers(196.7f64),
            Distance::kilometers(190.6f64),
        )
    }
}
const RIGHT_ASCENSION_MIMAS: RotationalElement<8usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 0.7096508738608943f64,
    c1: -0.0006283185307179586f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0.2366666465704311f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
    ],
    theta0: [
        6.166597313146365f64,
        0.5012585611727715f64,
        3.0962140930379407f64,
        5.235987755982989f64,
        5.523094417936056f64,
        6.0248765778844255f64,
        12.33319462629273f64,
        1.002517122345543f64,
    ],
    theta1: [
        1321.331180819591f64,
        1321.331180819591f64,
        -637.14117008679f64,
        -126.11574641985825f64,
        8.834856673595295f64,
        -17.73778118801837f64,
        2642.662361639182f64,
        2642.662361639182f64,
    ],
};
const DECLINATION_MIMAS: RotationalElement<8usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: 1.457698991265664f64,
    c1: -0.00006981317007977319f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        -0.026703537555513242f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
    ],
    theta0: [
        6.166597313146365f64,
        0.5012585611727715f64,
        3.0962140930379407f64,
        5.235987755982989f64,
        5.523094417936056f64,
        6.0248765778844255f64,
        12.33319462629273f64,
        1.002517122345543f64,
    ],
    theta1: [
        1321.331180819591f64,
        1321.331180819591f64,
        -637.14117008679f64,
        -126.11574641985825f64,
        8.834856673595295f64,
        -17.73778118801837f64,
        2642.662361639182f64,
        2642.662361639182f64,
    ],
};
const ROTATION_MIMAS: RotationalElement<8usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 5.819974923700291f64,
    c1: 6.667062709440567f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        -0.23527038316883564f64,
        0f64,
        -0.7827801695194568f64,
        0f64,
        0f64,
        0f64,
    ],
    theta0: [
        6.166597313146365f64,
        0.5012585611727715f64,
        3.0962140930379407f64,
        5.235987755982989f64,
        5.523094417936056f64,
        6.0248765778844255f64,
        12.33319462629273f64,
        1.002517122345543f64,
    ],
    theta1: [
        1321.331180819591f64,
        1321.331180819591f64,
        -637.14117008679f64,
        -126.11574641985825f64,
        8.834856673595295f64,
        -17.73778118801837f64,
        2642.662361639182f64,
        2642.662361639182f64,
    ],
};
impl RotationalElements for Mimas {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_MIMAS.angle(t),
            DECLINATION_MIMAS.angle(t),
            ROTATION_MIMAS.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_MIMAS.angle_dot(t),
            DECLINATION_MIMAS.angle_dot(t),
            ROTATION_MIMAS.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Enceladus;
impl Origin for Enceladus {
    fn id(&self) -> NaifId {
        NaifId(602i32)
    }
    fn name(&self) -> &'static str {
        "Enceladus"
    }
}
impl Display for Enceladus {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for Enceladus {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(7.210366688598896f64)
    }
}
impl MeanRadius for Enceladus {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(252.1f64)
    }
}
impl TriaxialEllipsoid for Enceladus {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(256.6f64),
            Distance::kilometers(251.4f64),
            Distance::kilometers(248.3f64),
        )
    }
}
const RIGHT_ASCENSION_ENCELADUS: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 0.7096508738608943f64,
    c1: -0.0006283185307179586f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
const DECLINATION_ENCELADUS: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: 1.457698991265664f64,
    c1: -0.00006981317007977319f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
const ROTATION_ENCELADUS: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 0.11030480872604163f64,
    c1: 4.585536698039173f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
impl RotationalElements for Enceladus {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_ENCELADUS.angle(t),
            DECLINATION_ENCELADUS.angle(t),
            ROTATION_ENCELADUS.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_ENCELADUS.angle_dot(t),
            DECLINATION_ENCELADUS.angle_dot(t),
            ROTATION_ENCELADUS.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Tethys;
impl Origin for Tethys {
    fn id(&self) -> NaifId {
        NaifId(603i32)
    }
    fn name(&self) -> &'static str {
        "Tethys"
    }
}
impl Display for Tethys {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for Tethys {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(41.21352885489587f64)
    }
}
impl MeanRadius for Tethys {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(531f64)
    }
}
impl TriaxialEllipsoid for Tethys {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(538.4f64),
            Distance::kilometers(528.3f64),
            Distance::kilometers(526.3f64),
        )
    }
}
const RIGHT_ASCENSION_TETHYS: RotationalElement<8usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 0.7096508738608943f64,
    c1: -0.0006283185307179586f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0f64,
        0.16859880574265224f64,
        0f64,
        0f64,
        0f64,
        0f64,
    ],
    theta0: [
        6.166597313146365f64,
        0.5012585611727715f64,
        3.0962140930379407f64,
        5.235987755982989f64,
        5.523094417936056f64,
        6.0248765778844255f64,
        12.33319462629273f64,
        1.002517122345543f64,
    ],
    theta1: [
        1321.331180819591f64,
        1321.331180819591f64,
        -637.14117008679f64,
        -126.11574641985825f64,
        8.834856673595295f64,
        -17.73778118801837f64,
        2642.662361639182f64,
        2642.662361639182f64,
    ],
};
const DECLINATION_TETHYS: RotationalElement<8usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: 1.457698991265664f64,
    c1: -0.00006981317007977319f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0f64,
        -0.019024088846738195f64,
        0f64,
        0f64,
        0f64,
        0f64,
    ],
    theta0: [
        6.166597313146365f64,
        0.5012585611727715f64,
        3.0962140930379407f64,
        5.235987755982989f64,
        5.523094417936056f64,
        6.0248765778844255f64,
        12.33319462629273f64,
        1.002517122345543f64,
    ],
    theta1: [
        1321.331180819591f64,
        1321.331180819591f64,
        -637.14117008679f64,
        -126.11574641985825f64,
        8.834856673595295f64,
        -17.73778118801837f64,
        2642.662361639182f64,
        2642.662361639182f64,
    ],
};
const ROTATION_TETHYS: RotationalElement<8usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 0.1562069680534925f64,
    c1: 3.328306379991881f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0f64,
        -0.16755160819145562f64,
        0.03892084231947355f64,
        0f64,
        0f64,
        0f64,
    ],
    theta0: [
        6.166597313146365f64,
        0.5012585611727715f64,
        3.0962140930379407f64,
        5.235987755982989f64,
        5.523094417936056f64,
        6.0248765778844255f64,
        12.33319462629273f64,
        1.002517122345543f64,
    ],
    theta1: [
        1321.331180819591f64,
        1321.331180819591f64,
        -637.14117008679f64,
        -126.11574641985825f64,
        8.834856673595295f64,
        -17.73778118801837f64,
        2642.662361639182f64,
        2642.662361639182f64,
    ],
};
impl RotationalElements for Tethys {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_TETHYS.angle(t),
            DECLINATION_TETHYS.angle(t),
            ROTATION_TETHYS.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_TETHYS.angle_dot(t),
            DECLINATION_TETHYS.angle_dot(t),
            ROTATION_TETHYS.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Dione;
impl Origin for Dione {
    fn id(&self) -> NaifId {
        NaifId(604i32)
    }
    fn name(&self) -> &'static str {
        "Dione"
    }
}
impl Display for Dione {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for Dione {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(73.11607172482067f64)
    }
}
impl MeanRadius for Dione {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(561.4f64)
    }
}
impl TriaxialEllipsoid for Dione {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(563.4f64),
            Distance::kilometers(561.3f64),
            Distance::kilometers(559.6f64),
        )
    }
}
const RIGHT_ASCENSION_DIONE: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 0.7096508738608943f64,
    c1: -0.0006283185307179586f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
const DECLINATION_DIONE: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: 1.457698991265664f64,
    c1: -0.00006981317007977319f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
const ROTATION_DIONE: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 6.241297405131723f64,
    c1: 2.295717637805533f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
impl RotationalElements for Dione {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_DIONE.angle(t),
            DECLINATION_DIONE.angle(t),
            ROTATION_DIONE.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_DIONE.angle_dot(t),
            DECLINATION_DIONE.angle_dot(t),
            ROTATION_DIONE.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Rhea;
impl Origin for Rhea {
    fn id(&self) -> NaifId {
        NaifId(605i32)
    }
    fn name(&self) -> &'static str {
        "Rhea"
    }
}
impl Display for Rhea {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for Rhea {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(153.9417519146563f64)
    }
}
impl MeanRadius for Rhea {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(763.5f64)
    }
}
impl TriaxialEllipsoid for Rhea {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(765f64),
            Distance::kilometers(763.1f64),
            Distance::kilometers(762.4f64),
        )
    }
}
const RIGHT_ASCENSION_RHEA: RotationalElement<8usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 0.7047639519553103f64,
    c1: -0.0006283185307179586f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0.054105206811824215f64,
        0f64,
        0f64,
    ],
    theta0: [
        6.166597313146365f64,
        0.5012585611727715f64,
        3.0962140930379407f64,
        5.235987755982989f64,
        5.523094417936056f64,
        6.0248765778844255f64,
        12.33319462629273f64,
        1.002517122345543f64,
    ],
    theta1: [
        1321.331180819591f64,
        1321.331180819591f64,
        -637.14117008679f64,
        -126.11574641985825f64,
        8.834856673595295f64,
        -17.73778118801837f64,
        2642.662361639182f64,
        2642.662361639182f64,
    ],
};
const DECLINATION_RHEA: RotationalElement<8usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: 1.4582225900412622f64,
    c1: -0.00006981317007977319f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        -0.006108652381980153f64,
        0f64,
        0f64,
    ],
    theta0: [
        6.166597313146365f64,
        0.5012585611727715f64,
        3.0962140930379407f64,
        5.235987755982989f64,
        5.523094417936056f64,
        6.0248765778844255f64,
        12.33319462629273f64,
        1.002517122345543f64,
    ],
    theta1: [
        1321.331180819591f64,
        1321.331180819591f64,
        -637.14117008679f64,
        -126.11574641985825f64,
        8.834856673595295f64,
        -17.73778118801837f64,
        2642.662361639182f64,
        2642.662361639182f64,
    ],
};
const ROTATION_RHEA: RotationalElement<8usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 4.104316268989865f64,
    c1: 1.3908537151816638f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        -0.05375614096142535f64,
        0f64,
        0f64,
    ],
    theta0: [
        6.166597313146365f64,
        0.5012585611727715f64,
        3.0962140930379407f64,
        5.235987755982989f64,
        5.523094417936056f64,
        6.0248765778844255f64,
        12.33319462629273f64,
        1.002517122345543f64,
    ],
    theta1: [
        1321.331180819591f64,
        1321.331180819591f64,
        -637.14117008679f64,
        -126.11574641985825f64,
        8.834856673595295f64,
        -17.73778118801837f64,
        2642.662361639182f64,
        2642.662361639182f64,
    ],
};
impl RotationalElements for Rhea {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_RHEA.angle(t),
            DECLINATION_RHEA.angle(t),
            ROTATION_RHEA.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_RHEA.angle_dot(t),
            DECLINATION_RHEA.angle_dot(t),
            ROTATION_RHEA.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Titan;
impl Origin for Titan {
    fn id(&self) -> NaifId {
        NaifId(606i32)
    }
    fn name(&self) -> &'static str {
        "Titan"
    }
}
impl Display for Titan {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for Titan {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(8978.137095521046f64)
    }
}
impl MeanRadius for Titan {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(2575f64)
    }
}
impl TriaxialEllipsoid for Titan {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(2575.15f64),
            Distance::kilometers(2574.78f64),
            Distance::kilometers(2574.47f64),
        )
    }
}
const RIGHT_ASCENSION_TITAN: RotationalElement<8usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 0.6891031125771652f64,
    c1: 0f64,
    c2: 0f64,
    c: [0f64, 0f64, 0f64, 0f64, 0f64, 0f64, 0f64, 0f64],
    theta0: [
        6.166597313146365f64,
        0.5012585611727715f64,
        3.0962140930379407f64,
        5.235987755982989f64,
        5.523094417936056f64,
        6.0248765778844255f64,
        12.33319462629273f64,
        1.002517122345543f64,
    ],
    theta1: [
        1321.331180819591f64,
        1321.331180819591f64,
        -637.14117008679f64,
        -126.11574641985825f64,
        8.834856673595295f64,
        -17.73778118801837f64,
        2642.662361639182f64,
        2642.662361639182f64,
    ],
};
const DECLINATION_TITAN: RotationalElement<8usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: 1.456091543024577f64,
    c1: 0f64,
    c2: 0f64,
    c: [0f64, 0f64, 0f64, 0f64, 0f64, 0f64, 0f64, 0f64],
    theta0: [
        6.166597313146365f64,
        0.5012585611727715f64,
        3.0962140930379407f64,
        5.235987755982989f64,
        5.523094417936056f64,
        6.0248765778844255f64,
        12.33319462629273f64,
        1.002517122345543f64,
    ],
    theta1: [
        1321.331180819591f64,
        1321.331180819591f64,
        -637.14117008679f64,
        -126.11574641985825f64,
        8.834856673595295f64,
        -17.73778118801837f64,
        2642.662361639182f64,
        2642.662361639182f64,
    ],
};
const ROTATION_TITAN: RotationalElement<8usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 3.2565313114798795f64,
    c1: 0.39404258030637335f64,
    c2: 0f64,
    c: [0f64, 0f64, 0f64, 0f64, 0f64, 0f64, 0f64, 0f64],
    theta0: [
        6.166597313146365f64,
        0.5012585611727715f64,
        3.0962140930379407f64,
        5.235987755982989f64,
        5.523094417936056f64,
        6.0248765778844255f64,
        12.33319462629273f64,
        1.002517122345543f64,
    ],
    theta1: [
        1321.331180819591f64,
        1321.331180819591f64,
        -637.14117008679f64,
        -126.11574641985825f64,
        8.834856673595295f64,
        -17.73778118801837f64,
        2642.662361639182f64,
        2642.662361639182f64,
    ],
};
impl RotationalElements for Titan {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_TITAN.angle(t),
            DECLINATION_TITAN.angle(t),
            ROTATION_TITAN.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_TITAN.angle_dot(t),
            DECLINATION_TITAN.angle_dot(t),
            ROTATION_TITAN.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Hyperion;
impl Origin for Hyperion {
    fn id(&self) -> NaifId {
        NaifId(607i32)
    }
    fn name(&self) -> &'static str {
        "Hyperion"
    }
}
impl Display for Hyperion {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for Hyperion {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(0.3704913747932265f64)
    }
}
impl MeanRadius for Hyperion {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(135f64)
    }
}
impl TriaxialEllipsoid for Hyperion {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(180.1f64),
            Distance::kilometers(133f64),
            Distance::kilometers(102.7f64),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Iapetus;
impl Origin for Iapetus {
    fn id(&self) -> NaifId {
        NaifId(608i32)
    }
    fn name(&self) -> &'static str {
        "Iapetus"
    }
}
impl Display for Iapetus {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for Iapetus {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(120.5151060137642f64)
    }
}
impl MeanRadius for Iapetus {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(734.3f64)
    }
}
impl TriaxialEllipsoid for Iapetus {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(745.7f64),
            Distance::kilometers(745.7f64),
            Distance::kilometers(712.1f64),
        )
    }
}
impl Spheroid for Iapetus {}
const RIGHT_ASCENSION_IAPETUS: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 5.552939548145159f64,
    c1: -0.06892305216125608f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
const DECLINATION_IAPETUS: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: 1.3095205377713455f64,
    c1: -0.019949113350295186f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
const ROTATION_IAPETUS: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 6.199409503083858f64,
    c1: 0.07920229445458282f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
impl RotationalElements for Iapetus {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_IAPETUS.angle(t),
            DECLINATION_IAPETUS.angle(t),
            ROTATION_IAPETUS.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_IAPETUS.angle_dot(t),
            DECLINATION_IAPETUS.angle_dot(t),
            ROTATION_IAPETUS.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Phoebe;
impl Origin for Phoebe {
    fn id(&self) -> NaifId {
        NaifId(609i32)
    }
    fn name(&self) -> &'static str {
        "Phoebe"
    }
}
impl Display for Phoebe {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for Phoebe {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(0.5547860052791678f64)
    }
}
impl MeanRadius for Phoebe {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(106.5f64)
    }
}
impl TriaxialEllipsoid for Phoebe {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(109.4f64),
            Distance::kilometers(108.5f64),
            Distance::kilometers(101.8f64),
        )
    }
}
const RIGHT_ASCENSION_PHOEBE: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 6.229080100367762f64,
    c1: 0f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
const DECLINATION_PHOEBE: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: 1.3578661580515883f64,
    c1: 0f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
const ROTATION_PHOEBE: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 3.116808978211474f64,
    c1: 16.26016798998745f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
impl RotationalElements for Phoebe {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_PHOEBE.angle(t),
            DECLINATION_PHOEBE.angle(t),
            ROTATION_PHOEBE.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_PHOEBE.angle_dot(t),
            DECLINATION_PHOEBE.angle_dot(t),
            ROTATION_PHOEBE.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Janus;
impl Origin for Janus {
    fn id(&self) -> NaifId {
        NaifId(610i32)
    }
    fn name(&self) -> &'static str {
        "Janus"
    }
}
impl Display for Janus {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for Janus {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(0.1265765099012197f64)
    }
}
impl MeanRadius for Janus {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(89.2f64)
    }
}
impl TriaxialEllipsoid for Janus {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(101.7f64),
            Distance::kilometers(93f64),
            Distance::kilometers(76.3f64),
        )
    }
}
const RIGHT_ASCENSION_JANUS: RotationalElement<8usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 0.7082546104592989f64,
    c1: -0.0006283185307179586f64,
    c2: 0f64,
    c: [
        0f64,
        -0.028326693759867967f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0.0004014257279586958f64,
    ],
    theta0: [
        6.166597313146365f64,
        0.5012585611727715f64,
        3.0962140930379407f64,
        5.235987755982989f64,
        5.523094417936056f64,
        6.0248765778844255f64,
        12.33319462629273f64,
        1.002517122345543f64,
    ],
    theta1: [
        1321.331180819591f64,
        1321.331180819591f64,
        -637.14117008679f64,
        -126.11574641985825f64,
        8.834856673595295f64,
        -17.73778118801837f64,
        2642.662361639182f64,
        2642.662361639182f64,
    ],
};
const DECLINATION_JANUS: RotationalElement<8usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: 1.457698991265664f64,
    c1: -0.00006981317007977319f64,
    c2: 0f64,
    c: [
        0f64,
        -0.003193952531149623f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0.000017453292519943296f64,
    ],
    theta0: [
        6.166597313146365f64,
        0.5012585611727715f64,
        3.0962140930379407f64,
        5.235987755982989f64,
        5.523094417936056f64,
        6.0248765778844255f64,
        12.33319462629273f64,
        1.002517122345543f64,
    ],
    theta1: [
        1321.331180819591f64,
        1321.331180819591f64,
        -637.14117008679f64,
        -126.11574641985825f64,
        8.834856673595295f64,
        -17.73778118801837f64,
        2642.662361639182f64,
        2642.662361639182f64,
    ],
};
const ROTATION_JANUS: RotationalElement<8usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 1.0267771989482641f64,
    c1: 9.044924285944507f64,
    c2: 0f64,
    c: [
        0f64,
        0.028152160834668535f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        -0.0004014257279586958f64,
    ],
    theta0: [
        6.166597313146365f64,
        0.5012585611727715f64,
        3.0962140930379407f64,
        5.235987755982989f64,
        5.523094417936056f64,
        6.0248765778844255f64,
        12.33319462629273f64,
        1.002517122345543f64,
    ],
    theta1: [
        1321.331180819591f64,
        1321.331180819591f64,
        -637.14117008679f64,
        -126.11574641985825f64,
        8.834856673595295f64,
        -17.73778118801837f64,
        2642.662361639182f64,
        2642.662361639182f64,
    ],
};
impl RotationalElements for Janus {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_JANUS.angle(t),
            DECLINATION_JANUS.angle(t),
            ROTATION_JANUS.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_JANUS.angle_dot(t),
            DECLINATION_JANUS.angle_dot(t),
            ROTATION_JANUS.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Epimetheus;
impl Origin for Epimetheus {
    fn id(&self) -> NaifId {
        NaifId(611i32)
    }
    fn name(&self) -> &'static str {
        "Epimetheus"
    }
}
impl Display for Epimetheus {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for Epimetheus {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(0.03512333288208074f64)
    }
}
impl MeanRadius for Epimetheus {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(58.2f64)
    }
}
impl TriaxialEllipsoid for Epimetheus {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(64.9f64),
            Distance::kilometers(57.3f64),
            Distance::kilometers(53f64),
        )
    }
}
const RIGHT_ASCENSION_EPIMETHEUS: RotationalElement<8usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 0.7082546104592989f64,
    c1: -0.0006283185307179586f64,
    c2: 0f64,
    c: [
        -0.05503023131538121f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0.0015009831567151233f64,
        0f64,
    ],
    theta0: [
        6.166597313146365f64,
        0.5012585611727715f64,
        3.0962140930379407f64,
        5.235987755982989f64,
        5.523094417936056f64,
        6.0248765778844255f64,
        12.33319462629273f64,
        1.002517122345543f64,
    ],
    theta1: [
        1321.331180819591f64,
        1321.331180819591f64,
        -637.14117008679f64,
        -126.11574641985825f64,
        8.834856673595295f64,
        -17.73778118801837f64,
        2642.662361639182f64,
        2642.662361639182f64,
    ],
};
const DECLINATION_EPIMETHEUS: RotationalElement<8usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: 1.457698991265664f64,
    c1: -0.00006981317007977319f64,
    c2: 0f64,
    c: [
        -0.006213372137099813f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0.00008726646259971648f64,
        0f64,
    ],
    theta0: [
        6.166597313146365f64,
        0.5012585611727715f64,
        3.0962140930379407f64,
        5.235987755982989f64,
        5.523094417936056f64,
        6.0248765778844255f64,
        12.33319462629273f64,
        1.002517122345543f64,
    ],
    theta1: [
        1321.331180819591f64,
        1321.331180819591f64,
        -637.14117008679f64,
        -126.11574641985825f64,
        8.834856673595295f64,
        -17.73778118801837f64,
        2642.662361639182f64,
        2642.662361639182f64,
    ],
};
const ROTATION_EPIMETHEUS: RotationalElement<8usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 5.128999072835736f64,
    c1: 9.049370273103856f64,
    c2: 0f64,
    c: [
        0.05468116546498235f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        -0.0015009831567151233f64,
        0f64,
    ],
    theta0: [
        6.166597313146365f64,
        0.5012585611727715f64,
        3.0962140930379407f64,
        5.235987755982989f64,
        5.523094417936056f64,
        6.0248765778844255f64,
        12.33319462629273f64,
        1.002517122345543f64,
    ],
    theta1: [
        1321.331180819591f64,
        1321.331180819591f64,
        -637.14117008679f64,
        -126.11574641985825f64,
        8.834856673595295f64,
        -17.73778118801837f64,
        2642.662361639182f64,
        2642.662361639182f64,
    ],
};
impl RotationalElements for Epimetheus {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_EPIMETHEUS.angle(t),
            DECLINATION_EPIMETHEUS.angle(t),
            ROTATION_EPIMETHEUS.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_EPIMETHEUS.angle_dot(t),
            DECLINATION_EPIMETHEUS.angle_dot(t),
            ROTATION_EPIMETHEUS.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Helene;
impl Origin for Helene {
    fn id(&self) -> NaifId {
        NaifId(612i32)
    }
    fn name(&self) -> &'static str {
        "Helene"
    }
}
impl Display for Helene {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for Helene {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(0.0004757419551776972f64)
    }
}
impl MeanRadius for Helene {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(18f64)
    }
}
impl TriaxialEllipsoid for Helene {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(22.5f64),
            Distance::kilometers(19.6f64),
            Distance::kilometers(13.3f64),
        )
    }
}
const RIGHT_ASCENSION_HELENE: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 0.7129669994396837f64,
    c1: -0.0006283185307179586f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
const DECLINATION_HELENE: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: 1.4545573986120743f64,
    c1: -0.00006981317007977319f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
const ROTATION_HELENE: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 4.278151062488501f64,
    c1: 2.297157080652823f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
impl RotationalElements for Helene {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_HELENE.angle(t),
            DECLINATION_HELENE.angle(t),
            ROTATION_HELENE.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_HELENE.angle_dot(t),
            DECLINATION_HELENE.angle_dot(t),
            ROTATION_HELENE.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Telesto;
impl Origin for Telesto {
    fn id(&self) -> NaifId {
        NaifId(613i32)
    }
    fn name(&self) -> &'static str {
        "Telesto"
    }
}
impl Display for Telesto {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl MeanRadius for Telesto {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(12.4f64)
    }
}
impl TriaxialEllipsoid for Telesto {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(16.3f64),
            Distance::kilometers(11.8f64),
            Distance::kilometers(9.8f64),
        )
    }
}
const RIGHT_ASCENSION_TELESTO: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 0.8815658051823358f64,
    c1: -0.0006283185307179586f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
const DECLINATION_TELESTO: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: 1.4671237692264334f64,
    c1: -0.00006981317007977319f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
const ROTATION_TELESTO: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 0.9927432785343747f64,
    c1: 3.328306811088206f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
impl RotationalElements for Telesto {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_TELESTO.angle(t),
            DECLINATION_TELESTO.angle(t),
            ROTATION_TELESTO.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_TELESTO.angle_dot(t),
            DECLINATION_TELESTO.angle_dot(t),
            ROTATION_TELESTO.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Calypso;
impl Origin for Calypso {
    fn id(&self) -> NaifId {
        NaifId(614i32)
    }
    fn name(&self) -> &'static str {
        "Calypso"
    }
}
impl Display for Calypso {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl MeanRadius for Calypso {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(9.6f64)
    }
}
impl TriaxialEllipsoid for Calypso {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(15.3f64),
            Distance::kilometers(9.3f64),
            Distance::kilometers(6.3f64),
        )
    }
}
const RIGHT_ASCENSION_CALYPSO: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 0.6354743806511354f64,
    c1: -0.0006283185307179586f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
const DECLINATION_CALYPSO: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: 1.4842279958959779f64,
    c1: -0.00006981317007977319f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
const ROTATION_CALYPSO: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 2.679254934736495f64,
    c1: 3.327893239613983f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
impl RotationalElements for Calypso {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_CALYPSO.angle(t),
            DECLINATION_CALYPSO.angle(t),
            ROTATION_CALYPSO.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_CALYPSO.angle_dot(t),
            DECLINATION_CALYPSO.angle_dot(t),
            ROTATION_CALYPSO.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Atlas;
impl Origin for Atlas {
    fn id(&self) -> NaifId {
        NaifId(615i32)
    }
    fn name(&self) -> &'static str {
        "Atlas"
    }
}
impl Display for Atlas {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for Atlas {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(0.0003718871247516475f64)
    }
}
impl MeanRadius for Atlas {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(15.1f64)
    }
}
impl TriaxialEllipsoid for Atlas {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(20.5f64),
            Distance::kilometers(17.8f64),
            Distance::kilometers(9.4f64),
        )
    }
}
const RIGHT_ASCENSION_ATLAS: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 0.7082546104592989f64,
    c1: -0.0006283185307179586f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
const DECLINATION_ATLAS: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: 1.4578735241908636f64,
    c1: -0.00006981317007977319f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
const ROTATION_ATLAS: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 2.4064599726497815f64,
    c1: 10.442409634437194f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
impl RotationalElements for Atlas {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_ATLAS.angle(t),
            DECLINATION_ATLAS.angle(t),
            ROTATION_ATLAS.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_ATLAS.angle_dot(t),
            DECLINATION_ATLAS.angle_dot(t),
            ROTATION_ATLAS.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Prometheus;
impl Origin for Prometheus {
    fn id(&self) -> NaifId {
        NaifId(616i32)
    }
    fn name(&self) -> &'static str {
        "Prometheus"
    }
}
impl Display for Prometheus {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for Prometheus {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(0.0107520800100761f64)
    }
}
impl MeanRadius for Prometheus {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(43.1f64)
    }
}
impl TriaxialEllipsoid for Prometheus {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(68.2f64),
            Distance::kilometers(41.6f64),
            Distance::kilometers(28.2f64),
        )
    }
}
const RIGHT_ASCENSION_PROMETHEUS: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 0.7082546104592989f64,
    c1: -0.0006283185307179586f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
const DECLINATION_PROMETHEUS: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: 1.4578735241908636f64,
    c1: -0.00006981317007977319f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
const ROTATION_PROMETHEUS: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 5.1686180468560075f64,
    c1: 10.250126710744977f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
impl RotationalElements for Prometheus {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_PROMETHEUS.angle(t),
            DECLINATION_PROMETHEUS.angle(t),
            ROTATION_PROMETHEUS.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_PROMETHEUS.angle_dot(t),
            DECLINATION_PROMETHEUS.angle_dot(t),
            ROTATION_PROMETHEUS.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Pandora;
impl Origin for Pandora {
    fn id(&self) -> NaifId {
        NaifId(617i32)
    }
    fn name(&self) -> &'static str {
        "Pandora"
    }
}
impl Display for Pandora {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for Pandora {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(0.009290325122028795f64)
    }
}
impl MeanRadius for Pandora {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(40.6f64)
    }
}
impl TriaxialEllipsoid for Pandora {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(52.2f64),
            Distance::kilometers(40.8f64),
            Distance::kilometers(31.5f64),
        )
    }
}
const RIGHT_ASCENSION_PANDORA: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 0.7082546104592989f64,
    c1: -0.0006283185307179586f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
const DECLINATION_PANDORA: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: 1.4578735241908636f64,
    c1: -0.00006981317007977319f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
const ROTATION_PANDORA: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 2.8434904173491615f64,
    c1: 9.997055714535051f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
impl RotationalElements for Pandora {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_PANDORA.angle(t),
            DECLINATION_PANDORA.angle(t),
            ROTATION_PANDORA.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_PANDORA.angle_dot(t),
            DECLINATION_PANDORA.angle_dot(t),
            ROTATION_PANDORA.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Pan;
impl Origin for Pan {
    fn id(&self) -> NaifId {
        NaifId(618i32)
    }
    fn name(&self) -> &'static str {
        "Pan"
    }
}
impl Display for Pan {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl MeanRadius for Pan {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(14f64)
    }
}
impl TriaxialEllipsoid for Pan {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(17.2f64),
            Distance::kilometers(15.4f64),
            Distance::kilometers(10.4f64),
        )
    }
}
const RIGHT_ASCENSION_PAN: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 0.7086036763096978f64,
    c1: -0.0006283185307179586f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
const DECLINATION_PAN: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: 1.457349925415265f64,
    c1: -0.00006981317007977319f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
const ROTATION_PAN: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 0.8517206749732328f64,
    c1: 10.92652906235538f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
impl RotationalElements for Pan {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_PAN.angle(t),
            DECLINATION_PAN.angle(t),
            ROTATION_PAN.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_PAN.angle_dot(t),
            DECLINATION_PAN.angle_dot(t),
            ROTATION_PAN.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Ymir;
impl Origin for Ymir {
    fn id(&self) -> NaifId {
        NaifId(619i32)
    }
    fn name(&self) -> &'static str {
        "Ymir"
    }
}
impl Display for Ymir {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Paaliaq;
impl Origin for Paaliaq {
    fn id(&self) -> NaifId {
        NaifId(620i32)
    }
    fn name(&self) -> &'static str {
        "Paaliaq"
    }
}
impl Display for Paaliaq {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Tarvos;
impl Origin for Tarvos {
    fn id(&self) -> NaifId {
        NaifId(621i32)
    }
    fn name(&self) -> &'static str {
        "Tarvos"
    }
}
impl Display for Tarvos {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Ijiraq;
impl Origin for Ijiraq {
    fn id(&self) -> NaifId {
        NaifId(622i32)
    }
    fn name(&self) -> &'static str {
        "Ijiraq"
    }
}
impl Display for Ijiraq {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Suttungr;
impl Origin for Suttungr {
    fn id(&self) -> NaifId {
        NaifId(623i32)
    }
    fn name(&self) -> &'static str {
        "Suttungr"
    }
}
impl Display for Suttungr {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Kiviuq;
impl Origin for Kiviuq {
    fn id(&self) -> NaifId {
        NaifId(624i32)
    }
    fn name(&self) -> &'static str {
        "Kiviuq"
    }
}
impl Display for Kiviuq {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Mundilfari;
impl Origin for Mundilfari {
    fn id(&self) -> NaifId {
        NaifId(625i32)
    }
    fn name(&self) -> &'static str {
        "Mundilfari"
    }
}
impl Display for Mundilfari {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Albiorix;
impl Origin for Albiorix {
    fn id(&self) -> NaifId {
        NaifId(626i32)
    }
    fn name(&self) -> &'static str {
        "Albiorix"
    }
}
impl Display for Albiorix {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Skathi;
impl Origin for Skathi {
    fn id(&self) -> NaifId {
        NaifId(627i32)
    }
    fn name(&self) -> &'static str {
        "Skathi"
    }
}
impl Display for Skathi {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Erriapus;
impl Origin for Erriapus {
    fn id(&self) -> NaifId {
        NaifId(628i32)
    }
    fn name(&self) -> &'static str {
        "Erriapus"
    }
}
impl Display for Erriapus {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Siarnaq;
impl Origin for Siarnaq {
    fn id(&self) -> NaifId {
        NaifId(629i32)
    }
    fn name(&self) -> &'static str {
        "Siarnaq"
    }
}
impl Display for Siarnaq {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Thrymr;
impl Origin for Thrymr {
    fn id(&self) -> NaifId {
        NaifId(630i32)
    }
    fn name(&self) -> &'static str {
        "Thrymr"
    }
}
impl Display for Thrymr {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Narvi;
impl Origin for Narvi {
    fn id(&self) -> NaifId {
        NaifId(631i32)
    }
    fn name(&self) -> &'static str {
        "Narvi"
    }
}
impl Display for Narvi {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Methone;
impl Origin for Methone {
    fn id(&self) -> NaifId {
        NaifId(632i32)
    }
    fn name(&self) -> &'static str {
        "Methone"
    }
}
impl Display for Methone {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl MeanRadius for Methone {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(1.45f64)
    }
}
impl TriaxialEllipsoid for Methone {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(1.94f64),
            Distance::kilometers(1.29f64),
            Distance::kilometers(1.21f64),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Pallene;
impl Origin for Pallene {
    fn id(&self) -> NaifId {
        NaifId(633i32)
    }
    fn name(&self) -> &'static str {
        "Pallene"
    }
}
impl Display for Pallene {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl MeanRadius for Pallene {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(2.23f64)
    }
}
impl TriaxialEllipsoid for Pallene {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(2.88f64),
            Distance::kilometers(2.08f64),
            Distance::kilometers(1.8f64),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Polydeuces;
impl Origin for Polydeuces {
    fn id(&self) -> NaifId {
        NaifId(634i32)
    }
    fn name(&self) -> &'static str {
        "Polydeuces"
    }
}
impl Display for Polydeuces {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl MeanRadius for Polydeuces {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(1.3f64)
    }
}
impl TriaxialEllipsoid for Polydeuces {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(1.5f64),
            Distance::kilometers(1.2f64),
            Distance::kilometers(1f64),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Daphnis;
impl Origin for Daphnis {
    fn id(&self) -> NaifId {
        NaifId(635i32)
    }
    fn name(&self) -> &'static str {
        "Daphnis"
    }
}
impl Display for Daphnis {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl MeanRadius for Daphnis {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(3.8f64)
    }
}
impl TriaxialEllipsoid for Daphnis {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(4.6f64),
            Distance::kilometers(4.5f64),
            Distance::kilometers(2.8f64),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Aegir;
impl Origin for Aegir {
    fn id(&self) -> NaifId {
        NaifId(636i32)
    }
    fn name(&self) -> &'static str {
        "Aegir"
    }
}
impl Display for Aegir {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Bebhionn;
impl Origin for Bebhionn {
    fn id(&self) -> NaifId {
        NaifId(637i32)
    }
    fn name(&self) -> &'static str {
        "Bebhionn"
    }
}
impl Display for Bebhionn {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Bergelmir;
impl Origin for Bergelmir {
    fn id(&self) -> NaifId {
        NaifId(638i32)
    }
    fn name(&self) -> &'static str {
        "Bergelmir"
    }
}
impl Display for Bergelmir {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Bestla;
impl Origin for Bestla {
    fn id(&self) -> NaifId {
        NaifId(639i32)
    }
    fn name(&self) -> &'static str {
        "Bestla"
    }
}
impl Display for Bestla {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Farbauti;
impl Origin for Farbauti {
    fn id(&self) -> NaifId {
        NaifId(640i32)
    }
    fn name(&self) -> &'static str {
        "Farbauti"
    }
}
impl Display for Farbauti {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Fenrir;
impl Origin for Fenrir {
    fn id(&self) -> NaifId {
        NaifId(641i32)
    }
    fn name(&self) -> &'static str {
        "Fenrir"
    }
}
impl Display for Fenrir {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Fornjot;
impl Origin for Fornjot {
    fn id(&self) -> NaifId {
        NaifId(642i32)
    }
    fn name(&self) -> &'static str {
        "Fornjot"
    }
}
impl Display for Fornjot {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Hati;
impl Origin for Hati {
    fn id(&self) -> NaifId {
        NaifId(643i32)
    }
    fn name(&self) -> &'static str {
        "Hati"
    }
}
impl Display for Hati {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Hyrrokkin;
impl Origin for Hyrrokkin {
    fn id(&self) -> NaifId {
        NaifId(644i32)
    }
    fn name(&self) -> &'static str {
        "Hyrrokkin"
    }
}
impl Display for Hyrrokkin {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Kari;
impl Origin for Kari {
    fn id(&self) -> NaifId {
        NaifId(645i32)
    }
    fn name(&self) -> &'static str {
        "Kari"
    }
}
impl Display for Kari {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Loge;
impl Origin for Loge {
    fn id(&self) -> NaifId {
        NaifId(646i32)
    }
    fn name(&self) -> &'static str {
        "Loge"
    }
}
impl Display for Loge {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Skoll;
impl Origin for Skoll {
    fn id(&self) -> NaifId {
        NaifId(647i32)
    }
    fn name(&self) -> &'static str {
        "Skoll"
    }
}
impl Display for Skoll {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Surtur;
impl Origin for Surtur {
    fn id(&self) -> NaifId {
        NaifId(648i32)
    }
    fn name(&self) -> &'static str {
        "Surtur"
    }
}
impl Display for Surtur {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Anthe;
impl Origin for Anthe {
    fn id(&self) -> NaifId {
        NaifId(649i32)
    }
    fn name(&self) -> &'static str {
        "Anthe"
    }
}
impl Display for Anthe {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl MeanRadius for Anthe {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(0.5f64)
    }
}
impl TriaxialEllipsoid for Anthe {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(0.5f64),
            Distance::kilometers(0.5f64),
            Distance::kilometers(0.5f64),
        )
    }
}
impl Spheroid for Anthe {}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Jarnsaxa;
impl Origin for Jarnsaxa {
    fn id(&self) -> NaifId {
        NaifId(650i32)
    }
    fn name(&self) -> &'static str {
        "Jarnsaxa"
    }
}
impl Display for Jarnsaxa {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Greip;
impl Origin for Greip {
    fn id(&self) -> NaifId {
        NaifId(651i32)
    }
    fn name(&self) -> &'static str {
        "Greip"
    }
}
impl Display for Greip {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Tarqeq;
impl Origin for Tarqeq {
    fn id(&self) -> NaifId {
        NaifId(652i32)
    }
    fn name(&self) -> &'static str {
        "Tarqeq"
    }
}
impl Display for Tarqeq {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Aegaeon;
impl Origin for Aegaeon {
    fn id(&self) -> NaifId {
        NaifId(653i32)
    }
    fn name(&self) -> &'static str {
        "Aegaeon"
    }
}
impl Display for Aegaeon {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl MeanRadius for Aegaeon {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(0.33f64)
    }
}
impl TriaxialEllipsoid for Aegaeon {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(0.7f64),
            Distance::kilometers(0.25f64),
            Distance::kilometers(0.2f64),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Ariel;
impl Origin for Ariel {
    fn id(&self) -> NaifId {
        NaifId(701i32)
    }
    fn name(&self) -> &'static str {
        "Ariel"
    }
}
impl Display for Ariel {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for Ariel {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(83.46344431770477f64)
    }
}
impl MeanRadius for Ariel {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(578.9f64)
    }
}
impl TriaxialEllipsoid for Ariel {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(581.1f64),
            Distance::kilometers(577.9f64),
            Distance::kilometers(577.7f64),
        )
    }
}
const RIGHT_ASCENSION_ARIEL: RotationalElement<13usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 4.493001093409003f64,
    c1: 0f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0.005061454830783556f64,
    ],
    theta0: [
        2.0202186091834364f64,
        2.4729570171507653f64,
        2.356718088967943f64,
        1.0780898789568973f64,
        4.351454891072263f64,
        0.7655014099247129f64,
        1.3554226970987964f64,
        2.746450110938277f64,
        1.776919711455427f64,
        2.419724474964938f64,
        1.784250094313803f64,
        5.522396286235258f64,
        5.3059754589879615f64,
    ],
    theta1: [
        959.7891933286942f64,
        731.077582955928f64,
        522.3307938967249f64,
        449.1358738582876f64,
        427.10754977009157f64,
        388.83160660922994f64,
        354.1171823199879f64,
        290.6454915444109f64,
        224.66977689099764f64,
        140.70512817020406f64,
        -35.32930378471962f64,
        49.9855316454168f64,
        -0.9065240134858548f64,
    ],
};
const DECLINATION_ARIEL: RotationalElement<13usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: -0.26354471705114374f64,
    c1: 0f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0.004886921905584123f64,
    ],
    theta0: [
        2.0202186091834364f64,
        2.4729570171507653f64,
        2.356718088967943f64,
        1.0780898789568973f64,
        4.351454891072263f64,
        0.7655014099247129f64,
        1.3554226970987964f64,
        2.746450110938277f64,
        1.776919711455427f64,
        2.419724474964938f64,
        1.784250094313803f64,
        5.522396286235258f64,
        5.3059754589879615f64,
    ],
    theta1: [
        959.7891933286942f64,
        731.077582955928f64,
        522.3307938967249f64,
        449.1358738582876f64,
        427.10754977009157f64,
        388.83160660922994f64,
        354.1171823199879f64,
        290.6454915444109f64,
        224.66977689099764f64,
        140.70512817020406f64,
        -35.32930378471962f64,
        49.9855316454168f64,
        -0.9065240134858548f64,
    ],
};
const ROTATION_ARIEL: RotationalElement<13usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 2.7265533574655416f64,
    c1: -2.492952697630833f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0.0008726646259971648f64,
        0.0013962634015954637f64,
    ],
    theta0: [
        2.0202186091834364f64,
        2.4729570171507653f64,
        2.356718088967943f64,
        1.0780898789568973f64,
        4.351454891072263f64,
        0.7655014099247129f64,
        1.3554226970987964f64,
        2.746450110938277f64,
        1.776919711455427f64,
        2.419724474964938f64,
        1.784250094313803f64,
        5.522396286235258f64,
        5.3059754589879615f64,
    ],
    theta1: [
        959.7891933286942f64,
        731.077582955928f64,
        522.3307938967249f64,
        449.1358738582876f64,
        427.10754977009157f64,
        388.83160660922994f64,
        354.1171823199879f64,
        290.6454915444109f64,
        224.66977689099764f64,
        140.70512817020406f64,
        -35.32930378471962f64,
        49.9855316454168f64,
        -0.9065240134858548f64,
    ],
};
impl RotationalElements for Ariel {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_ARIEL.angle(t),
            DECLINATION_ARIEL.angle(t),
            ROTATION_ARIEL.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_ARIEL.angle_dot(t),
            DECLINATION_ARIEL.angle_dot(t),
            ROTATION_ARIEL.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Umbriel;
impl Origin for Umbriel {
    fn id(&self) -> NaifId {
        NaifId(702i32)
    }
    fn name(&self) -> &'static str {
        "Umbriel"
    }
}
impl Display for Umbriel {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for Umbriel {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(85.09338094489388f64)
    }
}
impl MeanRadius for Umbriel {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(584.7f64)
    }
}
impl TriaxialEllipsoid for Umbriel {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(584.7f64),
            Distance::kilometers(584.7f64),
            Distance::kilometers(584.7f64),
        )
    }
}
impl Spheroid for Umbriel {}
const RIGHT_ASCENSION_UMBRIEL: RotationalElement<14usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 4.493001093409003f64,
    c1: 0f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0.003665191429188092f64,
    ],
    theta0: [
        2.0202186091834364f64,
        2.4729570171507653f64,
        2.356718088967943f64,
        1.0780898789568973f64,
        4.351454891072263f64,
        0.7655014099247129f64,
        1.3554226970987964f64,
        2.746450110938277f64,
        1.776919711455427f64,
        2.419724474964938f64,
        1.784250094313803f64,
        5.522396286235258f64,
        5.3059754589879615f64,
        5.388005933831694f64,
    ],
    theta1: [
        959.7891933286942f64,
        731.077582955928f64,
        522.3307938967249f64,
        449.1358738582876f64,
        427.10754977009157f64,
        388.83160660922994f64,
        354.1171823199879f64,
        290.6454915444109f64,
        224.66977689099764f64,
        140.70512817020406f64,
        -35.32930378471962f64,
        49.9855316454168f64,
        -0.9065240134858548f64,
        -1.626123264083117f64,
    ],
};
const DECLINATION_UMBRIEL: RotationalElement<14usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: -0.26354471705114374f64,
    c1: 0f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0.003490658503988659f64,
    ],
    theta0: [
        2.0202186091834364f64,
        2.4729570171507653f64,
        2.356718088967943f64,
        1.0780898789568973f64,
        4.351454891072263f64,
        0.7655014099247129f64,
        1.3554226970987964f64,
        2.746450110938277f64,
        1.776919711455427f64,
        2.419724474964938f64,
        1.784250094313803f64,
        5.522396286235258f64,
        5.3059754589879615f64,
        5.388005933831694f64,
    ],
    theta1: [
        959.7891933286942f64,
        731.077582955928f64,
        522.3307938967249f64,
        449.1358738582876f64,
        427.10754977009157f64,
        388.83160660922994f64,
        354.1171823199879f64,
        290.6454915444109f64,
        224.66977689099764f64,
        140.70512817020406f64,
        -35.32930378471962f64,
        49.9855316454168f64,
        -0.9065240134858548f64,
        -1.626123264083117f64,
    ],
};
const ROTATION_UMBRIEL: RotationalElement<14usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 1.885828256779873f64,
    c1: -1.5161481881953498f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        -0.0015707963267948964f64,
        0f64,
        0.0010471975511965976f64,
    ],
    theta0: [
        2.0202186091834364f64,
        2.4729570171507653f64,
        2.356718088967943f64,
        1.0780898789568973f64,
        4.351454891072263f64,
        0.7655014099247129f64,
        1.3554226970987964f64,
        2.746450110938277f64,
        1.776919711455427f64,
        2.419724474964938f64,
        1.784250094313803f64,
        5.522396286235258f64,
        5.3059754589879615f64,
        5.388005933831694f64,
    ],
    theta1: [
        959.7891933286942f64,
        731.077582955928f64,
        522.3307938967249f64,
        449.1358738582876f64,
        427.10754977009157f64,
        388.83160660922994f64,
        354.1171823199879f64,
        290.6454915444109f64,
        224.66977689099764f64,
        140.70512817020406f64,
        -35.32930378471962f64,
        49.9855316454168f64,
        -0.9065240134858548f64,
        -1.626123264083117f64,
    ],
};
impl RotationalElements for Umbriel {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_UMBRIEL.angle(t),
            DECLINATION_UMBRIEL.angle(t),
            ROTATION_UMBRIEL.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_UMBRIEL.angle_dot(t),
            DECLINATION_UMBRIEL.angle_dot(t),
            ROTATION_UMBRIEL.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Titania;
impl Origin for Titania {
    fn id(&self) -> NaifId {
        NaifId(703i32)
    }
    fn name(&self) -> &'static str {
        "Titania"
    }
}
impl Display for Titania {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for Titania {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(226.9437003741248f64)
    }
}
impl MeanRadius for Titania {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(788.9f64)
    }
}
impl TriaxialEllipsoid for Titania {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(788.9f64),
            Distance::kilometers(788.9f64),
            Distance::kilometers(788.9f64),
        )
    }
}
impl Spheroid for Titania {}
const RIGHT_ASCENSION_TITANIA: RotationalElement<15usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 4.493001093409003f64,
    c1: 0f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0.005061454830783556f64,
    ],
    theta0: [
        2.0202186091834364f64,
        2.4729570171507653f64,
        2.356718088967943f64,
        1.0780898789568973f64,
        4.351454891072263f64,
        0.7655014099247129f64,
        1.3554226970987964f64,
        2.746450110938277f64,
        1.776919711455427f64,
        2.419724474964938f64,
        1.784250094313803f64,
        5.522396286235258f64,
        5.3059754589879615f64,
        5.388005933831694f64,
        5.948431156647074f64,
    ],
    theta1: [
        959.7891933286942f64,
        731.077582955928f64,
        522.3307938967249f64,
        449.1358738582876f64,
        427.10754977009157f64,
        388.83160660922994f64,
        354.1171823199879f64,
        290.6454915444109f64,
        224.66977689099764f64,
        140.70512817020406f64,
        -35.32930378471962f64,
        49.9855316454168f64,
        -0.9065240134858548f64,
        -1.626123264083117f64,
        -1.314581992602129f64,
    ],
};
const DECLINATION_TITANIA: RotationalElement<15usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: -0.26354471705114374f64,
    c1: 0f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0.004886921905584123f64,
    ],
    theta0: [
        2.0202186091834364f64,
        2.4729570171507653f64,
        2.356718088967943f64,
        1.0780898789568973f64,
        4.351454891072263f64,
        0.7655014099247129f64,
        1.3554226970987964f64,
        2.746450110938277f64,
        1.776919711455427f64,
        2.419724474964938f64,
        1.784250094313803f64,
        5.522396286235258f64,
        5.3059754589879615f64,
        5.388005933831694f64,
        5.948431156647074f64,
    ],
    theta1: [
        959.7891933286942f64,
        731.077582955928f64,
        522.3307938967249f64,
        449.1358738582876f64,
        427.10754977009157f64,
        388.83160660922994f64,
        354.1171823199879f64,
        290.6454915444109f64,
        224.66977689099764f64,
        140.70512817020406f64,
        -35.32930378471962f64,
        49.9855316454168f64,
        -0.9065240134858548f64,
        -1.626123264083117f64,
        -1.314581992602129f64,
    ],
};
const ROTATION_TITANIA: RotationalElement<15usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 1.3568189605003917f64,
    c1: -0.7217186318332268f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0.0013962634015954637f64,
    ],
    theta0: [
        2.0202186091834364f64,
        2.4729570171507653f64,
        2.356718088967943f64,
        1.0780898789568973f64,
        4.351454891072263f64,
        0.7655014099247129f64,
        1.3554226970987964f64,
        2.746450110938277f64,
        1.776919711455427f64,
        2.419724474964938f64,
        1.784250094313803f64,
        5.522396286235258f64,
        5.3059754589879615f64,
        5.388005933831694f64,
        5.948431156647074f64,
    ],
    theta1: [
        959.7891933286942f64,
        731.077582955928f64,
        522.3307938967249f64,
        449.1358738582876f64,
        427.10754977009157f64,
        388.83160660922994f64,
        354.1171823199879f64,
        290.6454915444109f64,
        224.66977689099764f64,
        140.70512817020406f64,
        -35.32930378471962f64,
        49.9855316454168f64,
        -0.9065240134858548f64,
        -1.626123264083117f64,
        -1.314581992602129f64,
    ],
};
impl RotationalElements for Titania {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_TITANIA.angle(t),
            DECLINATION_TITANIA.angle(t),
            ROTATION_TITANIA.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_TITANIA.angle_dot(t),
            DECLINATION_TITANIA.angle_dot(t),
            ROTATION_TITANIA.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Oberon;
impl Origin for Oberon {
    fn id(&self) -> NaifId {
        NaifId(704i32)
    }
    fn name(&self) -> &'static str {
        "Oberon"
    }
}
impl Display for Oberon {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for Oberon {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(205.3234302535623f64)
    }
}
impl MeanRadius for Oberon {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(761.4f64)
    }
}
impl TriaxialEllipsoid for Oberon {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(761.4f64),
            Distance::kilometers(761.4f64),
            Distance::kilometers(761.4f64),
        )
    }
}
impl Spheroid for Oberon {}
const RIGHT_ASCENSION_OBERON: RotationalElement<16usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 4.493001093409003f64,
    c1: 0f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0.0027925268031909274f64,
    ],
    theta0: [
        2.0202186091834364f64,
        2.4729570171507653f64,
        2.356718088967943f64,
        1.0780898789568973f64,
        4.351454891072263f64,
        0.7655014099247129f64,
        1.3554226970987964f64,
        2.746450110938277f64,
        1.776919711455427f64,
        2.419724474964938f64,
        1.784250094313803f64,
        5.522396286235258f64,
        5.3059754589879615f64,
        5.388005933831694f64,
        5.948431156647074f64,
        4.522846223618106f64,
    ],
    theta1: [
        959.7891933286942f64,
        731.077582955928f64,
        522.3307938967249f64,
        449.1358738582876f64,
        427.10754977009157f64,
        388.83160660922994f64,
        354.1171823199879f64,
        290.6454915444109f64,
        224.66977689099764f64,
        140.70512817020406f64,
        -35.32930378471962f64,
        49.9855316454168f64,
        -0.9065240134858548f64,
        -1.626123264083117f64,
        -1.314581992602129f64,
        -8.810596596992575f64,
    ],
};
const DECLINATION_OBERON: RotationalElement<16usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: -0.26354471705114374f64,
    c1: 0f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0.0027925268031909274f64,
    ],
    theta0: [
        2.0202186091834364f64,
        2.4729570171507653f64,
        2.356718088967943f64,
        1.0780898789568973f64,
        4.351454891072263f64,
        0.7655014099247129f64,
        1.3554226970987964f64,
        2.746450110938277f64,
        1.776919711455427f64,
        2.419724474964938f64,
        1.784250094313803f64,
        5.522396286235258f64,
        5.3059754589879615f64,
        5.388005933831694f64,
        5.948431156647074f64,
        4.522846223618106f64,
    ],
    theta1: [
        959.7891933286942f64,
        731.077582955928f64,
        522.3307938967249f64,
        449.1358738582876f64,
        427.10754977009157f64,
        388.83160660922994f64,
        354.1171823199879f64,
        290.6454915444109f64,
        224.66977689099764f64,
        140.70512817020406f64,
        -35.32930378471962f64,
        49.9855316454168f64,
        -0.9065240134858548f64,
        -1.626123264083117f64,
        -1.314581992602129f64,
        -8.810596596992575f64,
    ],
};
const ROTATION_OBERON: RotationalElement<16usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 0.1181587903600161f64,
    c1: -0.4666921966546346f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0.0006981317007977319f64,
    ],
    theta0: [
        2.0202186091834364f64,
        2.4729570171507653f64,
        2.356718088967943f64,
        1.0780898789568973f64,
        4.351454891072263f64,
        0.7655014099247129f64,
        1.3554226970987964f64,
        2.746450110938277f64,
        1.776919711455427f64,
        2.419724474964938f64,
        1.784250094313803f64,
        5.522396286235258f64,
        5.3059754589879615f64,
        5.388005933831694f64,
        5.948431156647074f64,
        4.522846223618106f64,
    ],
    theta1: [
        959.7891933286942f64,
        731.077582955928f64,
        522.3307938967249f64,
        449.1358738582876f64,
        427.10754977009157f64,
        388.83160660922994f64,
        354.1171823199879f64,
        290.6454915444109f64,
        224.66977689099764f64,
        140.70512817020406f64,
        -35.32930378471962f64,
        49.9855316454168f64,
        -0.9065240134858548f64,
        -1.626123264083117f64,
        -1.314581992602129f64,
        -8.810596596992575f64,
    ],
};
impl RotationalElements for Oberon {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_OBERON.angle(t),
            DECLINATION_OBERON.angle(t),
            ROTATION_OBERON.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_OBERON.angle_dot(t),
            DECLINATION_OBERON.angle_dot(t),
            ROTATION_OBERON.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Miranda;
impl Origin for Miranda {
    fn id(&self) -> NaifId {
        NaifId(705i32)
    }
    fn name(&self) -> &'static str {
        "Miranda"
    }
}
impl Display for Miranda {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for Miranda {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(4.3195168992321f64)
    }
}
impl MeanRadius for Miranda {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(235.8f64)
    }
}
impl TriaxialEllipsoid for Miranda {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(240.4f64),
            Distance::kilometers(234.2f64),
            Distance::kilometers(232.9f64),
        )
    }
}
const RIGHT_ASCENSION_MIRANDA: RotationalElement<18usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 4.493001093409003f64,
    c1: 0f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0.07696902001294993f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        -0.0006981317007977319f64,
        0f64,
    ],
    theta0: [
        2.0202186091834364f64,
        2.4729570171507653f64,
        2.356718088967943f64,
        1.0780898789568973f64,
        4.351454891072263f64,
        0.7655014099247129f64,
        1.3554226970987964f64,
        2.746450110938277f64,
        1.776919711455427f64,
        2.419724474964938f64,
        1.784250094313803f64,
        5.522396286235258f64,
        5.3059754589879615f64,
        5.388005933831694f64,
        5.948431156647074f64,
        4.522846223618106f64,
        3.568500188627606f64,
        11.044792572470516f64,
    ],
    theta1: [
        959.7891933286942f64,
        731.077582955928f64,
        522.3307938967249f64,
        449.1358738582876f64,
        427.10754977009157f64,
        388.83160660922994f64,
        354.1171823199879f64,
        290.6454915444109f64,
        224.66977689099764f64,
        140.70512817020406f64,
        -35.32930378471962f64,
        49.9855316454168f64,
        -0.9065240134858548f64,
        -1.626123264083117f64,
        -1.314581992602129f64,
        -8.810596596992575f64,
        -70.65860756943924f64,
        99.9710632908336f64,
    ],
};
const DECLINATION_MIRANDA: RotationalElement<18usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: -0.2631956512007449f64,
    c1: 0f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0.07417649320975901f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        -0.00034906585039886593f64,
        0f64,
    ],
    theta0: [
        2.0202186091834364f64,
        2.4729570171507653f64,
        2.356718088967943f64,
        1.0780898789568973f64,
        4.351454891072263f64,
        0.7655014099247129f64,
        1.3554226970987964f64,
        2.746450110938277f64,
        1.776919711455427f64,
        2.419724474964938f64,
        1.784250094313803f64,
        5.522396286235258f64,
        5.3059754589879615f64,
        5.388005933831694f64,
        5.948431156647074f64,
        4.522846223618106f64,
        3.568500188627606f64,
        11.044792572470516f64,
    ],
    theta1: [
        959.7891933286942f64,
        731.077582955928f64,
        522.3307938967249f64,
        449.1358738582876f64,
        427.10754977009157f64,
        388.83160660922994f64,
        354.1171823199879f64,
        290.6454915444109f64,
        224.66977689099764f64,
        140.70512817020406f64,
        -35.32930378471962f64,
        49.9855316454168f64,
        -0.9065240134858548f64,
        -1.626123264083117f64,
        -1.314581992602129f64,
        -8.810596596992575f64,
        -70.65860756943924f64,
        99.9710632908336f64,
    ],
};
const ROTATION_MIRANDA: RotationalElement<18usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 0.5358160803622591f64,
    c1: -4.445191100713563f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0.02007128639793479f64,
        -0.022165681500327987f64,
        0f64,
        0f64,
        0f64,
        0f64,
        -0.0015707963267948964f64,
        0.002617993877991494f64,
    ],
    theta0: [
        2.0202186091834364f64,
        2.4729570171507653f64,
        2.356718088967943f64,
        1.0780898789568973f64,
        4.351454891072263f64,
        0.7655014099247129f64,
        1.3554226970987964f64,
        2.746450110938277f64,
        1.776919711455427f64,
        2.419724474964938f64,
        1.784250094313803f64,
        5.522396286235258f64,
        5.3059754589879615f64,
        5.388005933831694f64,
        5.948431156647074f64,
        4.522846223618106f64,
        3.568500188627606f64,
        11.044792572470516f64,
    ],
    theta1: [
        959.7891933286942f64,
        731.077582955928f64,
        522.3307938967249f64,
        449.1358738582876f64,
        427.10754977009157f64,
        388.83160660922994f64,
        354.1171823199879f64,
        290.6454915444109f64,
        224.66977689099764f64,
        140.70512817020406f64,
        -35.32930378471962f64,
        49.9855316454168f64,
        -0.9065240134858548f64,
        -1.626123264083117f64,
        -1.314581992602129f64,
        -8.810596596992575f64,
        -70.65860756943924f64,
        99.9710632908336f64,
    ],
};
impl RotationalElements for Miranda {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_MIRANDA.angle(t),
            DECLINATION_MIRANDA.angle(t),
            ROTATION_MIRANDA.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_MIRANDA.angle_dot(t),
            DECLINATION_MIRANDA.angle_dot(t),
            ROTATION_MIRANDA.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Cordelia;
impl Origin for Cordelia {
    fn id(&self) -> NaifId {
        NaifId(706i32)
    }
    fn name(&self) -> &'static str {
        "Cordelia"
    }
}
impl Display for Cordelia {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl MeanRadius for Cordelia {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(13f64)
    }
}
impl TriaxialEllipsoid for Cordelia {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(13f64),
            Distance::kilometers(13f64),
            Distance::kilometers(13f64),
        )
    }
}
impl Spheroid for Cordelia {}
const RIGHT_ASCENSION_CORDELIA: RotationalElement<18usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 4.49090669830661f64,
    c1: 0f64,
    c2: 0f64,
    c: [
        -0.002617993877991494f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
    ],
    theta0: [
        2.0202186091834364f64,
        2.4729570171507653f64,
        2.356718088967943f64,
        1.0780898789568973f64,
        4.351454891072263f64,
        0.7655014099247129f64,
        1.3554226970987964f64,
        2.746450110938277f64,
        1.776919711455427f64,
        2.419724474964938f64,
        1.784250094313803f64,
        5.522396286235258f64,
        5.3059754589879615f64,
        5.388005933831694f64,
        5.948431156647074f64,
        4.522846223618106f64,
        3.568500188627606f64,
        11.044792572470516f64,
    ],
    theta1: [
        959.7891933286942f64,
        731.077582955928f64,
        522.3307938967249f64,
        449.1358738582876f64,
        427.10754977009157f64,
        388.83160660922994f64,
        354.1171823199879f64,
        290.6454915444109f64,
        224.66977689099764f64,
        140.70512817020406f64,
        -35.32930378471962f64,
        49.9855316454168f64,
        -0.9065240134858548f64,
        -1.626123264083117f64,
        -1.314581992602129f64,
        -8.810596596992575f64,
        -70.65860756943924f64,
        99.9710632908336f64,
    ],
};
const DECLINATION_CORDELIA: RotationalElement<18usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: -0.2649409804527392f64,
    c1: 0f64,
    c2: 0f64,
    c: [
        0.0024434609527920616f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
    ],
    theta0: [
        2.0202186091834364f64,
        2.4729570171507653f64,
        2.356718088967943f64,
        1.0780898789568973f64,
        4.351454891072263f64,
        0.7655014099247129f64,
        1.3554226970987964f64,
        2.746450110938277f64,
        1.776919711455427f64,
        2.419724474964938f64,
        1.784250094313803f64,
        5.522396286235258f64,
        5.3059754589879615f64,
        5.388005933831694f64,
        5.948431156647074f64,
        4.522846223618106f64,
        3.568500188627606f64,
        11.044792572470516f64,
    ],
    theta1: [
        959.7891933286942f64,
        731.077582955928f64,
        522.3307938967249f64,
        449.1358738582876f64,
        427.10754977009157f64,
        388.83160660922994f64,
        354.1171823199879f64,
        290.6454915444109f64,
        224.66977689099764f64,
        140.70512817020406f64,
        -35.32930378471962f64,
        49.9855316454168f64,
        -0.9065240134858548f64,
        -1.626123264083117f64,
        -1.314581992602129f64,
        -8.810596596992575f64,
        -70.65860756943924f64,
        99.9710632908336f64,
    ],
};
const ROTATION_CORDELIA: RotationalElement<18usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 2.2286109218715593f64,
    c1: -18.753921879266084f64,
    c2: 0f64,
    c: [
        -0.0006981317007977319f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
    ],
    theta0: [
        2.0202186091834364f64,
        2.4729570171507653f64,
        2.356718088967943f64,
        1.0780898789568973f64,
        4.351454891072263f64,
        0.7655014099247129f64,
        1.3554226970987964f64,
        2.746450110938277f64,
        1.776919711455427f64,
        2.419724474964938f64,
        1.784250094313803f64,
        5.522396286235258f64,
        5.3059754589879615f64,
        5.388005933831694f64,
        5.948431156647074f64,
        4.522846223618106f64,
        3.568500188627606f64,
        11.044792572470516f64,
    ],
    theta1: [
        959.7891933286942f64,
        731.077582955928f64,
        522.3307938967249f64,
        449.1358738582876f64,
        427.10754977009157f64,
        388.83160660922994f64,
        354.1171823199879f64,
        290.6454915444109f64,
        224.66977689099764f64,
        140.70512817020406f64,
        -35.32930378471962f64,
        49.9855316454168f64,
        -0.9065240134858548f64,
        -1.626123264083117f64,
        -1.314581992602129f64,
        -8.810596596992575f64,
        -70.65860756943924f64,
        99.9710632908336f64,
    ],
};
impl RotationalElements for Cordelia {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_CORDELIA.angle(t),
            DECLINATION_CORDELIA.angle(t),
            ROTATION_CORDELIA.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_CORDELIA.angle_dot(t),
            DECLINATION_CORDELIA.angle_dot(t),
            ROTATION_CORDELIA.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Ophelia;
impl Origin for Ophelia {
    fn id(&self) -> NaifId {
        NaifId(707i32)
    }
    fn name(&self) -> &'static str {
        "Ophelia"
    }
}
impl Display for Ophelia {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl MeanRadius for Ophelia {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(15f64)
    }
}
impl TriaxialEllipsoid for Ophelia {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(15f64),
            Distance::kilometers(15f64),
            Distance::kilometers(15f64),
        )
    }
}
impl Spheroid for Ophelia {}
const RIGHT_ASCENSION_OPHELIA: RotationalElement<18usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 4.49090669830661f64,
    c1: 0f64,
    c2: 0f64,
    c: [
        0f64,
        -0.0015707963267948964f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
    ],
    theta0: [
        2.0202186091834364f64,
        2.4729570171507653f64,
        2.356718088967943f64,
        1.0780898789568973f64,
        4.351454891072263f64,
        0.7655014099247129f64,
        1.3554226970987964f64,
        2.746450110938277f64,
        1.776919711455427f64,
        2.419724474964938f64,
        1.784250094313803f64,
        5.522396286235258f64,
        5.3059754589879615f64,
        5.388005933831694f64,
        5.948431156647074f64,
        4.522846223618106f64,
        3.568500188627606f64,
        11.044792572470516f64,
    ],
    theta1: [
        959.7891933286942f64,
        731.077582955928f64,
        522.3307938967249f64,
        449.1358738582876f64,
        427.10754977009157f64,
        388.83160660922994f64,
        354.1171823199879f64,
        290.6454915444109f64,
        224.66977689099764f64,
        140.70512817020406f64,
        -35.32930378471962f64,
        49.9855316454168f64,
        -0.9065240134858548f64,
        -1.626123264083117f64,
        -1.314581992602129f64,
        -8.810596596992575f64,
        -70.65860756943924f64,
        99.9710632908336f64,
    ],
};
const DECLINATION_OPHELIA: RotationalElement<18usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: -0.2649409804527392f64,
    c1: 0f64,
    c2: 0f64,
    c: [
        0f64,
        0.0015707963267948964f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
    ],
    theta0: [
        2.0202186091834364f64,
        2.4729570171507653f64,
        2.356718088967943f64,
        1.0780898789568973f64,
        4.351454891072263f64,
        0.7655014099247129f64,
        1.3554226970987964f64,
        2.746450110938277f64,
        1.776919711455427f64,
        2.419724474964938f64,
        1.784250094313803f64,
        5.522396286235258f64,
        5.3059754589879615f64,
        5.388005933831694f64,
        5.948431156647074f64,
        4.522846223618106f64,
        3.568500188627606f64,
        11.044792572470516f64,
    ],
    theta1: [
        959.7891933286942f64,
        731.077582955928f64,
        522.3307938967249f64,
        449.1358738582876f64,
        427.10754977009157f64,
        388.83160660922994f64,
        354.1171823199879f64,
        290.6454915444109f64,
        224.66977689099764f64,
        140.70512817020406f64,
        -35.32930378471962f64,
        49.9855316454168f64,
        -0.9065240134858548f64,
        -1.626123264083117f64,
        -1.314581992602129f64,
        -8.810596596992575f64,
        -70.65860756943924f64,
        99.9710632908336f64,
    ],
};
const ROTATION_OPHELIA: RotationalElement<18usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 2.2750366799746087f64,
    c1: -16.692447910262292f64,
    c2: 0f64,
    c: [
        0f64,
        -0.0005235987755982988f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
    ],
    theta0: [
        2.0202186091834364f64,
        2.4729570171507653f64,
        2.356718088967943f64,
        1.0780898789568973f64,
        4.351454891072263f64,
        0.7655014099247129f64,
        1.3554226970987964f64,
        2.746450110938277f64,
        1.776919711455427f64,
        2.419724474964938f64,
        1.784250094313803f64,
        5.522396286235258f64,
        5.3059754589879615f64,
        5.388005933831694f64,
        5.948431156647074f64,
        4.522846223618106f64,
        3.568500188627606f64,
        11.044792572470516f64,
    ],
    theta1: [
        959.7891933286942f64,
        731.077582955928f64,
        522.3307938967249f64,
        449.1358738582876f64,
        427.10754977009157f64,
        388.83160660922994f64,
        354.1171823199879f64,
        290.6454915444109f64,
        224.66977689099764f64,
        140.70512817020406f64,
        -35.32930378471962f64,
        49.9855316454168f64,
        -0.9065240134858548f64,
        -1.626123264083117f64,
        -1.314581992602129f64,
        -8.810596596992575f64,
        -70.65860756943924f64,
        99.9710632908336f64,
    ],
};
impl RotationalElements for Ophelia {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_OPHELIA.angle(t),
            DECLINATION_OPHELIA.angle(t),
            ROTATION_OPHELIA.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_OPHELIA.angle_dot(t),
            DECLINATION_OPHELIA.angle_dot(t),
            ROTATION_OPHELIA.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Bianca;
impl Origin for Bianca {
    fn id(&self) -> NaifId {
        NaifId(708i32)
    }
    fn name(&self) -> &'static str {
        "Bianca"
    }
}
impl Display for Bianca {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl MeanRadius for Bianca {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(21f64)
    }
}
impl TriaxialEllipsoid for Bianca {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(21f64),
            Distance::kilometers(21f64),
            Distance::kilometers(21f64),
        )
    }
}
impl Spheroid for Bianca {}
const RIGHT_ASCENSION_BIANCA: RotationalElement<18usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 4.49090669830661f64,
    c1: 0f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        -0.0027925268031909274f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
    ],
    theta0: [
        2.0202186091834364f64,
        2.4729570171507653f64,
        2.356718088967943f64,
        1.0780898789568973f64,
        4.351454891072263f64,
        0.7655014099247129f64,
        1.3554226970987964f64,
        2.746450110938277f64,
        1.776919711455427f64,
        2.419724474964938f64,
        1.784250094313803f64,
        5.522396286235258f64,
        5.3059754589879615f64,
        5.388005933831694f64,
        5.948431156647074f64,
        4.522846223618106f64,
        3.568500188627606f64,
        11.044792572470516f64,
    ],
    theta1: [
        959.7891933286942f64,
        731.077582955928f64,
        522.3307938967249f64,
        449.1358738582876f64,
        427.10754977009157f64,
        388.83160660922994f64,
        354.1171823199879f64,
        290.6454915444109f64,
        224.66977689099764f64,
        140.70512817020406f64,
        -35.32930378471962f64,
        49.9855316454168f64,
        -0.9065240134858548f64,
        -1.626123264083117f64,
        -1.314581992602129f64,
        -8.810596596992575f64,
        -70.65860756943924f64,
        99.9710632908336f64,
    ],
};
const DECLINATION_BIANCA: RotationalElement<18usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: -0.2649409804527392f64,
    c1: 0f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0.0027925268031909274f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
    ],
    theta0: [
        2.0202186091834364f64,
        2.4729570171507653f64,
        2.356718088967943f64,
        1.0780898789568973f64,
        4.351454891072263f64,
        0.7655014099247129f64,
        1.3554226970987964f64,
        2.746450110938277f64,
        1.776919711455427f64,
        2.419724474964938f64,
        1.784250094313803f64,
        5.522396286235258f64,
        5.3059754589879615f64,
        5.388005933831694f64,
        5.948431156647074f64,
        4.522846223618106f64,
        3.568500188627606f64,
        11.044792572470516f64,
    ],
    theta1: [
        959.7891933286942f64,
        731.077582955928f64,
        522.3307938967249f64,
        449.1358738582876f64,
        427.10754977009157f64,
        388.83160660922994f64,
        354.1171823199879f64,
        290.6454915444109f64,
        224.66977689099764f64,
        140.70512817020406f64,
        -35.32930378471962f64,
        49.9855316454168f64,
        -0.9065240134858548f64,
        -1.626123264083117f64,
        -1.314581992602129f64,
        -8.810596596992575f64,
        -70.65860756943924f64,
        99.9710632908336f64,
    ],
};
const ROTATION_BIANCA: RotationalElement<18usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 1.8406242291532198f64,
    c1: -14.458158751655587f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        -0.0006981317007977319f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
    ],
    theta0: [
        2.0202186091834364f64,
        2.4729570171507653f64,
        2.356718088967943f64,
        1.0780898789568973f64,
        4.351454891072263f64,
        0.7655014099247129f64,
        1.3554226970987964f64,
        2.746450110938277f64,
        1.776919711455427f64,
        2.419724474964938f64,
        1.784250094313803f64,
        5.522396286235258f64,
        5.3059754589879615f64,
        5.388005933831694f64,
        5.948431156647074f64,
        4.522846223618106f64,
        3.568500188627606f64,
        11.044792572470516f64,
    ],
    theta1: [
        959.7891933286942f64,
        731.077582955928f64,
        522.3307938967249f64,
        449.1358738582876f64,
        427.10754977009157f64,
        388.83160660922994f64,
        354.1171823199879f64,
        290.6454915444109f64,
        224.66977689099764f64,
        140.70512817020406f64,
        -35.32930378471962f64,
        49.9855316454168f64,
        -0.9065240134858548f64,
        -1.626123264083117f64,
        -1.314581992602129f64,
        -8.810596596992575f64,
        -70.65860756943924f64,
        99.9710632908336f64,
    ],
};
impl RotationalElements for Bianca {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_BIANCA.angle(t),
            DECLINATION_BIANCA.angle(t),
            ROTATION_BIANCA.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_BIANCA.angle_dot(t),
            DECLINATION_BIANCA.angle_dot(t),
            ROTATION_BIANCA.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Cressida;
impl Origin for Cressida {
    fn id(&self) -> NaifId {
        NaifId(709i32)
    }
    fn name(&self) -> &'static str {
        "Cressida"
    }
}
impl Display for Cressida {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl MeanRadius for Cressida {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(31f64)
    }
}
impl TriaxialEllipsoid for Cressida {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(31f64),
            Distance::kilometers(31f64),
            Distance::kilometers(31f64),
        )
    }
}
impl Spheroid for Cressida {}
const RIGHT_ASCENSION_CRESSIDA: RotationalElement<18usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 4.49090669830661f64,
    c1: 0f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0f64,
        -0.0006981317007977319f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
    ],
    theta0: [
        2.0202186091834364f64,
        2.4729570171507653f64,
        2.356718088967943f64,
        1.0780898789568973f64,
        4.351454891072263f64,
        0.7655014099247129f64,
        1.3554226970987964f64,
        2.746450110938277f64,
        1.776919711455427f64,
        2.419724474964938f64,
        1.784250094313803f64,
        5.522396286235258f64,
        5.3059754589879615f64,
        5.388005933831694f64,
        5.948431156647074f64,
        4.522846223618106f64,
        3.568500188627606f64,
        11.044792572470516f64,
    ],
    theta1: [
        959.7891933286942f64,
        731.077582955928f64,
        522.3307938967249f64,
        449.1358738582876f64,
        427.10754977009157f64,
        388.83160660922994f64,
        354.1171823199879f64,
        290.6454915444109f64,
        224.66977689099764f64,
        140.70512817020406f64,
        -35.32930378471962f64,
        49.9855316454168f64,
        -0.9065240134858548f64,
        -1.626123264083117f64,
        -1.314581992602129f64,
        -8.810596596992575f64,
        -70.65860756943924f64,
        99.9710632908336f64,
    ],
};
const DECLINATION_CRESSIDA: RotationalElement<18usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: -0.2649409804527392f64,
    c1: 0f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0f64,
        0.0006981317007977319f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
    ],
    theta0: [
        2.0202186091834364f64,
        2.4729570171507653f64,
        2.356718088967943f64,
        1.0780898789568973f64,
        4.351454891072263f64,
        0.7655014099247129f64,
        1.3554226970987964f64,
        2.746450110938277f64,
        1.776919711455427f64,
        2.419724474964938f64,
        1.784250094313803f64,
        5.522396286235258f64,
        5.3059754589879615f64,
        5.388005933831694f64,
        5.948431156647074f64,
        4.522846223618106f64,
        3.568500188627606f64,
        11.044792572470516f64,
    ],
    theta1: [
        959.7891933286942f64,
        731.077582955928f64,
        522.3307938967249f64,
        449.1358738582876f64,
        427.10754977009157f64,
        388.83160660922994f64,
        354.1171823199879f64,
        290.6454915444109f64,
        224.66977689099764f64,
        140.70512817020406f64,
        -35.32930378471962f64,
        49.9855316454168f64,
        -0.9065240134858548f64,
        -1.626123264083117f64,
        -1.314581992602129f64,
        -8.810596596992575f64,
        -70.65860756943924f64,
        99.9710632908336f64,
    ],
};
const ROTATION_CRESSIDA: RotationalElement<18usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 1.0325367854798453f64,
    c1: -13.553906388910956f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0f64,
        -0.00017453292519943296f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
    ],
    theta0: [
        2.0202186091834364f64,
        2.4729570171507653f64,
        2.356718088967943f64,
        1.0780898789568973f64,
        4.351454891072263f64,
        0.7655014099247129f64,
        1.3554226970987964f64,
        2.746450110938277f64,
        1.776919711455427f64,
        2.419724474964938f64,
        1.784250094313803f64,
        5.522396286235258f64,
        5.3059754589879615f64,
        5.388005933831694f64,
        5.948431156647074f64,
        4.522846223618106f64,
        3.568500188627606f64,
        11.044792572470516f64,
    ],
    theta1: [
        959.7891933286942f64,
        731.077582955928f64,
        522.3307938967249f64,
        449.1358738582876f64,
        427.10754977009157f64,
        388.83160660922994f64,
        354.1171823199879f64,
        290.6454915444109f64,
        224.66977689099764f64,
        140.70512817020406f64,
        -35.32930378471962f64,
        49.9855316454168f64,
        -0.9065240134858548f64,
        -1.626123264083117f64,
        -1.314581992602129f64,
        -8.810596596992575f64,
        -70.65860756943924f64,
        99.9710632908336f64,
    ],
};
impl RotationalElements for Cressida {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_CRESSIDA.angle(t),
            DECLINATION_CRESSIDA.angle(t),
            ROTATION_CRESSIDA.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_CRESSIDA.angle_dot(t),
            DECLINATION_CRESSIDA.angle_dot(t),
            ROTATION_CRESSIDA.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Desdemona;
impl Origin for Desdemona {
    fn id(&self) -> NaifId {
        NaifId(710i32)
    }
    fn name(&self) -> &'static str {
        "Desdemona"
    }
}
impl Display for Desdemona {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl MeanRadius for Desdemona {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(27f64)
    }
}
impl TriaxialEllipsoid for Desdemona {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(27f64),
            Distance::kilometers(27f64),
            Distance::kilometers(27f64),
        )
    }
}
impl Spheroid for Desdemona {}
const RIGHT_ASCENSION_DESDEMONA: RotationalElement<18usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 4.49090669830661f64,
    c1: 0f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0f64,
        0f64,
        -0.0029670597283903604f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
    ],
    theta0: [
        2.0202186091834364f64,
        2.4729570171507653f64,
        2.356718088967943f64,
        1.0780898789568973f64,
        4.351454891072263f64,
        0.7655014099247129f64,
        1.3554226970987964f64,
        2.746450110938277f64,
        1.776919711455427f64,
        2.419724474964938f64,
        1.784250094313803f64,
        5.522396286235258f64,
        5.3059754589879615f64,
        5.388005933831694f64,
        5.948431156647074f64,
        4.522846223618106f64,
        3.568500188627606f64,
        11.044792572470516f64,
    ],
    theta1: [
        959.7891933286942f64,
        731.077582955928f64,
        522.3307938967249f64,
        449.1358738582876f64,
        427.10754977009157f64,
        388.83160660922994f64,
        354.1171823199879f64,
        290.6454915444109f64,
        224.66977689099764f64,
        140.70512817020406f64,
        -35.32930378471962f64,
        49.9855316454168f64,
        -0.9065240134858548f64,
        -1.626123264083117f64,
        -1.314581992602129f64,
        -8.810596596992575f64,
        -70.65860756943924f64,
        99.9710632908336f64,
    ],
};
const DECLINATION_DESDEMONA: RotationalElement<18usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: -0.2649409804527392f64,
    c1: 0f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0f64,
        0f64,
        0.0027925268031909274f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
    ],
    theta0: [
        2.0202186091834364f64,
        2.4729570171507653f64,
        2.356718088967943f64,
        1.0780898789568973f64,
        4.351454891072263f64,
        0.7655014099247129f64,
        1.3554226970987964f64,
        2.746450110938277f64,
        1.776919711455427f64,
        2.419724474964938f64,
        1.784250094313803f64,
        5.522396286235258f64,
        5.3059754589879615f64,
        5.388005933831694f64,
        5.948431156647074f64,
        4.522846223618106f64,
        3.568500188627606f64,
        11.044792572470516f64,
    ],
    theta1: [
        959.7891933286942f64,
        731.077582955928f64,
        522.3307938967249f64,
        449.1358738582876f64,
        427.10754977009157f64,
        388.83160660922994f64,
        354.1171823199879f64,
        290.6454915444109f64,
        224.66977689099764f64,
        140.70512817020406f64,
        -35.32930378471962f64,
        49.9855316454168f64,
        -0.9065240134858548f64,
        -1.626123264083117f64,
        -1.314581992602129f64,
        -8.810596596992575f64,
        -70.65860756943924f64,
        99.9710632908336f64,
    ],
};
const ROTATION_DESDEMONA: RotationalElement<18usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 1.6594590527962085f64,
    c1: -13.265430289266899f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0f64,
        0f64,
        -0.0006981317007977319f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
    ],
    theta0: [
        2.0202186091834364f64,
        2.4729570171507653f64,
        2.356718088967943f64,
        1.0780898789568973f64,
        4.351454891072263f64,
        0.7655014099247129f64,
        1.3554226970987964f64,
        2.746450110938277f64,
        1.776919711455427f64,
        2.419724474964938f64,
        1.784250094313803f64,
        5.522396286235258f64,
        5.3059754589879615f64,
        5.388005933831694f64,
        5.948431156647074f64,
        4.522846223618106f64,
        3.568500188627606f64,
        11.044792572470516f64,
    ],
    theta1: [
        959.7891933286942f64,
        731.077582955928f64,
        522.3307938967249f64,
        449.1358738582876f64,
        427.10754977009157f64,
        388.83160660922994f64,
        354.1171823199879f64,
        290.6454915444109f64,
        224.66977689099764f64,
        140.70512817020406f64,
        -35.32930378471962f64,
        49.9855316454168f64,
        -0.9065240134858548f64,
        -1.626123264083117f64,
        -1.314581992602129f64,
        -8.810596596992575f64,
        -70.65860756943924f64,
        99.9710632908336f64,
    ],
};
impl RotationalElements for Desdemona {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_DESDEMONA.angle(t),
            DECLINATION_DESDEMONA.angle(t),
            ROTATION_DESDEMONA.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_DESDEMONA.angle_dot(t),
            DECLINATION_DESDEMONA.angle_dot(t),
            ROTATION_DESDEMONA.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Juliet;
impl Origin for Juliet {
    fn id(&self) -> NaifId {
        NaifId(711i32)
    }
    fn name(&self) -> &'static str {
        "Juliet"
    }
}
impl Display for Juliet {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl MeanRadius for Juliet {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(42f64)
    }
}
impl TriaxialEllipsoid for Juliet {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(42f64),
            Distance::kilometers(42f64),
            Distance::kilometers(42f64),
        )
    }
}
impl Spheroid for Juliet {}
const RIGHT_ASCENSION_JULIET: RotationalElement<18usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 4.49090669830661f64,
    c1: 0f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        -0.0010471975511965976f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
    ],
    theta0: [
        2.0202186091834364f64,
        2.4729570171507653f64,
        2.356718088967943f64,
        1.0780898789568973f64,
        4.351454891072263f64,
        0.7655014099247129f64,
        1.3554226970987964f64,
        2.746450110938277f64,
        1.776919711455427f64,
        2.419724474964938f64,
        1.784250094313803f64,
        5.522396286235258f64,
        5.3059754589879615f64,
        5.388005933831694f64,
        5.948431156647074f64,
        4.522846223618106f64,
        3.568500188627606f64,
        11.044792572470516f64,
    ],
    theta1: [
        959.7891933286942f64,
        731.077582955928f64,
        522.3307938967249f64,
        449.1358738582876f64,
        427.10754977009157f64,
        388.83160660922994f64,
        354.1171823199879f64,
        290.6454915444109f64,
        224.66977689099764f64,
        140.70512817020406f64,
        -35.32930378471962f64,
        49.9855316454168f64,
        -0.9065240134858548f64,
        -1.626123264083117f64,
        -1.314581992602129f64,
        -8.810596596992575f64,
        -70.65860756943924f64,
        99.9710632908336f64,
    ],
};
const DECLINATION_JULIET: RotationalElement<18usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: -0.2649409804527392f64,
    c1: 0f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0.0010471975511965976f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
    ],
    theta0: [
        2.0202186091834364f64,
        2.4729570171507653f64,
        2.356718088967943f64,
        1.0780898789568973f64,
        4.351454891072263f64,
        0.7655014099247129f64,
        1.3554226970987964f64,
        2.746450110938277f64,
        1.776919711455427f64,
        2.419724474964938f64,
        1.784250094313803f64,
        5.522396286235258f64,
        5.3059754589879615f64,
        5.388005933831694f64,
        5.948431156647074f64,
        4.522846223618106f64,
        3.568500188627606f64,
        11.044792572470516f64,
    ],
    theta1: [
        959.7891933286942f64,
        731.077582955928f64,
        522.3307938967249f64,
        449.1358738582876f64,
        427.10754977009157f64,
        388.83160660922994f64,
        354.1171823199879f64,
        290.6454915444109f64,
        224.66977689099764f64,
        140.70512817020406f64,
        -35.32930378471962f64,
        49.9855316454168f64,
        -0.9065240134858548f64,
        -1.626123264083117f64,
        -1.314581992602129f64,
        -8.810596596992575f64,
        -70.65860756943924f64,
        99.9710632908336f64,
    ],
};
const ROTATION_JULIET: RotationalElement<18usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 5.2806681848340435f64,
    c1: -12.74309158902866f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        -0.00034906585039886593f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
    ],
    theta0: [
        2.0202186091834364f64,
        2.4729570171507653f64,
        2.356718088967943f64,
        1.0780898789568973f64,
        4.351454891072263f64,
        0.7655014099247129f64,
        1.3554226970987964f64,
        2.746450110938277f64,
        1.776919711455427f64,
        2.419724474964938f64,
        1.784250094313803f64,
        5.522396286235258f64,
        5.3059754589879615f64,
        5.388005933831694f64,
        5.948431156647074f64,
        4.522846223618106f64,
        3.568500188627606f64,
        11.044792572470516f64,
    ],
    theta1: [
        959.7891933286942f64,
        731.077582955928f64,
        522.3307938967249f64,
        449.1358738582876f64,
        427.10754977009157f64,
        388.83160660922994f64,
        354.1171823199879f64,
        290.6454915444109f64,
        224.66977689099764f64,
        140.70512817020406f64,
        -35.32930378471962f64,
        49.9855316454168f64,
        -0.9065240134858548f64,
        -1.626123264083117f64,
        -1.314581992602129f64,
        -8.810596596992575f64,
        -70.65860756943924f64,
        99.9710632908336f64,
    ],
};
impl RotationalElements for Juliet {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_JULIET.angle(t),
            DECLINATION_JULIET.angle(t),
            ROTATION_JULIET.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_JULIET.angle_dot(t),
            DECLINATION_JULIET.angle_dot(t),
            ROTATION_JULIET.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Portia;
impl Origin for Portia {
    fn id(&self) -> NaifId {
        NaifId(712i32)
    }
    fn name(&self) -> &'static str {
        "Portia"
    }
}
impl Display for Portia {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl MeanRadius for Portia {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(54f64)
    }
}
impl TriaxialEllipsoid for Portia {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(54f64),
            Distance::kilometers(54f64),
            Distance::kilometers(54f64),
        )
    }
}
impl Spheroid for Portia {}
const RIGHT_ASCENSION_PORTIA: RotationalElement<18usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 4.49090669830661f64,
    c1: 0f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        -0.0015707963267948964f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
    ],
    theta0: [
        2.0202186091834364f64,
        2.4729570171507653f64,
        2.356718088967943f64,
        1.0780898789568973f64,
        4.351454891072263f64,
        0.7655014099247129f64,
        1.3554226970987964f64,
        2.746450110938277f64,
        1.776919711455427f64,
        2.419724474964938f64,
        1.784250094313803f64,
        5.522396286235258f64,
        5.3059754589879615f64,
        5.388005933831694f64,
        5.948431156647074f64,
        4.522846223618106f64,
        3.568500188627606f64,
        11.044792572470516f64,
    ],
    theta1: [
        959.7891933286942f64,
        731.077582955928f64,
        522.3307938967249f64,
        449.1358738582876f64,
        427.10754977009157f64,
        388.83160660922994f64,
        354.1171823199879f64,
        290.6454915444109f64,
        224.66977689099764f64,
        140.70512817020406f64,
        -35.32930378471962f64,
        49.9855316454168f64,
        -0.9065240134858548f64,
        -1.626123264083117f64,
        -1.314581992602129f64,
        -8.810596596992575f64,
        -70.65860756943924f64,
        99.9710632908336f64,
    ],
};
const DECLINATION_PORTIA: RotationalElement<18usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: -0.2649409804527392f64,
    c1: 0f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0.0015707963267948964f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
    ],
    theta0: [
        2.0202186091834364f64,
        2.4729570171507653f64,
        2.356718088967943f64,
        1.0780898789568973f64,
        4.351454891072263f64,
        0.7655014099247129f64,
        1.3554226970987964f64,
        2.746450110938277f64,
        1.776919711455427f64,
        2.419724474964938f64,
        1.784250094313803f64,
        5.522396286235258f64,
        5.3059754589879615f64,
        5.388005933831694f64,
        5.948431156647074f64,
        4.522846223618106f64,
        3.568500188627606f64,
        11.044792572470516f64,
    ],
    theta1: [
        959.7891933286942f64,
        731.077582955928f64,
        522.3307938967249f64,
        449.1358738582876f64,
        427.10754977009157f64,
        388.83160660922994f64,
        354.1171823199879f64,
        290.6454915444109f64,
        224.66977689099764f64,
        140.70512817020406f64,
        -35.32930378471962f64,
        49.9855316454168f64,
        -0.9065240134858548f64,
        -1.626123264083117f64,
        -1.314581992602129f64,
        -8.810596596992575f64,
        -70.65860756943924f64,
        99.9710632908336f64,
    ],
};
const ROTATION_PORTIA: RotationalElement<18usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 0.4368559117741807f64,
    c1: -12.243250601727652f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        -0.00034906585039886593f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
    ],
    theta0: [
        2.0202186091834364f64,
        2.4729570171507653f64,
        2.356718088967943f64,
        1.0780898789568973f64,
        4.351454891072263f64,
        0.7655014099247129f64,
        1.3554226970987964f64,
        2.746450110938277f64,
        1.776919711455427f64,
        2.419724474964938f64,
        1.784250094313803f64,
        5.522396286235258f64,
        5.3059754589879615f64,
        5.388005933831694f64,
        5.948431156647074f64,
        4.522846223618106f64,
        3.568500188627606f64,
        11.044792572470516f64,
    ],
    theta1: [
        959.7891933286942f64,
        731.077582955928f64,
        522.3307938967249f64,
        449.1358738582876f64,
        427.10754977009157f64,
        388.83160660922994f64,
        354.1171823199879f64,
        290.6454915444109f64,
        224.66977689099764f64,
        140.70512817020406f64,
        -35.32930378471962f64,
        49.9855316454168f64,
        -0.9065240134858548f64,
        -1.626123264083117f64,
        -1.314581992602129f64,
        -8.810596596992575f64,
        -70.65860756943924f64,
        99.9710632908336f64,
    ],
};
impl RotationalElements for Portia {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_PORTIA.angle(t),
            DECLINATION_PORTIA.angle(t),
            ROTATION_PORTIA.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_PORTIA.angle_dot(t),
            DECLINATION_PORTIA.angle_dot(t),
            ROTATION_PORTIA.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Rosalind;
impl Origin for Rosalind {
    fn id(&self) -> NaifId {
        NaifId(713i32)
    }
    fn name(&self) -> &'static str {
        "Rosalind"
    }
}
impl Display for Rosalind {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl MeanRadius for Rosalind {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(27f64)
    }
}
impl TriaxialEllipsoid for Rosalind {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(27f64),
            Distance::kilometers(27f64),
            Distance::kilometers(27f64),
        )
    }
}
impl Spheroid for Rosalind {}
const RIGHT_ASCENSION_ROSALIND: RotationalElement<18usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 4.49090669830661f64,
    c1: 0f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        -0.005061454830783556f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
    ],
    theta0: [
        2.0202186091834364f64,
        2.4729570171507653f64,
        2.356718088967943f64,
        1.0780898789568973f64,
        4.351454891072263f64,
        0.7655014099247129f64,
        1.3554226970987964f64,
        2.746450110938277f64,
        1.776919711455427f64,
        2.419724474964938f64,
        1.784250094313803f64,
        5.522396286235258f64,
        5.3059754589879615f64,
        5.388005933831694f64,
        5.948431156647074f64,
        4.522846223618106f64,
        3.568500188627606f64,
        11.044792572470516f64,
    ],
    theta1: [
        959.7891933286942f64,
        731.077582955928f64,
        522.3307938967249f64,
        449.1358738582876f64,
        427.10754977009157f64,
        388.83160660922994f64,
        354.1171823199879f64,
        290.6454915444109f64,
        224.66977689099764f64,
        140.70512817020406f64,
        -35.32930378471962f64,
        49.9855316454168f64,
        -0.9065240134858548f64,
        -1.626123264083117f64,
        -1.314581992602129f64,
        -8.810596596992575f64,
        -70.65860756943924f64,
        99.9710632908336f64,
    ],
};
const DECLINATION_ROSALIND: RotationalElement<18usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: -0.2649409804527392f64,
    c1: 0f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0.004886921905584123f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
    ],
    theta0: [
        2.0202186091834364f64,
        2.4729570171507653f64,
        2.356718088967943f64,
        1.0780898789568973f64,
        4.351454891072263f64,
        0.7655014099247129f64,
        1.3554226970987964f64,
        2.746450110938277f64,
        1.776919711455427f64,
        2.419724474964938f64,
        1.784250094313803f64,
        5.522396286235258f64,
        5.3059754589879615f64,
        5.388005933831694f64,
        5.948431156647074f64,
        4.522846223618106f64,
        3.568500188627606f64,
        11.044792572470516f64,
    ],
    theta1: [
        959.7891933286942f64,
        731.077582955928f64,
        522.3307938967249f64,
        449.1358738582876f64,
        427.10754977009157f64,
        388.83160660922994f64,
        354.1171823199879f64,
        290.6454915444109f64,
        224.66977689099764f64,
        140.70512817020406f64,
        -35.32930378471962f64,
        49.9855316454168f64,
        -0.9065240134858548f64,
        -1.626123264083117f64,
        -1.314581992602129f64,
        -8.810596596992575f64,
        -70.65860756943924f64,
        99.9710632908336f64,
    ],
};
const ROTATION_ROSALIND: RotationalElement<18usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 5.496041814530144f64,
    c1: -11.250935609538423f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        -0.0013962634015954637f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
    ],
    theta0: [
        2.0202186091834364f64,
        2.4729570171507653f64,
        2.356718088967943f64,
        1.0780898789568973f64,
        4.351454891072263f64,
        0.7655014099247129f64,
        1.3554226970987964f64,
        2.746450110938277f64,
        1.776919711455427f64,
        2.419724474964938f64,
        1.784250094313803f64,
        5.522396286235258f64,
        5.3059754589879615f64,
        5.388005933831694f64,
        5.948431156647074f64,
        4.522846223618106f64,
        3.568500188627606f64,
        11.044792572470516f64,
    ],
    theta1: [
        959.7891933286942f64,
        731.077582955928f64,
        522.3307938967249f64,
        449.1358738582876f64,
        427.10754977009157f64,
        388.83160660922994f64,
        354.1171823199879f64,
        290.6454915444109f64,
        224.66977689099764f64,
        140.70512817020406f64,
        -35.32930378471962f64,
        49.9855316454168f64,
        -0.9065240134858548f64,
        -1.626123264083117f64,
        -1.314581992602129f64,
        -8.810596596992575f64,
        -70.65860756943924f64,
        99.9710632908336f64,
    ],
};
impl RotationalElements for Rosalind {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_ROSALIND.angle(t),
            DECLINATION_ROSALIND.angle(t),
            ROTATION_ROSALIND.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_ROSALIND.angle_dot(t),
            DECLINATION_ROSALIND.angle_dot(t),
            ROTATION_ROSALIND.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Belinda;
impl Origin for Belinda {
    fn id(&self) -> NaifId {
        NaifId(714i32)
    }
    fn name(&self) -> &'static str {
        "Belinda"
    }
}
impl Display for Belinda {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl MeanRadius for Belinda {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(33f64)
    }
}
impl TriaxialEllipsoid for Belinda {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(33f64),
            Distance::kilometers(33f64),
            Distance::kilometers(33f64),
        )
    }
}
impl Spheroid for Belinda {}
const RIGHT_ASCENSION_BELINDA: RotationalElement<18usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 4.49090669830661f64,
    c1: 0f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        -0.0005235987755982988f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
    ],
    theta0: [
        2.0202186091834364f64,
        2.4729570171507653f64,
        2.356718088967943f64,
        1.0780898789568973f64,
        4.351454891072263f64,
        0.7655014099247129f64,
        1.3554226970987964f64,
        2.746450110938277f64,
        1.776919711455427f64,
        2.419724474964938f64,
        1.784250094313803f64,
        5.522396286235258f64,
        5.3059754589879615f64,
        5.388005933831694f64,
        5.948431156647074f64,
        4.522846223618106f64,
        3.568500188627606f64,
        11.044792572470516f64,
    ],
    theta1: [
        959.7891933286942f64,
        731.077582955928f64,
        522.3307938967249f64,
        449.1358738582876f64,
        427.10754977009157f64,
        388.83160660922994f64,
        354.1171823199879f64,
        290.6454915444109f64,
        224.66977689099764f64,
        140.70512817020406f64,
        -35.32930378471962f64,
        49.9855316454168f64,
        -0.9065240134858548f64,
        -1.626123264083117f64,
        -1.314581992602129f64,
        -8.810596596992575f64,
        -70.65860756943924f64,
        99.9710632908336f64,
    ],
};
const DECLINATION_BELINDA: RotationalElement<18usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: -0.2649409804527392f64,
    c1: 0f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0.0005235987755982988f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
    ],
    theta0: [
        2.0202186091834364f64,
        2.4729570171507653f64,
        2.356718088967943f64,
        1.0780898789568973f64,
        4.351454891072263f64,
        0.7655014099247129f64,
        1.3554226970987964f64,
        2.746450110938277f64,
        1.776919711455427f64,
        2.419724474964938f64,
        1.784250094313803f64,
        5.522396286235258f64,
        5.3059754589879615f64,
        5.388005933831694f64,
        5.948431156647074f64,
        4.522846223618106f64,
        3.568500188627606f64,
        11.044792572470516f64,
    ],
    theta1: [
        959.7891933286942f64,
        731.077582955928f64,
        522.3307938967249f64,
        449.1358738582876f64,
        427.10754977009157f64,
        388.83160660922994f64,
        354.1171823199879f64,
        290.6454915444109f64,
        224.66977689099764f64,
        140.70512817020406f64,
        -35.32930378471962f64,
        49.9855316454168f64,
        -0.9065240134858548f64,
        -1.626123264083117f64,
        -1.314581992602129f64,
        -8.810596596992575f64,
        -70.65860756943924f64,
        99.9710632908336f64,
    ],
};
const ROTATION_BELINDA: RotationalElement<18usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 5.191656392982332f64,
    c1: -10.076882135239488f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        -0.00017453292519943296f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
    ],
    theta0: [
        2.0202186091834364f64,
        2.4729570171507653f64,
        2.356718088967943f64,
        1.0780898789568973f64,
        4.351454891072263f64,
        0.7655014099247129f64,
        1.3554226970987964f64,
        2.746450110938277f64,
        1.776919711455427f64,
        2.419724474964938f64,
        1.784250094313803f64,
        5.522396286235258f64,
        5.3059754589879615f64,
        5.388005933831694f64,
        5.948431156647074f64,
        4.522846223618106f64,
        3.568500188627606f64,
        11.044792572470516f64,
    ],
    theta1: [
        959.7891933286942f64,
        731.077582955928f64,
        522.3307938967249f64,
        449.1358738582876f64,
        427.10754977009157f64,
        388.83160660922994f64,
        354.1171823199879f64,
        290.6454915444109f64,
        224.66977689099764f64,
        140.70512817020406f64,
        -35.32930378471962f64,
        49.9855316454168f64,
        -0.9065240134858548f64,
        -1.626123264083117f64,
        -1.314581992602129f64,
        -8.810596596992575f64,
        -70.65860756943924f64,
        99.9710632908336f64,
    ],
};
impl RotationalElements for Belinda {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_BELINDA.angle(t),
            DECLINATION_BELINDA.angle(t),
            ROTATION_BELINDA.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_BELINDA.angle_dot(t),
            DECLINATION_BELINDA.angle_dot(t),
            ROTATION_BELINDA.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Puck;
impl Origin for Puck {
    fn id(&self) -> NaifId {
        NaifId(715i32)
    }
    fn name(&self) -> &'static str {
        "Puck"
    }
}
impl Display for Puck {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl MeanRadius for Puck {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(77f64)
    }
}
impl TriaxialEllipsoid for Puck {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(77f64),
            Distance::kilometers(77f64),
            Distance::kilometers(77f64),
        )
    }
}
impl Spheroid for Puck {}
const RIGHT_ASCENSION_PUCK: RotationalElement<18usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 4.49090669830661f64,
    c1: 0f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        -0.005759586531581287f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
    ],
    theta0: [
        2.0202186091834364f64,
        2.4729570171507653f64,
        2.356718088967943f64,
        1.0780898789568973f64,
        4.351454891072263f64,
        0.7655014099247129f64,
        1.3554226970987964f64,
        2.746450110938277f64,
        1.776919711455427f64,
        2.419724474964938f64,
        1.784250094313803f64,
        5.522396286235258f64,
        5.3059754589879615f64,
        5.388005933831694f64,
        5.948431156647074f64,
        4.522846223618106f64,
        3.568500188627606f64,
        11.044792572470516f64,
    ],
    theta1: [
        959.7891933286942f64,
        731.077582955928f64,
        522.3307938967249f64,
        449.1358738582876f64,
        427.10754977009157f64,
        388.83160660922994f64,
        354.1171823199879f64,
        290.6454915444109f64,
        224.66977689099764f64,
        140.70512817020406f64,
        -35.32930378471962f64,
        49.9855316454168f64,
        -0.9065240134858548f64,
        -1.626123264083117f64,
        -1.314581992602129f64,
        -8.810596596992575f64,
        -70.65860756943924f64,
        99.9710632908336f64,
    ],
};
const DECLINATION_PUCK: RotationalElement<18usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: -0.2649409804527392f64,
    c1: 0f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0.0054105206811824215f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
    ],
    theta0: [
        2.0202186091834364f64,
        2.4729570171507653f64,
        2.356718088967943f64,
        1.0780898789568973f64,
        4.351454891072263f64,
        0.7655014099247129f64,
        1.3554226970987964f64,
        2.746450110938277f64,
        1.776919711455427f64,
        2.419724474964938f64,
        1.784250094313803f64,
        5.522396286235258f64,
        5.3059754589879615f64,
        5.388005933831694f64,
        5.948431156647074f64,
        4.522846223618106f64,
        3.568500188627606f64,
        11.044792572470516f64,
    ],
    theta1: [
        959.7891933286942f64,
        731.077582955928f64,
        522.3307938967249f64,
        449.1358738582876f64,
        427.10754977009157f64,
        388.83160660922994f64,
        354.1171823199879f64,
        290.6454915444109f64,
        224.66977689099764f64,
        140.70512817020406f64,
        -35.32930378471962f64,
        49.9855316454168f64,
        -0.9065240134858548f64,
        -1.626123264083117f64,
        -1.314581992602129f64,
        -8.810596596992575f64,
        -70.65860756943924f64,
        99.9710632908336f64,
    ],
};
const ROTATION_PUCK: RotationalElement<18usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 1.5924384095196262f64,
    c1: -8.247467318113788f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        -0.0015707963267948964f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
    ],
    theta0: [
        2.0202186091834364f64,
        2.4729570171507653f64,
        2.356718088967943f64,
        1.0780898789568973f64,
        4.351454891072263f64,
        0.7655014099247129f64,
        1.3554226970987964f64,
        2.746450110938277f64,
        1.776919711455427f64,
        2.419724474964938f64,
        1.784250094313803f64,
        5.522396286235258f64,
        5.3059754589879615f64,
        5.388005933831694f64,
        5.948431156647074f64,
        4.522846223618106f64,
        3.568500188627606f64,
        11.044792572470516f64,
    ],
    theta1: [
        959.7891933286942f64,
        731.077582955928f64,
        522.3307938967249f64,
        449.1358738582876f64,
        427.10754977009157f64,
        388.83160660922994f64,
        354.1171823199879f64,
        290.6454915444109f64,
        224.66977689099764f64,
        140.70512817020406f64,
        -35.32930378471962f64,
        49.9855316454168f64,
        -0.9065240134858548f64,
        -1.626123264083117f64,
        -1.314581992602129f64,
        -8.810596596992575f64,
        -70.65860756943924f64,
        99.9710632908336f64,
    ],
};
impl RotationalElements for Puck {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_PUCK.angle(t),
            DECLINATION_PUCK.angle(t),
            ROTATION_PUCK.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_PUCK.angle_dot(t),
            DECLINATION_PUCK.angle_dot(t),
            ROTATION_PUCK.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Caliban;
impl Origin for Caliban {
    fn id(&self) -> NaifId {
        NaifId(716i32)
    }
    fn name(&self) -> &'static str {
        "Caliban"
    }
}
impl Display for Caliban {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Sycorax;
impl Origin for Sycorax {
    fn id(&self) -> NaifId {
        NaifId(717i32)
    }
    fn name(&self) -> &'static str {
        "Sycorax"
    }
}
impl Display for Sycorax {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Prospero;
impl Origin for Prospero {
    fn id(&self) -> NaifId {
        NaifId(718i32)
    }
    fn name(&self) -> &'static str {
        "Prospero"
    }
}
impl Display for Prospero {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Setebos;
impl Origin for Setebos {
    fn id(&self) -> NaifId {
        NaifId(719i32)
    }
    fn name(&self) -> &'static str {
        "Setebos"
    }
}
impl Display for Setebos {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Stephano;
impl Origin for Stephano {
    fn id(&self) -> NaifId {
        NaifId(720i32)
    }
    fn name(&self) -> &'static str {
        "Stephano"
    }
}
impl Display for Stephano {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Trinculo;
impl Origin for Trinculo {
    fn id(&self) -> NaifId {
        NaifId(721i32)
    }
    fn name(&self) -> &'static str {
        "Trinculo"
    }
}
impl Display for Trinculo {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Francisco;
impl Origin for Francisco {
    fn id(&self) -> NaifId {
        NaifId(722i32)
    }
    fn name(&self) -> &'static str {
        "Francisco"
    }
}
impl Display for Francisco {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Margaret;
impl Origin for Margaret {
    fn id(&self) -> NaifId {
        NaifId(723i32)
    }
    fn name(&self) -> &'static str {
        "Margaret"
    }
}
impl Display for Margaret {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Ferdinand;
impl Origin for Ferdinand {
    fn id(&self) -> NaifId {
        NaifId(724i32)
    }
    fn name(&self) -> &'static str {
        "Ferdinand"
    }
}
impl Display for Ferdinand {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Perdita;
impl Origin for Perdita {
    fn id(&self) -> NaifId {
        NaifId(725i32)
    }
    fn name(&self) -> &'static str {
        "Perdita"
    }
}
impl Display for Perdita {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Mab;
impl Origin for Mab {
    fn id(&self) -> NaifId {
        NaifId(726i32)
    }
    fn name(&self) -> &'static str {
        "Mab"
    }
}
impl Display for Mab {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Cupid;
impl Origin for Cupid {
    fn id(&self) -> NaifId {
        NaifId(727i32)
    }
    fn name(&self) -> &'static str {
        "Cupid"
    }
}
impl Display for Cupid {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Triton;
impl Origin for Triton {
    fn id(&self) -> NaifId {
        NaifId(801i32)
    }
    fn name(&self) -> &'static str {
        "Triton"
    }
}
impl Display for Triton {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for Triton {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(1428.495462910464f64)
    }
}
impl MeanRadius for Triton {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(1352.6f64)
    }
}
impl TriaxialEllipsoid for Triton {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(1352.6f64),
            Distance::kilometers(1352.6f64),
            Distance::kilometers(1352.6f64),
        )
    }
}
impl Spheroid for Triton {}
const RIGHT_ASCENSION_TRITON: RotationalElement<17usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 5.224817648770225f64,
    c1: 0f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        -0.5646140130201657f64,
        0f64,
        -0.1096066770252439f64,
        -0.03630284844148206f64,
        -0.012915436464758038f64,
        -0.004886921905584123f64,
        -0.0019198621771937625f64,
        -0.0012217304763960308f64,
        -0.00034906585039886593f64,
        -0.00017453292519943296f64,
    ],
    theta0: [
        6.245660728261709f64,
        5.653470513060032f64,
        3.848625533572696f64,
        6.183177941040311f64,
        1.3144074596769295f64,
        0.6171484235051949f64,
        2.4890140462691135f64,
        3.104068074671915f64,
        11.306941026120064f64,
        6.20813614934383f64,
        9.312204224015744f64,
        12.41627229868766f64,
        15.520340373359575f64,
        18.624408448031488f64,
        21.728476522703406f64,
        24.83254459737532f64,
        27.936612672047236f64,
    ],
    theta1: [
        0.9130864514733535f64,
        1092.6913034790819f64,
        961.0515899766616f64,
        812.7038395448996f64,
        455.6949957202075f64,
        250.02539666519567f64,
        49.29857005183183f64,
        0.9130864514733535f64,
        2185.3826069581637f64,
        1.826172902946707f64,
        2.7392593544200605f64,
        3.652345805893414f64,
        4.565432257366767f64,
        5.478518708840121f64,
        6.391605160313474f64,
        7.304691611786828f64,
        8.21777806326018f64,
    ],
};
const DECLINATION_TRITON: RotationalElement<17usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: 0.7185520530460655f64,
    c1: 0f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0.3935717463247213f64,
        0f64,
        0.03665191429188092f64,
        0.009599310885968814f64,
        0.0027925268031909274f64,
        0.0008726646259971648f64,
        0.00034906585039886593f64,
        0.00017453292519943296f64,
        0f64,
        0f64,
    ],
    theta0: [
        6.245660728261709f64,
        5.653470513060032f64,
        3.848625533572696f64,
        6.183177941040311f64,
        1.3144074596769295f64,
        0.6171484235051949f64,
        2.4890140462691135f64,
        3.104068074671915f64,
        11.306941026120064f64,
        6.20813614934383f64,
        9.312204224015744f64,
        12.41627229868766f64,
        15.520340373359575f64,
        18.624408448031488f64,
        21.728476522703406f64,
        24.83254459737532f64,
        27.936612672047236f64,
    ],
    theta1: [
        0.9130864514733535f64,
        1092.6913034790819f64,
        961.0515899766616f64,
        812.7038395448996f64,
        455.6949957202075f64,
        250.02539666519567f64,
        49.29857005183183f64,
        0.9130864514733535f64,
        2185.3826069581637f64,
        1.826172902946707f64,
        2.7392593544200605f64,
        3.652345805893414f64,
        4.565432257366767f64,
        5.478518708840121f64,
        6.391605160313474f64,
        7.304691611786828f64,
        8.21777806326018f64,
    ],
};
const ROTATION_TRITON: RotationalElement<17usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 5.175424830938785f64,
    c1: -1.069140942327404f64,
    c2: 0f64,
    c: [
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0.3883357585687383f64,
        0f64,
        0.11746065865921838f64,
        0.03577924966588375f64,
        0.012915436464758038f64,
        0.004886921905584123f64,
        0.0019198621771937625f64,
        0.0008726646259971648f64,
        0.00034906585039886593f64,
        0.00017453292519943296f64,
    ],
    theta0: [
        6.245660728261709f64,
        5.653470513060032f64,
        3.848625533572696f64,
        6.183177941040311f64,
        1.3144074596769295f64,
        0.6171484235051949f64,
        2.4890140462691135f64,
        3.104068074671915f64,
        11.306941026120064f64,
        6.20813614934383f64,
        9.312204224015744f64,
        12.41627229868766f64,
        15.520340373359575f64,
        18.624408448031488f64,
        21.728476522703406f64,
        24.83254459737532f64,
        27.936612672047236f64,
    ],
    theta1: [
        0.9130864514733535f64,
        1092.6913034790819f64,
        961.0515899766616f64,
        812.7038395448996f64,
        455.6949957202075f64,
        250.02539666519567f64,
        49.29857005183183f64,
        0.9130864514733535f64,
        2185.3826069581637f64,
        1.826172902946707f64,
        2.7392593544200605f64,
        3.652345805893414f64,
        4.565432257366767f64,
        5.478518708840121f64,
        6.391605160313474f64,
        7.304691611786828f64,
        8.21777806326018f64,
    ],
};
impl RotationalElements for Triton {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_TRITON.angle(t),
            DECLINATION_TRITON.angle(t),
            ROTATION_TRITON.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_TRITON.angle_dot(t),
            DECLINATION_TRITON.angle_dot(t),
            ROTATION_TRITON.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Nereid;
impl Origin for Nereid {
    fn id(&self) -> NaifId {
        NaifId(802i32)
    }
    fn name(&self) -> &'static str {
        "Nereid"
    }
}
impl Display for Nereid {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl MeanRadius for Nereid {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(170f64)
    }
}
impl TriaxialEllipsoid for Nereid {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(170f64),
            Distance::kilometers(170f64),
            Distance::kilometers(170f64),
        )
    }
}
impl Spheroid for Nereid {}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Naiad;
impl Origin for Naiad {
    fn id(&self) -> NaifId {
        NaifId(803i32)
    }
    fn name(&self) -> &'static str {
        "Naiad"
    }
}
impl Display for Naiad {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for Naiad {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(0.008530281246540886f64)
    }
}
impl MeanRadius for Naiad {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(29f64)
    }
}
impl TriaxialEllipsoid for Naiad {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(29f64),
            Distance::kilometers(29f64),
            Distance::kilometers(29f64),
        )
    }
}
impl Spheroid for Naiad {}
const RIGHT_ASCENSION_NAIAD: RotationalElement<17usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 5.224817648770225f64,
    c1: 0f64,
    c2: 0f64,
    c: [
        0.012217304763960306f64,
        -0.11327186845443199f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0.004363323129985824f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
    ],
    theta0: [
        6.245660728261709f64,
        5.653470513060032f64,
        3.848625533572696f64,
        6.183177941040311f64,
        1.3144074596769295f64,
        0.6171484235051949f64,
        2.4890140462691135f64,
        3.104068074671915f64,
        11.306941026120064f64,
        6.20813614934383f64,
        9.312204224015744f64,
        12.41627229868766f64,
        15.520340373359575f64,
        18.624408448031488f64,
        21.728476522703406f64,
        24.83254459737532f64,
        27.936612672047236f64,
    ],
    theta1: [
        0.9130864514733535f64,
        1092.6913034790819f64,
        961.0515899766616f64,
        812.7038395448996f64,
        455.6949957202075f64,
        250.02539666519567f64,
        49.29857005183183f64,
        0.9130864514733535f64,
        2185.3826069581637f64,
        1.826172902946707f64,
        2.7392593544200605f64,
        3.652345805893414f64,
        4.565432257366767f64,
        5.478518708840121f64,
        6.391605160313474f64,
        7.304691611786828f64,
        8.21777806326018f64,
    ],
};
const DECLINATION_NAIAD: RotationalElement<17usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: 0.7567747636647413f64,
    c1: 0f64,
    c2: 0f64,
    c: [
        -0.00890117918517108f64,
        -0.08290313946973066f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0.0015707963267948964f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
    ],
    theta0: [
        6.245660728261709f64,
        5.653470513060032f64,
        3.848625533572696f64,
        6.183177941040311f64,
        1.3144074596769295f64,
        0.6171484235051949f64,
        2.4890140462691135f64,
        3.104068074671915f64,
        11.306941026120064f64,
        6.20813614934383f64,
        9.312204224015744f64,
        12.41627229868766f64,
        15.520340373359575f64,
        18.624408448031488f64,
        21.728476522703406f64,
        24.83254459737532f64,
        27.936612672047236f64,
    ],
    theta1: [
        0.9130864514733535f64,
        1092.6913034790819f64,
        961.0515899766616f64,
        812.7038395448996f64,
        455.6949957202075f64,
        250.02539666519567f64,
        49.29857005183183f64,
        0.9130864514733535f64,
        2185.3826069581637f64,
        1.826172902946707f64,
        2.7392593544200605f64,
        3.652345805893414f64,
        4.565432257366767f64,
        5.478518708840121f64,
        6.391605160313474f64,
        7.304691611786828f64,
        8.21777806326018f64,
    ],
};
const ROTATION_NAIAD: RotationalElement<17usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 4.434183497616794f64,
    c1: 21.342656148360604f64,
    c2: 0f64,
    c: [
        -0.008377580409572781f64,
        0.07679448708775051f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        -0.00471238898038469f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
    ],
    theta0: [
        6.245660728261709f64,
        5.653470513060032f64,
        3.848625533572696f64,
        6.183177941040311f64,
        1.3144074596769295f64,
        0.6171484235051949f64,
        2.4890140462691135f64,
        3.104068074671915f64,
        11.306941026120064f64,
        6.20813614934383f64,
        9.312204224015744f64,
        12.41627229868766f64,
        15.520340373359575f64,
        18.624408448031488f64,
        21.728476522703406f64,
        24.83254459737532f64,
        27.936612672047236f64,
    ],
    theta1: [
        0.9130864514733535f64,
        1092.6913034790819f64,
        961.0515899766616f64,
        812.7038395448996f64,
        455.6949957202075f64,
        250.02539666519567f64,
        49.29857005183183f64,
        0.9130864514733535f64,
        2185.3826069581637f64,
        1.826172902946707f64,
        2.7392593544200605f64,
        3.652345805893414f64,
        4.565432257366767f64,
        5.478518708840121f64,
        6.391605160313474f64,
        7.304691611786828f64,
        8.21777806326018f64,
    ],
};
impl RotationalElements for Naiad {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_NAIAD.angle(t),
            DECLINATION_NAIAD.angle(t),
            ROTATION_NAIAD.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_NAIAD.angle_dot(t),
            DECLINATION_NAIAD.angle_dot(t),
            ROTATION_NAIAD.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Thalassa;
impl Origin for Thalassa {
    fn id(&self) -> NaifId {
        NaifId(804i32)
    }
    fn name(&self) -> &'static str {
        "Thalassa"
    }
}
impl Display for Thalassa {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for Thalassa {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(0.0235887319799217f64)
    }
}
impl MeanRadius for Thalassa {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(40f64)
    }
}
impl TriaxialEllipsoid for Thalassa {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(40f64),
            Distance::kilometers(40f64),
            Distance::kilometers(40f64),
        )
    }
}
impl Spheroid for Thalassa {}
const RIGHT_ASCENSION_THALASSA: RotationalElement<17usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 5.224817648770225f64,
    c1: 0f64,
    c2: 0f64,
    c: [
        0.012217304763960306f64,
        0f64,
        -0.004886921905584123f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
    ],
    theta0: [
        6.245660728261709f64,
        5.653470513060032f64,
        3.848625533572696f64,
        6.183177941040311f64,
        1.3144074596769295f64,
        0.6171484235051949f64,
        2.4890140462691135f64,
        3.104068074671915f64,
        11.306941026120064f64,
        6.20813614934383f64,
        9.312204224015744f64,
        12.41627229868766f64,
        15.520340373359575f64,
        18.624408448031488f64,
        21.728476522703406f64,
        24.83254459737532f64,
        27.936612672047236f64,
    ],
    theta1: [
        0.9130864514733535f64,
        1092.6913034790819f64,
        961.0515899766616f64,
        812.7038395448996f64,
        455.6949957202075f64,
        250.02539666519567f64,
        49.29857005183183f64,
        0.9130864514733535f64,
        2185.3826069581637f64,
        1.826172902946707f64,
        2.7392593544200605f64,
        3.652345805893414f64,
        4.565432257366767f64,
        5.478518708840121f64,
        6.391605160313474f64,
        7.304691611786828f64,
        8.21777806326018f64,
    ],
};
const DECLINATION_THALASSA: RotationalElement<17usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: 0.7583455599915362f64,
    c1: 0f64,
    c2: 0f64,
    c: [
        -0.00890117918517108f64,
        0f64,
        -0.003665191429188092f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
    ],
    theta0: [
        6.245660728261709f64,
        5.653470513060032f64,
        3.848625533572696f64,
        6.183177941040311f64,
        1.3144074596769295f64,
        0.6171484235051949f64,
        2.4890140462691135f64,
        3.104068074671915f64,
        11.306941026120064f64,
        6.20813614934383f64,
        9.312204224015744f64,
        12.41627229868766f64,
        15.520340373359575f64,
        18.624408448031488f64,
        21.728476522703406f64,
        24.83254459737532f64,
        27.936612672047236f64,
    ],
    theta1: [
        0.9130864514733535f64,
        1092.6913034790819f64,
        961.0515899766616f64,
        812.7038395448996f64,
        455.6949957202075f64,
        250.02539666519567f64,
        49.29857005183183f64,
        0.9130864514733535f64,
        2185.3826069581637f64,
        1.826172902946707f64,
        2.7392593544200605f64,
        3.652345805893414f64,
        4.565432257366767f64,
        5.478518708840121f64,
        6.391605160313474f64,
        7.304691611786828f64,
        8.21777806326018f64,
    ],
};
const ROTATION_THALASSA: RotationalElement<17usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 1.7812830345854127f64,
    c1: 20.171739891174827f64,
    c2: 0f64,
    c: [
        -0.008377580409572781f64,
        0f64,
        0.0033161255787892262f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
    ],
    theta0: [
        6.245660728261709f64,
        5.653470513060032f64,
        3.848625533572696f64,
        6.183177941040311f64,
        1.3144074596769295f64,
        0.6171484235051949f64,
        2.4890140462691135f64,
        3.104068074671915f64,
        11.306941026120064f64,
        6.20813614934383f64,
        9.312204224015744f64,
        12.41627229868766f64,
        15.520340373359575f64,
        18.624408448031488f64,
        21.728476522703406f64,
        24.83254459737532f64,
        27.936612672047236f64,
    ],
    theta1: [
        0.9130864514733535f64,
        1092.6913034790819f64,
        961.0515899766616f64,
        812.7038395448996f64,
        455.6949957202075f64,
        250.02539666519567f64,
        49.29857005183183f64,
        0.9130864514733535f64,
        2185.3826069581637f64,
        1.826172902946707f64,
        2.7392593544200605f64,
        3.652345805893414f64,
        4.565432257366767f64,
        5.478518708840121f64,
        6.391605160313474f64,
        7.304691611786828f64,
        8.21777806326018f64,
    ],
};
impl RotationalElements for Thalassa {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_THALASSA.angle(t),
            DECLINATION_THALASSA.angle(t),
            ROTATION_THALASSA.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_THALASSA.angle_dot(t),
            DECLINATION_THALASSA.angle_dot(t),
            ROTATION_THALASSA.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Despina;
impl Origin for Despina {
    fn id(&self) -> NaifId {
        NaifId(805i32)
    }
    fn name(&self) -> &'static str {
        "Despina"
    }
}
impl Display for Despina {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for Despina {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(0.1167318403814998f64)
    }
}
impl MeanRadius for Despina {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(74f64)
    }
}
impl TriaxialEllipsoid for Despina {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(74f64),
            Distance::kilometers(74f64),
            Distance::kilometers(74f64),
        )
    }
}
impl Spheroid for Despina {}
const RIGHT_ASCENSION_DESPINA: RotationalElement<17usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 5.224817648770225f64,
    c1: 0f64,
    c2: 0f64,
    c: [
        0.012217304763960306f64,
        0f64,
        0f64,
        -0.0015707963267948964f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
    ],
    theta0: [
        6.245660728261709f64,
        5.653470513060032f64,
        3.848625533572696f64,
        6.183177941040311f64,
        1.3144074596769295f64,
        0.6171484235051949f64,
        2.4890140462691135f64,
        3.104068074671915f64,
        11.306941026120064f64,
        6.20813614934383f64,
        9.312204224015744f64,
        12.41627229868766f64,
        15.520340373359575f64,
        18.624408448031488f64,
        21.728476522703406f64,
        24.83254459737532f64,
        27.936612672047236f64,
    ],
    theta1: [
        0.9130864514733535f64,
        1092.6913034790819f64,
        961.0515899766616f64,
        812.7038395448996f64,
        455.6949957202075f64,
        250.02539666519567f64,
        49.29857005183183f64,
        0.9130864514733535f64,
        2185.3826069581637f64,
        1.826172902946707f64,
        2.7392593544200605f64,
        3.652345805893414f64,
        4.565432257366767f64,
        5.478518708840121f64,
        6.391605160313474f64,
        7.304691611786828f64,
        8.21777806326018f64,
    ],
};
const DECLINATION_DESPINA: RotationalElement<17usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: 0.7583455599915362f64,
    c1: 0f64,
    c2: 0f64,
    c: [
        -0.00890117918517108f64,
        0f64,
        0f64,
        -0.0012217304763960308f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
    ],
    theta0: [
        6.245660728261709f64,
        5.653470513060032f64,
        3.848625533572696f64,
        6.183177941040311f64,
        1.3144074596769295f64,
        0.6171484235051949f64,
        2.4890140462691135f64,
        3.104068074671915f64,
        11.306941026120064f64,
        6.20813614934383f64,
        9.312204224015744f64,
        12.41627229868766f64,
        15.520340373359575f64,
        18.624408448031488f64,
        21.728476522703406f64,
        24.83254459737532f64,
        27.936612672047236f64,
    ],
    theta1: [
        0.9130864514733535f64,
        1092.6913034790819f64,
        961.0515899766616f64,
        812.7038395448996f64,
        455.6949957202075f64,
        250.02539666519567f64,
        49.29857005183183f64,
        0.9130864514733535f64,
        2185.3826069581637f64,
        1.826172902946707f64,
        2.7392593544200605f64,
        3.652345805893414f64,
        4.565432257366767f64,
        5.478518708840121f64,
        6.391605160313474f64,
        7.304691611786828f64,
        8.21777806326018f64,
    ],
};
const ROTATION_DESPINA: RotationalElement<17usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 5.34960869028782f64,
    c1: 18.77510290185297f64,
    c2: 0f64,
    c: [
        -0.008552113334772215f64,
        0f64,
        0f64,
        0.0010471975511965976f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
    ],
    theta0: [
        6.245660728261709f64,
        5.653470513060032f64,
        3.848625533572696f64,
        6.183177941040311f64,
        1.3144074596769295f64,
        0.6171484235051949f64,
        2.4890140462691135f64,
        3.104068074671915f64,
        11.306941026120064f64,
        6.20813614934383f64,
        9.312204224015744f64,
        12.41627229868766f64,
        15.520340373359575f64,
        18.624408448031488f64,
        21.728476522703406f64,
        24.83254459737532f64,
        27.936612672047236f64,
    ],
    theta1: [
        0.9130864514733535f64,
        1092.6913034790819f64,
        961.0515899766616f64,
        812.7038395448996f64,
        455.6949957202075f64,
        250.02539666519567f64,
        49.29857005183183f64,
        0.9130864514733535f64,
        2185.3826069581637f64,
        1.826172902946707f64,
        2.7392593544200605f64,
        3.652345805893414f64,
        4.565432257366767f64,
        5.478518708840121f64,
        6.391605160313474f64,
        7.304691611786828f64,
        8.21777806326018f64,
    ],
};
impl RotationalElements for Despina {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_DESPINA.angle(t),
            DECLINATION_DESPINA.angle(t),
            ROTATION_DESPINA.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_DESPINA.angle_dot(t),
            DECLINATION_DESPINA.angle_dot(t),
            ROTATION_DESPINA.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Galatea;
impl Origin for Galatea {
    fn id(&self) -> NaifId {
        NaifId(806i32)
    }
    fn name(&self) -> &'static str {
        "Galatea"
    }
}
impl Display for Galatea {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for Galatea {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(0.189898503906069f64)
    }
}
impl MeanRadius for Galatea {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(79f64)
    }
}
impl TriaxialEllipsoid for Galatea {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(79f64),
            Distance::kilometers(79f64),
            Distance::kilometers(79f64),
        )
    }
}
impl Spheroid for Galatea {}
const RIGHT_ASCENSION_GALATEA: RotationalElement<17usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 5.224817648770225f64,
    c1: 0f64,
    c2: 0f64,
    c: [
        0.012217304763960306f64,
        0f64,
        0f64,
        0f64,
        -0.0012217304763960308f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
    ],
    theta0: [
        6.245660728261709f64,
        5.653470513060032f64,
        3.848625533572696f64,
        6.183177941040311f64,
        1.3144074596769295f64,
        0.6171484235051949f64,
        2.4890140462691135f64,
        3.104068074671915f64,
        11.306941026120064f64,
        6.20813614934383f64,
        9.312204224015744f64,
        12.41627229868766f64,
        15.520340373359575f64,
        18.624408448031488f64,
        21.728476522703406f64,
        24.83254459737532f64,
        27.936612672047236f64,
    ],
    theta1: [
        0.9130864514733535f64,
        1092.6913034790819f64,
        961.0515899766616f64,
        812.7038395448996f64,
        455.6949957202075f64,
        250.02539666519567f64,
        49.29857005183183f64,
        0.9130864514733535f64,
        2185.3826069581637f64,
        1.826172902946707f64,
        2.7392593544200605f64,
        3.652345805893414f64,
        4.565432257366767f64,
        5.478518708840121f64,
        6.391605160313474f64,
        7.304691611786828f64,
        8.21777806326018f64,
    ],
};
const DECLINATION_GALATEA: RotationalElement<17usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: 0.7579964941411373f64,
    c1: 0f64,
    c2: 0f64,
    c: [
        -0.00890117918517108f64,
        0f64,
        0f64,
        0f64,
        -0.0008726646259971648f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
    ],
    theta0: [
        6.245660728261709f64,
        5.653470513060032f64,
        3.848625533572696f64,
        6.183177941040311f64,
        1.3144074596769295f64,
        0.6171484235051949f64,
        2.4890140462691135f64,
        3.104068074671915f64,
        11.306941026120064f64,
        6.20813614934383f64,
        9.312204224015744f64,
        12.41627229868766f64,
        15.520340373359575f64,
        18.624408448031488f64,
        21.728476522703406f64,
        24.83254459737532f64,
        27.936612672047236f64,
    ],
    theta1: [
        0.9130864514733535f64,
        1092.6913034790819f64,
        961.0515899766616f64,
        812.7038395448996f64,
        455.6949957202075f64,
        250.02539666519567f64,
        49.29857005183183f64,
        0.9130864514733535f64,
        2185.3826069581637f64,
        1.826172902946707f64,
        2.7392593544200605f64,
        3.652345805893414f64,
        4.565432257366767f64,
        5.478518708840121f64,
        6.391605160313474f64,
        7.304691611786828f64,
        8.21777806326018f64,
    ],
};
const ROTATION_GALATEA: RotationalElement<17usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 4.504520266472165f64,
    c1: 14.6548275586037f64,
    c2: 0f64,
    c: [
        -0.008377580409572781f64,
        0f64,
        0f64,
        0f64,
        0.0008726646259971648f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
    ],
    theta0: [
        6.245660728261709f64,
        5.653470513060032f64,
        3.848625533572696f64,
        6.183177941040311f64,
        1.3144074596769295f64,
        0.6171484235051949f64,
        2.4890140462691135f64,
        3.104068074671915f64,
        11.306941026120064f64,
        6.20813614934383f64,
        9.312204224015744f64,
        12.41627229868766f64,
        15.520340373359575f64,
        18.624408448031488f64,
        21.728476522703406f64,
        24.83254459737532f64,
        27.936612672047236f64,
    ],
    theta1: [
        0.9130864514733535f64,
        1092.6913034790819f64,
        961.0515899766616f64,
        812.7038395448996f64,
        455.6949957202075f64,
        250.02539666519567f64,
        49.29857005183183f64,
        0.9130864514733535f64,
        2185.3826069581637f64,
        1.826172902946707f64,
        2.7392593544200605f64,
        3.652345805893414f64,
        4.565432257366767f64,
        5.478518708840121f64,
        6.391605160313474f64,
        7.304691611786828f64,
        8.21777806326018f64,
    ],
};
impl RotationalElements for Galatea {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_GALATEA.angle(t),
            DECLINATION_GALATEA.angle(t),
            ROTATION_GALATEA.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_GALATEA.angle_dot(t),
            DECLINATION_GALATEA.angle_dot(t),
            ROTATION_GALATEA.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Larissa;
impl Origin for Larissa {
    fn id(&self) -> NaifId {
        NaifId(807i32)
    }
    fn name(&self) -> &'static str {
        "Larissa"
    }
}
impl Display for Larissa {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for Larissa {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(0.2548437405693583f64)
    }
}
impl MeanRadius for Larissa {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(96f64)
    }
}
impl TriaxialEllipsoid for Larissa {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(96f64),
            Distance::kilometers(96f64),
            Distance::kilometers(96f64),
        )
    }
}
impl Spheroid for Larissa {}
const RIGHT_ASCENSION_LARISSA: RotationalElement<17usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 5.224817648770225f64,
    c1: 0f64,
    c2: 0f64,
    c: [
        0.012217304763960306f64,
        0f64,
        0f64,
        0f64,
        0f64,
        -0.00471238898038469f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
    ],
    theta0: [
        6.245660728261709f64,
        5.653470513060032f64,
        3.848625533572696f64,
        6.183177941040311f64,
        1.3144074596769295f64,
        0.6171484235051949f64,
        2.4890140462691135f64,
        3.104068074671915f64,
        11.306941026120064f64,
        6.20813614934383f64,
        9.312204224015744f64,
        12.41627229868766f64,
        15.520340373359575f64,
        18.624408448031488f64,
        21.728476522703406f64,
        24.83254459737532f64,
        27.936612672047236f64,
    ],
    theta1: [
        0.9130864514733535f64,
        1092.6913034790819f64,
        961.0515899766616f64,
        812.7038395448996f64,
        455.6949957202075f64,
        250.02539666519567f64,
        49.29857005183183f64,
        0.9130864514733535f64,
        2185.3826069581637f64,
        1.826172902946707f64,
        2.7392593544200605f64,
        3.652345805893414f64,
        4.565432257366767f64,
        5.478518708840121f64,
        6.391605160313474f64,
        7.304691611786828f64,
        8.21777806326018f64,
    ],
};
const DECLINATION_LARISSA: RotationalElement<17usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: 0.7576474282907384f64,
    c1: 0f64,
    c2: 0f64,
    c: [
        -0.00890117918517108f64,
        0f64,
        0f64,
        0f64,
        0f64,
        -0.003490658503988659f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
    ],
    theta0: [
        6.245660728261709f64,
        5.653470513060032f64,
        3.848625533572696f64,
        6.183177941040311f64,
        1.3144074596769295f64,
        0.6171484235051949f64,
        2.4890140462691135f64,
        3.104068074671915f64,
        11.306941026120064f64,
        6.20813614934383f64,
        9.312204224015744f64,
        12.41627229868766f64,
        15.520340373359575f64,
        18.624408448031488f64,
        21.728476522703406f64,
        24.83254459737532f64,
        27.936612672047236f64,
    ],
    theta1: [
        0.9130864514733535f64,
        1092.6913034790819f64,
        961.0515899766616f64,
        812.7038395448996f64,
        455.6949957202075f64,
        250.02539666519567f64,
        49.29857005183183f64,
        0.9130864514733535f64,
        2185.3826069581637f64,
        1.826172902946707f64,
        2.7392593544200605f64,
        3.652345805893414f64,
        4.565432257366767f64,
        5.478518708840121f64,
        6.391605160313474f64,
        7.304691611786828f64,
        8.21777806326018f64,
    ],
};
const ROTATION_LARISSA: RotationalElement<17usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 3.1312952110030268f64,
    c1: 11.328119671568512f64,
    c2: 0f64,
    c: [
        -0.008377580409572781f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0.0033161255787892262f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
    ],
    theta0: [
        6.245660728261709f64,
        5.653470513060032f64,
        3.848625533572696f64,
        6.183177941040311f64,
        1.3144074596769295f64,
        0.6171484235051949f64,
        2.4890140462691135f64,
        3.104068074671915f64,
        11.306941026120064f64,
        6.20813614934383f64,
        9.312204224015744f64,
        12.41627229868766f64,
        15.520340373359575f64,
        18.624408448031488f64,
        21.728476522703406f64,
        24.83254459737532f64,
        27.936612672047236f64,
    ],
    theta1: [
        0.9130864514733535f64,
        1092.6913034790819f64,
        961.0515899766616f64,
        812.7038395448996f64,
        455.6949957202075f64,
        250.02539666519567f64,
        49.29857005183183f64,
        0.9130864514733535f64,
        2185.3826069581637f64,
        1.826172902946707f64,
        2.7392593544200605f64,
        3.652345805893414f64,
        4.565432257366767f64,
        5.478518708840121f64,
        6.391605160313474f64,
        7.304691611786828f64,
        8.21777806326018f64,
    ],
};
impl RotationalElements for Larissa {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_LARISSA.angle(t),
            DECLINATION_LARISSA.angle(t),
            ROTATION_LARISSA.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_LARISSA.angle_dot(t),
            DECLINATION_LARISSA.angle_dot(t),
            ROTATION_LARISSA.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Proteus;
impl Origin for Proteus {
    fn id(&self) -> NaifId {
        NaifId(808i32)
    }
    fn name(&self) -> &'static str {
        "Proteus"
    }
}
impl Display for Proteus {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for Proteus {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(2.583422379120727f64)
    }
}
impl MeanRadius for Proteus {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(208f64)
    }
}
impl TriaxialEllipsoid for Proteus {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(218f64),
            Distance::kilometers(208f64),
            Distance::kilometers(201f64),
        )
    }
}
const RIGHT_ASCENSION_PROTEUS: RotationalElement<17usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 5.22324685244343f64,
    c1: 0f64,
    c2: 0f64,
    c: [
        0.012217304763960306f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        -0.0008726646259971648f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
    ],
    theta0: [
        6.245660728261709f64,
        5.653470513060032f64,
        3.848625533572696f64,
        6.183177941040311f64,
        1.3144074596769295f64,
        0.6171484235051949f64,
        2.4890140462691135f64,
        3.104068074671915f64,
        11.306941026120064f64,
        6.20813614934383f64,
        9.312204224015744f64,
        12.41627229868766f64,
        15.520340373359575f64,
        18.624408448031488f64,
        21.728476522703406f64,
        24.83254459737532f64,
        27.936612672047236f64,
    ],
    theta1: [
        0.9130864514733535f64,
        1092.6913034790819f64,
        961.0515899766616f64,
        812.7038395448996f64,
        455.6949957202075f64,
        250.02539666519567f64,
        49.29857005183183f64,
        0.9130864514733535f64,
        2185.3826069581637f64,
        1.826172902946707f64,
        2.7392593544200605f64,
        3.652345805893414f64,
        4.565432257366767f64,
        5.478518708840121f64,
        6.391605160313474f64,
        7.304691611786828f64,
        8.21777806326018f64,
    ],
};
const DECLINATION_PROTEUS: RotationalElement<17usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: 0.7489207820307667f64,
    c1: 0f64,
    c2: 0f64,
    c: [
        -0.00890117918517108f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        -0.0006981317007977319f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
    ],
    theta0: [
        6.245660728261709f64,
        5.653470513060032f64,
        3.848625533572696f64,
        6.183177941040311f64,
        1.3144074596769295f64,
        0.6171484235051949f64,
        2.4890140462691135f64,
        3.104068074671915f64,
        11.306941026120064f64,
        6.20813614934383f64,
        9.312204224015744f64,
        12.41627229868766f64,
        15.520340373359575f64,
        18.624408448031488f64,
        21.728476522703406f64,
        24.83254459737532f64,
        27.936612672047236f64,
    ],
    theta1: [
        0.9130864514733535f64,
        1092.6913034790819f64,
        961.0515899766616f64,
        812.7038395448996f64,
        455.6949957202075f64,
        250.02539666519567f64,
        49.29857005183183f64,
        0.9130864514733535f64,
        2185.3826069581637f64,
        1.826172902946707f64,
        2.7392593544200605f64,
        3.652345805893414f64,
        4.565432257366767f64,
        5.478518708840121f64,
        6.391605160313474f64,
        7.304691611786828f64,
        8.21777806326018f64,
    ],
};
const ROTATION_PROTEUS: RotationalElement<17usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 1.6297884555123048f64,
    c1: 5.598412754411688f64,
    c2: 0f64,
    c: [
        -0.008377580409572781f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0.0006981317007977319f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
        0f64,
    ],
    theta0: [
        6.245660728261709f64,
        5.653470513060032f64,
        3.848625533572696f64,
        6.183177941040311f64,
        1.3144074596769295f64,
        0.6171484235051949f64,
        2.4890140462691135f64,
        3.104068074671915f64,
        11.306941026120064f64,
        6.20813614934383f64,
        9.312204224015744f64,
        12.41627229868766f64,
        15.520340373359575f64,
        18.624408448031488f64,
        21.728476522703406f64,
        24.83254459737532f64,
        27.936612672047236f64,
    ],
    theta1: [
        0.9130864514733535f64,
        1092.6913034790819f64,
        961.0515899766616f64,
        812.7038395448996f64,
        455.6949957202075f64,
        250.02539666519567f64,
        49.29857005183183f64,
        0.9130864514733535f64,
        2185.3826069581637f64,
        1.826172902946707f64,
        2.7392593544200605f64,
        3.652345805893414f64,
        4.565432257366767f64,
        5.478518708840121f64,
        6.391605160313474f64,
        7.304691611786828f64,
        8.21777806326018f64,
    ],
};
impl RotationalElements for Proteus {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_PROTEUS.angle(t),
            DECLINATION_PROTEUS.angle(t),
            ROTATION_PROTEUS.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_PROTEUS.angle_dot(t),
            DECLINATION_PROTEUS.angle_dot(t),
            ROTATION_PROTEUS.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Halimede;
impl Origin for Halimede {
    fn id(&self) -> NaifId {
        NaifId(809i32)
    }
    fn name(&self) -> &'static str {
        "Halimede"
    }
}
impl Display for Halimede {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Psamathe;
impl Origin for Psamathe {
    fn id(&self) -> NaifId {
        NaifId(810i32)
    }
    fn name(&self) -> &'static str {
        "Psamathe"
    }
}
impl Display for Psamathe {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Sao;
impl Origin for Sao {
    fn id(&self) -> NaifId {
        NaifId(811i32)
    }
    fn name(&self) -> &'static str {
        "Sao"
    }
}
impl Display for Sao {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Laomedeia;
impl Origin for Laomedeia {
    fn id(&self) -> NaifId {
        NaifId(812i32)
    }
    fn name(&self) -> &'static str {
        "Laomedeia"
    }
}
impl Display for Laomedeia {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Neso;
impl Origin for Neso {
    fn id(&self) -> NaifId {
        NaifId(813i32)
    }
    fn name(&self) -> &'static str {
        "Neso"
    }
}
impl Display for Neso {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Charon;
impl Origin for Charon {
    fn id(&self) -> NaifId {
        NaifId(901i32)
    }
    fn name(&self) -> &'static str {
        "Charon"
    }
}
impl Display for Charon {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for Charon {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(105.8799888601881f64)
    }
}
impl MeanRadius for Charon {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(606f64)
    }
}
impl TriaxialEllipsoid for Charon {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(606f64),
            Distance::kilometers(606f64),
            Distance::kilometers(606f64),
        )
    }
}
impl Spheroid for Charon {}
const RIGHT_ASCENSION_CHARON: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 2.3211657321048187f64,
    c1: 0f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
const DECLINATION_CHARON: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: -0.10756464180041053f64,
    c1: 0f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
const ROTATION_CHARON: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 2.1414317257344426f64,
    c1: 0.9837115923543857f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
impl RotationalElements for Charon {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_CHARON.angle(t),
            DECLINATION_CHARON.angle(t),
            ROTATION_CHARON.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_CHARON.angle_dot(t),
            DECLINATION_CHARON.angle_dot(t),
            ROTATION_CHARON.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Nix;
impl Origin for Nix {
    fn id(&self) -> NaifId {
        NaifId(902i32)
    }
    fn name(&self) -> &'static str {
        "Nix"
    }
}
impl Display for Nix {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for Nix {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(0.00304817564816976f64)
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Hydra;
impl Origin for Hydra {
    fn id(&self) -> NaifId {
        NaifId(903i32)
    }
    fn name(&self) -> &'static str {
        "Hydra"
    }
}
impl Display for Hydra {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for Hydra {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(0.003211039206155255f64)
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Kerberos;
impl Origin for Kerberos {
    fn id(&self) -> NaifId {
        NaifId(904i32)
    }
    fn name(&self) -> &'static str {
        "Kerberos"
    }
}
impl Display for Kerberos {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for Kerberos {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(0.001110040850536676f64)
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Styx;
impl Origin for Styx {
    fn id(&self) -> NaifId {
        NaifId(905i32)
    }
    fn name(&self) -> &'static str {
        "Styx"
    }
}
impl Display for Styx {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for Styx {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(0f64)
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Gaspra;
impl Origin for Gaspra {
    fn id(&self) -> NaifId {
        NaifId(9511010i32)
    }
    fn name(&self) -> &'static str {
        "Gaspra"
    }
}
impl Display for Gaspra {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl MeanRadius for Gaspra {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(6.1f64)
    }
}
impl TriaxialEllipsoid for Gaspra {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(9.1f64),
            Distance::kilometers(5.2f64),
            Distance::kilometers(4.4f64),
        )
    }
}
const RIGHT_ASCENSION_GASPRA: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 0.16528268016386302f64,
    c1: 0f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
const DECLINATION_GASPRA: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: 0.46600291028248597f64,
    c1: 0f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
const ROTATION_GASPRA: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 1.4603169851436555f64,
    c1: 21.41364504378302f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
impl RotationalElements for Gaspra {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_GASPRA.angle(t),
            DECLINATION_GASPRA.angle(t),
            ROTATION_GASPRA.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_GASPRA.angle_dot(t),
            DECLINATION_GASPRA.angle_dot(t),
            ROTATION_GASPRA.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Ida;
impl Origin for Ida {
    fn id(&self) -> NaifId {
        NaifId(2431010i32)
    }
    fn name(&self) -> &'static str {
        "Ida"
    }
}
impl Display for Ida {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl MeanRadius for Ida {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(15.65f64)
    }
}
impl TriaxialEllipsoid for Ida {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(26.8f64),
            Distance::kilometers(12f64),
            Distance::kilometers(7.6f64),
        )
    }
}
const RIGHT_ASCENSION_IDA: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 2.9454176456656302f64,
    c1: 0f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
const DECLINATION_IDA: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: -1.5205308443374599f64,
    c1: 0f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
const ROTATION_IDA: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 4.78307481509046f64,
    c1: 32.54389804704987f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
impl RotationalElements for Ida {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_IDA.angle(t),
            DECLINATION_IDA.angle(t),
            ROTATION_IDA.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_IDA.angle_dot(t),
            DECLINATION_IDA.angle_dot(t),
            ROTATION_IDA.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Dactyl;
impl Origin for Dactyl {
    fn id(&self) -> NaifId {
        NaifId(2431011i32)
    }
    fn name(&self) -> &'static str {
        "Dactyl"
    }
}
impl Display for Dactyl {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Ceres;
impl Origin for Ceres {
    fn id(&self) -> NaifId {
        NaifId(2000001i32)
    }
    fn name(&self) -> &'static str {
        "Ceres"
    }
}
impl Display for Ceres {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for Ceres {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(62.62888864440993f64)
    }
}
impl MeanRadius for Ceres {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(470f64)
    }
}
impl TriaxialEllipsoid for Ceres {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(487.3f64),
            Distance::kilometers(487.3f64),
            Distance::kilometers(446f64),
        )
    }
}
impl Spheroid for Ceres {}
const RIGHT_ASCENSION_CERES: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 5.0862035995768355f64,
    c1: 0f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
const DECLINATION_CERES: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: 1.165251621801494f64,
    c1: 0f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
const ROTATION_CERES: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 2.9784043685283237f64,
    c1: 16.618208323400072f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
impl RotationalElements for Ceres {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_CERES.angle(t),
            DECLINATION_CERES.angle(t),
            ROTATION_CERES.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_CERES.angle_dot(t),
            DECLINATION_CERES.angle_dot(t),
            ROTATION_CERES.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Pallas;
impl Origin for Pallas {
    fn id(&self) -> NaifId {
        NaifId(2000002i32)
    }
    fn name(&self) -> &'static str {
        "Pallas"
    }
}
impl Display for Pallas {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for Pallas {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(13.665878145967422f64)
    }
}
const RIGHT_ASCENSION_PALLAS: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 0.5759586531581288f64,
    c1: 0f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
const DECLINATION_PALLAS: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: -0.05235987755982989f64,
    c1: 0f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
const ROTATION_PALLAS: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 0.6632251157578453f64,
    c1: 19.299913700406368f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
impl RotationalElements for Pallas {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_PALLAS.angle(t),
            DECLINATION_PALLAS.angle(t),
            ROTATION_PALLAS.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_PALLAS.angle_dot(t),
            DECLINATION_PALLAS.angle_dot(t),
            ROTATION_PALLAS.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Vesta;
impl Origin for Vesta {
    fn id(&self) -> NaifId {
        NaifId(2000004i32)
    }
    fn name(&self) -> &'static str {
        "Vesta"
    }
}
impl Display for Vesta {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for Vesta {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(17.288232879171513f64)
    }
}
impl TriaxialEllipsoid for Vesta {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(289f64),
            Distance::kilometers(280f64),
            Distance::kilometers(229f64),
        )
    }
}
const RIGHT_ASCENSION_VESTA: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 5.393608440730596f64,
    c1: 0f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
const DECLINATION_VESTA: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: 0.7371398095798051f64,
    c1: 0f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
const ROTATION_VESTA: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 4.980995152266617f64,
    c1: 28.22778495282912f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
impl RotationalElements for Vesta {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_VESTA.angle(t),
            DECLINATION_VESTA.angle(t),
            ROTATION_VESTA.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_VESTA.angle_dot(t),
            DECLINATION_VESTA.angle_dot(t),
            ROTATION_VESTA.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Psyche;
impl Origin for Psyche {
    fn id(&self) -> NaifId {
        NaifId(2000016i32)
    }
    fn name(&self) -> &'static str {
        "Psyche"
    }
}
impl Display for Psyche {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for Psyche {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(1.5896582441709424f64)
    }
}
impl MeanRadius for Psyche {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(113f64)
    }
}
impl TriaxialEllipsoid for Psyche {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(139.5f64),
            Distance::kilometers(116f64),
            Distance::kilometers(94.5f64),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Lutetia;
impl Origin for Lutetia {
    fn id(&self) -> NaifId {
        NaifId(2000021i32)
    }
    fn name(&self) -> &'static str {
        "Lutetia"
    }
}
impl Display for Lutetia {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl MeanRadius for Lutetia {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(52.5f64)
    }
}
impl TriaxialEllipsoid for Lutetia {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(62f64),
            Distance::kilometers(50.5f64),
            Distance::kilometers(46.5f64),
        )
    }
}
const RIGHT_ASCENSION_LUTETIA: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 0.9075712110370514f64,
    c1: 0f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
const DECLINATION_LUTETIA: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: 0.20943951023931956f64,
    c1: 0f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
const ROTATION_LUTETIA: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 1.6406094968746698f64,
    c1: 18.4612463429088f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
impl RotationalElements for Lutetia {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_LUTETIA.angle(t),
            DECLINATION_LUTETIA.angle(t),
            ROTATION_LUTETIA.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_LUTETIA.angle_dot(t),
            DECLINATION_LUTETIA.angle_dot(t),
            ROTATION_LUTETIA.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Kleopatra;
impl Origin for Kleopatra {
    fn id(&self) -> NaifId {
        NaifId(2000216i32)
    }
    fn name(&self) -> &'static str {
        "Kleopatra"
    }
}
impl Display for Kleopatra {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Eros;
impl Origin for Eros {
    fn id(&self) -> NaifId {
        NaifId(2000433i32)
    }
    fn name(&self) -> &'static str {
        "Eros"
    }
}
impl Display for Eros {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for Eros {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(0.0004463f64)
    }
}
impl MeanRadius for Eros {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(8.45f64)
    }
}
impl TriaxialEllipsoid for Eros {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(17f64),
            Distance::kilometers(5.5f64),
            Distance::kilometers(5.5f64),
        )
    }
}
const RIGHT_ASCENSION_EROS: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 0.1980948701013564f64,
    c1: 0f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
const DECLINATION_EROS: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: 0.30054569719342356f64,
    c1: 0f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
const ROTATION_EROS: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 5.690995091977911f64,
    c1: 28.612729617819042f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
impl RotationalElements for Eros {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_EROS.angle(t),
            DECLINATION_EROS.angle(t),
            ROTATION_EROS.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_EROS.angle_dot(t),
            DECLINATION_EROS.angle_dot(t),
            ROTATION_EROS.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Davida;
impl Origin for Davida {
    fn id(&self) -> NaifId {
        NaifId(2000511i32)
    }
    fn name(&self) -> &'static str {
        "Davida"
    }
}
impl Display for Davida {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl PointMass for Davida {
    fn gravitational_parameter(&self) -> GravitationalParameter {
        GravitationalParameter::km3_per_s2(3.8944831481705644f64)
    }
}
impl MeanRadius for Davida {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(150f64)
    }
}
impl TriaxialEllipsoid for Davida {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(180f64),
            Distance::kilometers(147f64),
            Distance::kilometers(127f64),
        )
    }
}
const RIGHT_ASCENSION_DAVIDA: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 5.183627878423159f64,
    c1: 0f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
const DECLINATION_DAVIDA: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: 0.08726646259971647f64,
    c1: 0f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
const ROTATION_DAVIDA: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 4.679227724596798f64,
    c1: 29.39866372732388f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
impl RotationalElements for Davida {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_DAVIDA.angle(t),
            DECLINATION_DAVIDA.angle(t),
            ROTATION_DAVIDA.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_DAVIDA.angle_dot(t),
            DECLINATION_DAVIDA.angle_dot(t),
            ROTATION_DAVIDA.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Mathilde;
impl Origin for Mathilde {
    fn id(&self) -> NaifId {
        NaifId(2000253i32)
    }
    fn name(&self) -> &'static str {
        "Mathilde"
    }
}
impl Display for Mathilde {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl MeanRadius for Mathilde {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(26.5f64)
    }
}
impl TriaxialEllipsoid for Mathilde {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(33f64),
            Distance::kilometers(24f64),
            Distance::kilometers(23f64),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Steins;
impl Origin for Steins {
    fn id(&self) -> NaifId {
        NaifId(2002867i32)
    }
    fn name(&self) -> &'static str {
        "Steins"
    }
}
impl Display for Steins {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl MeanRadius for Steins {
    fn mean_radius(&self) -> Distance {
        Distance::kilometers(2.7f64)
    }
}
impl TriaxialEllipsoid for Steins {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(3.24f64),
            Distance::kilometers(2.73f64),
            Distance::kilometers(2.04f64),
        )
    }
}
const RIGHT_ASCENSION_STEINS: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 1.5882496193148399f64,
    c1: 0f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
const DECLINATION_STEINS: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: -1.0821041362364843f64,
    c1: 0f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
const ROTATION_STEINS: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 5.615771401216954f64,
    c1: 24.925032561498227f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
impl RotationalElements for Steins {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_STEINS.angle(t),
            DECLINATION_STEINS.angle(t),
            ROTATION_STEINS.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_STEINS.angle_dot(t),
            DECLINATION_STEINS.angle_dot(t),
            ROTATION_STEINS.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Braille;
impl Origin for Braille {
    fn id(&self) -> NaifId {
        NaifId(2009969i32)
    }
    fn name(&self) -> &'static str {
        "Braille"
    }
}
impl Display for Braille {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct WilsonHarrington;
impl Origin for WilsonHarrington {
    fn id(&self) -> NaifId {
        NaifId(2004015i32)
    }
    fn name(&self) -> &'static str {
        "Wilson-Harrington"
    }
}
impl Display for WilsonHarrington {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Toutatis;
impl Origin for Toutatis {
    fn id(&self) -> NaifId {
        NaifId(2004179i32)
    }
    fn name(&self) -> &'static str {
        "Toutatis"
    }
}
impl Display for Toutatis {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl TriaxialEllipsoid for Toutatis {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(2.13f64),
            Distance::kilometers(1.015f64),
            Distance::kilometers(0.85f64),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Itokawa;
impl Origin for Itokawa {
    fn id(&self) -> NaifId {
        NaifId(2025143i32)
    }
    fn name(&self) -> &'static str {
        "Itokawa"
    }
}
impl Display for Itokawa {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl TriaxialEllipsoid for Itokawa {
    fn radii(&self) -> Radii {
        (
            Distance::kilometers(0.268f64),
            Distance::kilometers(0.147f64),
            Distance::kilometers(0.104f64),
        )
    }
}
const RIGHT_ASCENSION_ITOKAWA: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::RightAscension,
    c0: 1.5800465718304666f64,
    c1: 0f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
const DECLINATION_ITOKAWA: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::Declination,
    c0: -1.1571532940722404f64,
    c1: 0f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
const ROTATION_ITOKAWA: RotationalElement<0usize> = RotationalElement {
    typ: RotationalElementType::Rotation,
    c0: 0f64,
    c1: 12.429240095029979f64,
    c2: 0f64,
    c: [],
    theta0: [],
    theta1: [],
};
impl RotationalElements for Itokawa {
    fn rotational_elements(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_ITOKAWA.angle(t),
            DECLINATION_ITOKAWA.angle(t),
            ROTATION_ITOKAWA.angle(t),
        )
    }
    fn rotational_element_rates(&self, t: f64) -> Elements {
        (
            RIGHT_ASCENSION_ITOKAWA.angle_dot(t),
            DECLINATION_ITOKAWA.angle_dot(t),
            ROTATION_ITOKAWA.angle_dot(t),
        )
    }
}
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Bennu;
impl Origin for Bennu {
    fn id(&self) -> NaifId {
        NaifId(2101955i32)
    }
    fn name(&self) -> &'static str {
        "Bennu"
    }
}
impl Display for Bennu {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name())
    }
}
impl TryPointMass for DynOrigin {
    fn try_gravitational_parameter(
        &self,
    ) -> Result<GravitationalParameter, UndefinedOriginPropertyError> {
        match self {
            DynOrigin::Sun => Ok(GravitationalParameter::km3_per_s2(132712440041.27942f64)),
            DynOrigin::Mercury => Ok(GravitationalParameter::km3_per_s2(22031.868551400003f64)),
            DynOrigin::Venus => Ok(GravitationalParameter::km3_per_s2(324858.592f64)),
            DynOrigin::Earth => Ok(GravitationalParameter::km3_per_s2(398600.43550702266f64)),
            DynOrigin::Mars => Ok(GravitationalParameter::km3_per_s2(42828.37362069909f64)),
            DynOrigin::Jupiter => Ok(GravitationalParameter::km3_per_s2(126686531.9003704f64)),
            DynOrigin::Saturn => Ok(GravitationalParameter::km3_per_s2(37931206.23436167f64)),
            DynOrigin::Uranus => Ok(GravitationalParameter::km3_per_s2(5793951.256527211f64)),
            DynOrigin::Neptune => Ok(GravitationalParameter::km3_per_s2(6835103.145462294f64)),
            DynOrigin::Pluto => Ok(GravitationalParameter::km3_per_s2(869.6138177608748f64)),
            DynOrigin::SolarSystemBarycenter => {
                Ok(GravitationalParameter::km3_per_s2(132712440041.27942f64))
            }
            DynOrigin::MercuryBarycenter => {
                Ok(GravitationalParameter::km3_per_s2(22031.868551400003f64))
            }
            DynOrigin::VenusBarycenter => Ok(GravitationalParameter::km3_per_s2(324858.592f64)),
            DynOrigin::EarthBarycenter => {
                Ok(GravitationalParameter::km3_per_s2(403503.2356254802f64))
            }
            DynOrigin::MarsBarycenter => {
                Ok(GravitationalParameter::km3_per_s2(42828.3758157561f64))
            }
            DynOrigin::JupiterBarycenter => {
                Ok(GravitationalParameter::km3_per_s2(126712764.09999998f64))
            }
            DynOrigin::SaturnBarycenter => Ok(GravitationalParameter::km3_per_s2(37940584.8418f64)),
            DynOrigin::UranusBarycenter => {
                Ok(GravitationalParameter::km3_per_s2(5794556.3999999985f64))
            }
            DynOrigin::NeptuneBarycenter => {
                Ok(GravitationalParameter::km3_per_s2(6836527.100580399f64))
            }
            DynOrigin::PlutoBarycenter => Ok(GravitationalParameter::km3_per_s2(975.5f64)),
            DynOrigin::Moon => Ok(GravitationalParameter::km3_per_s2(4902.80011845755f64)),
            DynOrigin::Phobos => Ok(GravitationalParameter::km3_per_s2(0.0007087546066894452f64)),
            DynOrigin::Deimos => Ok(GravitationalParameter::km3_per_s2(
                0.00009615569648120313f64,
            )),
            DynOrigin::Io => Ok(GravitationalParameter::km3_per_s2(5959.915466180539f64)),
            DynOrigin::Europa => Ok(GravitationalParameter::km3_per_s2(3202.712099607295f64)),
            DynOrigin::Ganymede => Ok(GravitationalParameter::km3_per_s2(9887.832752719638f64)),
            DynOrigin::Callisto => Ok(GravitationalParameter::km3_per_s2(7179.283402579837f64)),
            DynOrigin::Amalthea => Ok(GravitationalParameter::km3_per_s2(0.1645634534798259f64)),
            DynOrigin::Himalia => Ok(GravitationalParameter::km3_per_s2(0.1515524299611265f64)),
            DynOrigin::Thebe => Ok(GravitationalParameter::km3_per_s2(0.030148f64)),
            DynOrigin::Adrastea => Ok(GravitationalParameter::km3_per_s2(0.000139f64)),
            DynOrigin::Metis => Ok(GravitationalParameter::km3_per_s2(0.002501f64)),
            DynOrigin::Mimas => Ok(GravitationalParameter::km3_per_s2(2.503488768152587f64)),
            DynOrigin::Enceladus => Ok(GravitationalParameter::km3_per_s2(7.210366688598896f64)),
            DynOrigin::Tethys => Ok(GravitationalParameter::km3_per_s2(41.21352885489587f64)),
            DynOrigin::Dione => Ok(GravitationalParameter::km3_per_s2(73.11607172482067f64)),
            DynOrigin::Rhea => Ok(GravitationalParameter::km3_per_s2(153.9417519146563f64)),
            DynOrigin::Titan => Ok(GravitationalParameter::km3_per_s2(8978.137095521046f64)),
            DynOrigin::Hyperion => Ok(GravitationalParameter::km3_per_s2(0.3704913747932265f64)),
            DynOrigin::Iapetus => Ok(GravitationalParameter::km3_per_s2(120.5151060137642f64)),
            DynOrigin::Phoebe => Ok(GravitationalParameter::km3_per_s2(0.5547860052791678f64)),
            DynOrigin::Janus => Ok(GravitationalParameter::km3_per_s2(0.1265765099012197f64)),
            DynOrigin::Epimetheus => Ok(GravitationalParameter::km3_per_s2(0.03512333288208074f64)),
            DynOrigin::Helene => Ok(GravitationalParameter::km3_per_s2(0.0004757419551776972f64)),
            DynOrigin::Atlas => Ok(GravitationalParameter::km3_per_s2(0.0003718871247516475f64)),
            DynOrigin::Prometheus => Ok(GravitationalParameter::km3_per_s2(0.0107520800100761f64)),
            DynOrigin::Pandora => Ok(GravitationalParameter::km3_per_s2(0.009290325122028795f64)),
            DynOrigin::Ariel => Ok(GravitationalParameter::km3_per_s2(83.46344431770477f64)),
            DynOrigin::Umbriel => Ok(GravitationalParameter::km3_per_s2(85.09338094489388f64)),
            DynOrigin::Titania => Ok(GravitationalParameter::km3_per_s2(226.9437003741248f64)),
            DynOrigin::Oberon => Ok(GravitationalParameter::km3_per_s2(205.3234302535623f64)),
            DynOrigin::Miranda => Ok(GravitationalParameter::km3_per_s2(4.3195168992321f64)),
            DynOrigin::Triton => Ok(GravitationalParameter::km3_per_s2(1428.495462910464f64)),
            DynOrigin::Naiad => Ok(GravitationalParameter::km3_per_s2(0.008530281246540886f64)),
            DynOrigin::Thalassa => Ok(GravitationalParameter::km3_per_s2(0.0235887319799217f64)),
            DynOrigin::Despina => Ok(GravitationalParameter::km3_per_s2(0.1167318403814998f64)),
            DynOrigin::Galatea => Ok(GravitationalParameter::km3_per_s2(0.189898503906069f64)),
            DynOrigin::Larissa => Ok(GravitationalParameter::km3_per_s2(0.2548437405693583f64)),
            DynOrigin::Proteus => Ok(GravitationalParameter::km3_per_s2(2.583422379120727f64)),
            DynOrigin::Charon => Ok(GravitationalParameter::km3_per_s2(105.8799888601881f64)),
            DynOrigin::Nix => Ok(GravitationalParameter::km3_per_s2(0.00304817564816976f64)),
            DynOrigin::Hydra => Ok(GravitationalParameter::km3_per_s2(0.003211039206155255f64)),
            DynOrigin::Kerberos => Ok(GravitationalParameter::km3_per_s2(0.001110040850536676f64)),
            DynOrigin::Styx => Ok(GravitationalParameter::km3_per_s2(0f64)),
            DynOrigin::Ceres => Ok(GravitationalParameter::km3_per_s2(62.62888864440993f64)),
            DynOrigin::Pallas => Ok(GravitationalParameter::km3_per_s2(13.665878145967422f64)),
            DynOrigin::Vesta => Ok(GravitationalParameter::km3_per_s2(17.288232879171513f64)),
            DynOrigin::Psyche => Ok(GravitationalParameter::km3_per_s2(1.5896582441709424f64)),
            DynOrigin::Eros => Ok(GravitationalParameter::km3_per_s2(0.0004463f64)),
            DynOrigin::Davida => Ok(GravitationalParameter::km3_per_s2(3.8944831481705644f64)),
            _ => Err(UndefinedOriginPropertyError {
                origin: self.to_string(),
                prop: "gravitational parameter".to_string(),
            }),
        }
    }
}
impl TryMeanRadius for DynOrigin {
    fn try_mean_radius(&self) -> Result<Distance, UndefinedOriginPropertyError> {
        match self {
            DynOrigin::Mercury => Ok(Distance::kilometers(2439.4f64)),
            DynOrigin::Venus => Ok(Distance::kilometers(6051.8f64)),
            DynOrigin::Earth => Ok(Distance::kilometers(6371.0084f64)),
            DynOrigin::Mars => Ok(Distance::kilometers(3389.5f64)),
            DynOrigin::Jupiter => Ok(Distance::kilometers(69911f64)),
            DynOrigin::Saturn => Ok(Distance::kilometers(58232f64)),
            DynOrigin::Uranus => Ok(Distance::kilometers(25362f64)),
            DynOrigin::Neptune => Ok(Distance::kilometers(24622f64)),
            DynOrigin::Pluto => Ok(Distance::kilometers(1188.3f64)),
            DynOrigin::Moon => Ok(Distance::kilometers(1737.4f64)),
            DynOrigin::Phobos => Ok(Distance::kilometers(11.08f64)),
            DynOrigin::Deimos => Ok(Distance::kilometers(6.2f64)),
            DynOrigin::Io => Ok(Distance::kilometers(1821.49f64)),
            DynOrigin::Europa => Ok(Distance::kilometers(1560.8f64)),
            DynOrigin::Ganymede => Ok(Distance::kilometers(2631.2f64)),
            DynOrigin::Callisto => Ok(Distance::kilometers(2410.3f64)),
            DynOrigin::Amalthea => Ok(Distance::kilometers(83.5f64)),
            DynOrigin::Himalia => Ok(Distance::kilometers(85f64)),
            DynOrigin::Elara => Ok(Distance::kilometers(40f64)),
            DynOrigin::Pasiphae => Ok(Distance::kilometers(18f64)),
            DynOrigin::Sinope => Ok(Distance::kilometers(14f64)),
            DynOrigin::Lysithea => Ok(Distance::kilometers(12f64)),
            DynOrigin::Carme => Ok(Distance::kilometers(15f64)),
            DynOrigin::Ananke => Ok(Distance::kilometers(10f64)),
            DynOrigin::Leda => Ok(Distance::kilometers(5f64)),
            DynOrigin::Thebe => Ok(Distance::kilometers(49.3f64)),
            DynOrigin::Adrastea => Ok(Distance::kilometers(8.2f64)),
            DynOrigin::Metis => Ok(Distance::kilometers(21.5f64)),
            DynOrigin::Mimas => Ok(Distance::kilometers(198.2f64)),
            DynOrigin::Enceladus => Ok(Distance::kilometers(252.1f64)),
            DynOrigin::Tethys => Ok(Distance::kilometers(531f64)),
            DynOrigin::Dione => Ok(Distance::kilometers(561.4f64)),
            DynOrigin::Rhea => Ok(Distance::kilometers(763.5f64)),
            DynOrigin::Titan => Ok(Distance::kilometers(2575f64)),
            DynOrigin::Hyperion => Ok(Distance::kilometers(135f64)),
            DynOrigin::Iapetus => Ok(Distance::kilometers(734.3f64)),
            DynOrigin::Phoebe => Ok(Distance::kilometers(106.5f64)),
            DynOrigin::Janus => Ok(Distance::kilometers(89.2f64)),
            DynOrigin::Epimetheus => Ok(Distance::kilometers(58.2f64)),
            DynOrigin::Helene => Ok(Distance::kilometers(18f64)),
            DynOrigin::Telesto => Ok(Distance::kilometers(12.4f64)),
            DynOrigin::Calypso => Ok(Distance::kilometers(9.6f64)),
            DynOrigin::Atlas => Ok(Distance::kilometers(15.1f64)),
            DynOrigin::Prometheus => Ok(Distance::kilometers(43.1f64)),
            DynOrigin::Pandora => Ok(Distance::kilometers(40.6f64)),
            DynOrigin::Pan => Ok(Distance::kilometers(14f64)),
            DynOrigin::Methone => Ok(Distance::kilometers(1.45f64)),
            DynOrigin::Pallene => Ok(Distance::kilometers(2.23f64)),
            DynOrigin::Polydeuces => Ok(Distance::kilometers(1.3f64)),
            DynOrigin::Daphnis => Ok(Distance::kilometers(3.8f64)),
            DynOrigin::Anthe => Ok(Distance::kilometers(0.5f64)),
            DynOrigin::Aegaeon => Ok(Distance::kilometers(0.33f64)),
            DynOrigin::Ariel => Ok(Distance::kilometers(578.9f64)),
            DynOrigin::Umbriel => Ok(Distance::kilometers(584.7f64)),
            DynOrigin::Titania => Ok(Distance::kilometers(788.9f64)),
            DynOrigin::Oberon => Ok(Distance::kilometers(761.4f64)),
            DynOrigin::Miranda => Ok(Distance::kilometers(235.8f64)),
            DynOrigin::Cordelia => Ok(Distance::kilometers(13f64)),
            DynOrigin::Ophelia => Ok(Distance::kilometers(15f64)),
            DynOrigin::Bianca => Ok(Distance::kilometers(21f64)),
            DynOrigin::Cressida => Ok(Distance::kilometers(31f64)),
            DynOrigin::Desdemona => Ok(Distance::kilometers(27f64)),
            DynOrigin::Juliet => Ok(Distance::kilometers(42f64)),
            DynOrigin::Portia => Ok(Distance::kilometers(54f64)),
            DynOrigin::Rosalind => Ok(Distance::kilometers(27f64)),
            DynOrigin::Belinda => Ok(Distance::kilometers(33f64)),
            DynOrigin::Puck => Ok(Distance::kilometers(77f64)),
            DynOrigin::Triton => Ok(Distance::kilometers(1352.6f64)),
            DynOrigin::Nereid => Ok(Distance::kilometers(170f64)),
            DynOrigin::Naiad => Ok(Distance::kilometers(29f64)),
            DynOrigin::Thalassa => Ok(Distance::kilometers(40f64)),
            DynOrigin::Despina => Ok(Distance::kilometers(74f64)),
            DynOrigin::Galatea => Ok(Distance::kilometers(79f64)),
            DynOrigin::Larissa => Ok(Distance::kilometers(96f64)),
            DynOrigin::Proteus => Ok(Distance::kilometers(208f64)),
            DynOrigin::Charon => Ok(Distance::kilometers(606f64)),
            DynOrigin::Gaspra => Ok(Distance::kilometers(6.1f64)),
            DynOrigin::Ida => Ok(Distance::kilometers(15.65f64)),
            DynOrigin::Ceres => Ok(Distance::kilometers(470f64)),
            DynOrigin::Psyche => Ok(Distance::kilometers(113f64)),
            DynOrigin::Lutetia => Ok(Distance::kilometers(52.5f64)),
            DynOrigin::Eros => Ok(Distance::kilometers(8.45f64)),
            DynOrigin::Davida => Ok(Distance::kilometers(150f64)),
            DynOrigin::Mathilde => Ok(Distance::kilometers(26.5f64)),
            DynOrigin::Steins => Ok(Distance::kilometers(2.7f64)),
            _ => Err(UndefinedOriginPropertyError {
                origin: self.to_string(),
                prop: "mean radius".to_string(),
            }),
        }
    }
}
impl TryTriaxialEllipsoid for DynOrigin {
    fn try_radii(&self) -> Result<Radii, UndefinedOriginPropertyError> {
        match self {
            DynOrigin::Sun => Ok((
                Distance::kilometers(695700f64),
                Distance::kilometers(695700f64),
                Distance::kilometers(695700f64),
            )),
            DynOrigin::Mercury => Ok((
                Distance::kilometers(2440.53f64),
                Distance::kilometers(2440.53f64),
                Distance::kilometers(2438.26f64),
            )),
            DynOrigin::Venus => Ok((
                Distance::kilometers(6051.8f64),
                Distance::kilometers(6051.8f64),
                Distance::kilometers(6051.8f64),
            )),
            DynOrigin::Earth => Ok((
                Distance::kilometers(6378.1366f64),
                Distance::kilometers(6378.1366f64),
                Distance::kilometers(6356.7519f64),
            )),
            DynOrigin::Mars => Ok((
                Distance::kilometers(3396.19f64),
                Distance::kilometers(3396.19f64),
                Distance::kilometers(3376.2f64),
            )),
            DynOrigin::Jupiter => Ok((
                Distance::kilometers(71492f64),
                Distance::kilometers(71492f64),
                Distance::kilometers(66854f64),
            )),
            DynOrigin::Saturn => Ok((
                Distance::kilometers(60268f64),
                Distance::kilometers(60268f64),
                Distance::kilometers(54364f64),
            )),
            DynOrigin::Uranus => Ok((
                Distance::kilometers(25559f64),
                Distance::kilometers(25559f64),
                Distance::kilometers(24973f64),
            )),
            DynOrigin::Neptune => Ok((
                Distance::kilometers(24764f64),
                Distance::kilometers(24764f64),
                Distance::kilometers(24341f64),
            )),
            DynOrigin::Pluto => Ok((
                Distance::kilometers(1188.3f64),
                Distance::kilometers(1188.3f64),
                Distance::kilometers(1188.3f64),
            )),
            DynOrigin::Moon => Ok((
                Distance::kilometers(1737.4f64),
                Distance::kilometers(1737.4f64),
                Distance::kilometers(1737.4f64),
            )),
            DynOrigin::Phobos => Ok((
                Distance::kilometers(13f64),
                Distance::kilometers(11.4f64),
                Distance::kilometers(9.1f64),
            )),
            DynOrigin::Deimos => Ok((
                Distance::kilometers(7.8f64),
                Distance::kilometers(6f64),
                Distance::kilometers(5.1f64),
            )),
            DynOrigin::Io => Ok((
                Distance::kilometers(1829.4f64),
                Distance::kilometers(1819.4f64),
                Distance::kilometers(1815.7f64),
            )),
            DynOrigin::Europa => Ok((
                Distance::kilometers(1562.6f64),
                Distance::kilometers(1560.3f64),
                Distance::kilometers(1559.5f64),
            )),
            DynOrigin::Ganymede => Ok((
                Distance::kilometers(2631.2f64),
                Distance::kilometers(2631.2f64),
                Distance::kilometers(2631.2f64),
            )),
            DynOrigin::Callisto => Ok((
                Distance::kilometers(2410.3f64),
                Distance::kilometers(2410.3f64),
                Distance::kilometers(2410.3f64),
            )),
            DynOrigin::Amalthea => Ok((
                Distance::kilometers(125f64),
                Distance::kilometers(73f64),
                Distance::kilometers(64f64),
            )),
            DynOrigin::Himalia => Ok((
                Distance::kilometers(85f64),
                Distance::kilometers(85f64),
                Distance::kilometers(85f64),
            )),
            DynOrigin::Elara => Ok((
                Distance::kilometers(40f64),
                Distance::kilometers(40f64),
                Distance::kilometers(40f64),
            )),
            DynOrigin::Pasiphae => Ok((
                Distance::kilometers(18f64),
                Distance::kilometers(18f64),
                Distance::kilometers(18f64),
            )),
            DynOrigin::Sinope => Ok((
                Distance::kilometers(14f64),
                Distance::kilometers(14f64),
                Distance::kilometers(14f64),
            )),
            DynOrigin::Lysithea => Ok((
                Distance::kilometers(12f64),
                Distance::kilometers(12f64),
                Distance::kilometers(12f64),
            )),
            DynOrigin::Carme => Ok((
                Distance::kilometers(15f64),
                Distance::kilometers(15f64),
                Distance::kilometers(15f64),
            )),
            DynOrigin::Ananke => Ok((
                Distance::kilometers(10f64),
                Distance::kilometers(10f64),
                Distance::kilometers(10f64),
            )),
            DynOrigin::Leda => Ok((
                Distance::kilometers(5f64),
                Distance::kilometers(5f64),
                Distance::kilometers(5f64),
            )),
            DynOrigin::Thebe => Ok((
                Distance::kilometers(58f64),
                Distance::kilometers(49f64),
                Distance::kilometers(42f64),
            )),
            DynOrigin::Adrastea => Ok((
                Distance::kilometers(10f64),
                Distance::kilometers(8f64),
                Distance::kilometers(7f64),
            )),
            DynOrigin::Metis => Ok((
                Distance::kilometers(30f64),
                Distance::kilometers(20f64),
                Distance::kilometers(17f64),
            )),
            DynOrigin::Mimas => Ok((
                Distance::kilometers(207.8f64),
                Distance::kilometers(196.7f64),
                Distance::kilometers(190.6f64),
            )),
            DynOrigin::Enceladus => Ok((
                Distance::kilometers(256.6f64),
                Distance::kilometers(251.4f64),
                Distance::kilometers(248.3f64),
            )),
            DynOrigin::Tethys => Ok((
                Distance::kilometers(538.4f64),
                Distance::kilometers(528.3f64),
                Distance::kilometers(526.3f64),
            )),
            DynOrigin::Dione => Ok((
                Distance::kilometers(563.4f64),
                Distance::kilometers(561.3f64),
                Distance::kilometers(559.6f64),
            )),
            DynOrigin::Rhea => Ok((
                Distance::kilometers(765f64),
                Distance::kilometers(763.1f64),
                Distance::kilometers(762.4f64),
            )),
            DynOrigin::Titan => Ok((
                Distance::kilometers(2575.15f64),
                Distance::kilometers(2574.78f64),
                Distance::kilometers(2574.47f64),
            )),
            DynOrigin::Hyperion => Ok((
                Distance::kilometers(180.1f64),
                Distance::kilometers(133f64),
                Distance::kilometers(102.7f64),
            )),
            DynOrigin::Iapetus => Ok((
                Distance::kilometers(745.7f64),
                Distance::kilometers(745.7f64),
                Distance::kilometers(712.1f64),
            )),
            DynOrigin::Phoebe => Ok((
                Distance::kilometers(109.4f64),
                Distance::kilometers(108.5f64),
                Distance::kilometers(101.8f64),
            )),
            DynOrigin::Janus => Ok((
                Distance::kilometers(101.7f64),
                Distance::kilometers(93f64),
                Distance::kilometers(76.3f64),
            )),
            DynOrigin::Epimetheus => Ok((
                Distance::kilometers(64.9f64),
                Distance::kilometers(57.3f64),
                Distance::kilometers(53f64),
            )),
            DynOrigin::Helene => Ok((
                Distance::kilometers(22.5f64),
                Distance::kilometers(19.6f64),
                Distance::kilometers(13.3f64),
            )),
            DynOrigin::Telesto => Ok((
                Distance::kilometers(16.3f64),
                Distance::kilometers(11.8f64),
                Distance::kilometers(9.8f64),
            )),
            DynOrigin::Calypso => Ok((
                Distance::kilometers(15.3f64),
                Distance::kilometers(9.3f64),
                Distance::kilometers(6.3f64),
            )),
            DynOrigin::Atlas => Ok((
                Distance::kilometers(20.5f64),
                Distance::kilometers(17.8f64),
                Distance::kilometers(9.4f64),
            )),
            DynOrigin::Prometheus => Ok((
                Distance::kilometers(68.2f64),
                Distance::kilometers(41.6f64),
                Distance::kilometers(28.2f64),
            )),
            DynOrigin::Pandora => Ok((
                Distance::kilometers(52.2f64),
                Distance::kilometers(40.8f64),
                Distance::kilometers(31.5f64),
            )),
            DynOrigin::Pan => Ok((
                Distance::kilometers(17.2f64),
                Distance::kilometers(15.4f64),
                Distance::kilometers(10.4f64),
            )),
            DynOrigin::Methone => Ok((
                Distance::kilometers(1.94f64),
                Distance::kilometers(1.29f64),
                Distance::kilometers(1.21f64),
            )),
            DynOrigin::Pallene => Ok((
                Distance::kilometers(2.88f64),
                Distance::kilometers(2.08f64),
                Distance::kilometers(1.8f64),
            )),
            DynOrigin::Polydeuces => Ok((
                Distance::kilometers(1.5f64),
                Distance::kilometers(1.2f64),
                Distance::kilometers(1f64),
            )),
            DynOrigin::Daphnis => Ok((
                Distance::kilometers(4.6f64),
                Distance::kilometers(4.5f64),
                Distance::kilometers(2.8f64),
            )),
            DynOrigin::Anthe => Ok((
                Distance::kilometers(0.5f64),
                Distance::kilometers(0.5f64),
                Distance::kilometers(0.5f64),
            )),
            DynOrigin::Aegaeon => Ok((
                Distance::kilometers(0.7f64),
                Distance::kilometers(0.25f64),
                Distance::kilometers(0.2f64),
            )),
            DynOrigin::Ariel => Ok((
                Distance::kilometers(581.1f64),
                Distance::kilometers(577.9f64),
                Distance::kilometers(577.7f64),
            )),
            DynOrigin::Umbriel => Ok((
                Distance::kilometers(584.7f64),
                Distance::kilometers(584.7f64),
                Distance::kilometers(584.7f64),
            )),
            DynOrigin::Titania => Ok((
                Distance::kilometers(788.9f64),
                Distance::kilometers(788.9f64),
                Distance::kilometers(788.9f64),
            )),
            DynOrigin::Oberon => Ok((
                Distance::kilometers(761.4f64),
                Distance::kilometers(761.4f64),
                Distance::kilometers(761.4f64),
            )),
            DynOrigin::Miranda => Ok((
                Distance::kilometers(240.4f64),
                Distance::kilometers(234.2f64),
                Distance::kilometers(232.9f64),
            )),
            DynOrigin::Cordelia => Ok((
                Distance::kilometers(13f64),
                Distance::kilometers(13f64),
                Distance::kilometers(13f64),
            )),
            DynOrigin::Ophelia => Ok((
                Distance::kilometers(15f64),
                Distance::kilometers(15f64),
                Distance::kilometers(15f64),
            )),
            DynOrigin::Bianca => Ok((
                Distance::kilometers(21f64),
                Distance::kilometers(21f64),
                Distance::kilometers(21f64),
            )),
            DynOrigin::Cressida => Ok((
                Distance::kilometers(31f64),
                Distance::kilometers(31f64),
                Distance::kilometers(31f64),
            )),
            DynOrigin::Desdemona => Ok((
                Distance::kilometers(27f64),
                Distance::kilometers(27f64),
                Distance::kilometers(27f64),
            )),
            DynOrigin::Juliet => Ok((
                Distance::kilometers(42f64),
                Distance::kilometers(42f64),
                Distance::kilometers(42f64),
            )),
            DynOrigin::Portia => Ok((
                Distance::kilometers(54f64),
                Distance::kilometers(54f64),
                Distance::kilometers(54f64),
            )),
            DynOrigin::Rosalind => Ok((
                Distance::kilometers(27f64),
                Distance::kilometers(27f64),
                Distance::kilometers(27f64),
            )),
            DynOrigin::Belinda => Ok((
                Distance::kilometers(33f64),
                Distance::kilometers(33f64),
                Distance::kilometers(33f64),
            )),
            DynOrigin::Puck => Ok((
                Distance::kilometers(77f64),
                Distance::kilometers(77f64),
                Distance::kilometers(77f64),
            )),
            DynOrigin::Triton => Ok((
                Distance::kilometers(1352.6f64),
                Distance::kilometers(1352.6f64),
                Distance::kilometers(1352.6f64),
            )),
            DynOrigin::Nereid => Ok((
                Distance::kilometers(170f64),
                Distance::kilometers(170f64),
                Distance::kilometers(170f64),
            )),
            DynOrigin::Naiad => Ok((
                Distance::kilometers(29f64),
                Distance::kilometers(29f64),
                Distance::kilometers(29f64),
            )),
            DynOrigin::Thalassa => Ok((
                Distance::kilometers(40f64),
                Distance::kilometers(40f64),
                Distance::kilometers(40f64),
            )),
            DynOrigin::Despina => Ok((
                Distance::kilometers(74f64),
                Distance::kilometers(74f64),
                Distance::kilometers(74f64),
            )),
            DynOrigin::Galatea => Ok((
                Distance::kilometers(79f64),
                Distance::kilometers(79f64),
                Distance::kilometers(79f64),
            )),
            DynOrigin::Larissa => Ok((
                Distance::kilometers(96f64),
                Distance::kilometers(96f64),
                Distance::kilometers(96f64),
            )),
            DynOrigin::Proteus => Ok((
                Distance::kilometers(218f64),
                Distance::kilometers(208f64),
                Distance::kilometers(201f64),
            )),
            DynOrigin::Charon => Ok((
                Distance::kilometers(606f64),
                Distance::kilometers(606f64),
                Distance::kilometers(606f64),
            )),
            DynOrigin::Gaspra => Ok((
                Distance::kilometers(9.1f64),
                Distance::kilometers(5.2f64),
                Distance::kilometers(4.4f64),
            )),
            DynOrigin::Ida => Ok((
                Distance::kilometers(26.8f64),
                Distance::kilometers(12f64),
                Distance::kilometers(7.6f64),
            )),
            DynOrigin::Ceres => Ok((
                Distance::kilometers(487.3f64),
                Distance::kilometers(487.3f64),
                Distance::kilometers(446f64),
            )),
            DynOrigin::Vesta => Ok((
                Distance::kilometers(289f64),
                Distance::kilometers(280f64),
                Distance::kilometers(229f64),
            )),
            DynOrigin::Psyche => Ok((
                Distance::kilometers(139.5f64),
                Distance::kilometers(116f64),
                Distance::kilometers(94.5f64),
            )),
            DynOrigin::Lutetia => Ok((
                Distance::kilometers(62f64),
                Distance::kilometers(50.5f64),
                Distance::kilometers(46.5f64),
            )),
            DynOrigin::Eros => Ok((
                Distance::kilometers(17f64),
                Distance::kilometers(5.5f64),
                Distance::kilometers(5.5f64),
            )),
            DynOrigin::Davida => Ok((
                Distance::kilometers(180f64),
                Distance::kilometers(147f64),
                Distance::kilometers(127f64),
            )),
            DynOrigin::Mathilde => Ok((
                Distance::kilometers(33f64),
                Distance::kilometers(24f64),
                Distance::kilometers(23f64),
            )),
            DynOrigin::Steins => Ok((
                Distance::kilometers(3.24f64),
                Distance::kilometers(2.73f64),
                Distance::kilometers(2.04f64),
            )),
            DynOrigin::Toutatis => Ok((
                Distance::kilometers(2.13f64),
                Distance::kilometers(1.015f64),
                Distance::kilometers(0.85f64),
            )),
            DynOrigin::Itokawa => Ok((
                Distance::kilometers(0.268f64),
                Distance::kilometers(0.147f64),
                Distance::kilometers(0.104f64),
            )),
            _ => Err(UndefinedOriginPropertyError {
                origin: self.to_string(),
                prop: "radii".to_string(),
            }),
        }
    }
}
impl TrySpheroid for DynOrigin {
    fn try_polar_radius(&self) -> Result<Distance, UndefinedOriginPropertyError> {
        match self {
            DynOrigin::Sun => Ok(Distance::kilometers(695700f64)),
            DynOrigin::Mercury => Ok(Distance::kilometers(2438.26f64)),
            DynOrigin::Venus => Ok(Distance::kilometers(6051.8f64)),
            DynOrigin::Earth => Ok(Distance::kilometers(6356.7519f64)),
            DynOrigin::Mars => Ok(Distance::kilometers(3376.2f64)),
            DynOrigin::Jupiter => Ok(Distance::kilometers(66854f64)),
            DynOrigin::Saturn => Ok(Distance::kilometers(54364f64)),
            DynOrigin::Uranus => Ok(Distance::kilometers(24973f64)),
            DynOrigin::Neptune => Ok(Distance::kilometers(24341f64)),
            DynOrigin::Pluto => Ok(Distance::kilometers(1188.3f64)),
            DynOrigin::Moon => Ok(Distance::kilometers(1737.4f64)),
            DynOrigin::Ganymede => Ok(Distance::kilometers(2631.2f64)),
            DynOrigin::Callisto => Ok(Distance::kilometers(2410.3f64)),
            DynOrigin::Himalia => Ok(Distance::kilometers(85f64)),
            DynOrigin::Elara => Ok(Distance::kilometers(40f64)),
            DynOrigin::Pasiphae => Ok(Distance::kilometers(18f64)),
            DynOrigin::Sinope => Ok(Distance::kilometers(14f64)),
            DynOrigin::Lysithea => Ok(Distance::kilometers(12f64)),
            DynOrigin::Carme => Ok(Distance::kilometers(15f64)),
            DynOrigin::Ananke => Ok(Distance::kilometers(10f64)),
            DynOrigin::Leda => Ok(Distance::kilometers(5f64)),
            DynOrigin::Iapetus => Ok(Distance::kilometers(712.1f64)),
            DynOrigin::Anthe => Ok(Distance::kilometers(0.5f64)),
            DynOrigin::Umbriel => Ok(Distance::kilometers(584.7f64)),
            DynOrigin::Titania => Ok(Distance::kilometers(788.9f64)),
            DynOrigin::Oberon => Ok(Distance::kilometers(761.4f64)),
            DynOrigin::Cordelia => Ok(Distance::kilometers(13f64)),
            DynOrigin::Ophelia => Ok(Distance::kilometers(15f64)),
            DynOrigin::Bianca => Ok(Distance::kilometers(21f64)),
            DynOrigin::Cressida => Ok(Distance::kilometers(31f64)),
            DynOrigin::Desdemona => Ok(Distance::kilometers(27f64)),
            DynOrigin::Juliet => Ok(Distance::kilometers(42f64)),
            DynOrigin::Portia => Ok(Distance::kilometers(54f64)),
            DynOrigin::Rosalind => Ok(Distance::kilometers(27f64)),
            DynOrigin::Belinda => Ok(Distance::kilometers(33f64)),
            DynOrigin::Puck => Ok(Distance::kilometers(77f64)),
            DynOrigin::Triton => Ok(Distance::kilometers(1352.6f64)),
            DynOrigin::Nereid => Ok(Distance::kilometers(170f64)),
            DynOrigin::Naiad => Ok(Distance::kilometers(29f64)),
            DynOrigin::Thalassa => Ok(Distance::kilometers(40f64)),
            DynOrigin::Despina => Ok(Distance::kilometers(74f64)),
            DynOrigin::Galatea => Ok(Distance::kilometers(79f64)),
            DynOrigin::Larissa => Ok(Distance::kilometers(96f64)),
            DynOrigin::Charon => Ok(Distance::kilometers(606f64)),
            DynOrigin::Ceres => Ok(Distance::kilometers(446f64)),
            _ => Err(UndefinedOriginPropertyError {
                origin: self.to_string(),
                prop: "polar radius".to_string(),
            }),
        }
    }
    fn try_equatorial_radius(&self) -> Result<Distance, UndefinedOriginPropertyError> {
        match self {
            DynOrigin::Sun => Ok(Distance::kilometers(695700f64)),
            DynOrigin::Mercury => Ok(Distance::kilometers(2440.53f64)),
            DynOrigin::Venus => Ok(Distance::kilometers(6051.8f64)),
            DynOrigin::Earth => Ok(Distance::kilometers(6378.1366f64)),
            DynOrigin::Mars => Ok(Distance::kilometers(3396.19f64)),
            DynOrigin::Jupiter => Ok(Distance::kilometers(71492f64)),
            DynOrigin::Saturn => Ok(Distance::kilometers(60268f64)),
            DynOrigin::Uranus => Ok(Distance::kilometers(25559f64)),
            DynOrigin::Neptune => Ok(Distance::kilometers(24764f64)),
            DynOrigin::Pluto => Ok(Distance::kilometers(1188.3f64)),
            DynOrigin::Moon => Ok(Distance::kilometers(1737.4f64)),
            DynOrigin::Ganymede => Ok(Distance::kilometers(2631.2f64)),
            DynOrigin::Callisto => Ok(Distance::kilometers(2410.3f64)),
            DynOrigin::Himalia => Ok(Distance::kilometers(85f64)),
            DynOrigin::Elara => Ok(Distance::kilometers(40f64)),
            DynOrigin::Pasiphae => Ok(Distance::kilometers(18f64)),
            DynOrigin::Sinope => Ok(Distance::kilometers(14f64)),
            DynOrigin::Lysithea => Ok(Distance::kilometers(12f64)),
            DynOrigin::Carme => Ok(Distance::kilometers(15f64)),
            DynOrigin::Ananke => Ok(Distance::kilometers(10f64)),
            DynOrigin::Leda => Ok(Distance::kilometers(5f64)),
            DynOrigin::Iapetus => Ok(Distance::kilometers(745.7f64)),
            DynOrigin::Anthe => Ok(Distance::kilometers(0.5f64)),
            DynOrigin::Umbriel => Ok(Distance::kilometers(584.7f64)),
            DynOrigin::Titania => Ok(Distance::kilometers(788.9f64)),
            DynOrigin::Oberon => Ok(Distance::kilometers(761.4f64)),
            DynOrigin::Cordelia => Ok(Distance::kilometers(13f64)),
            DynOrigin::Ophelia => Ok(Distance::kilometers(15f64)),
            DynOrigin::Bianca => Ok(Distance::kilometers(21f64)),
            DynOrigin::Cressida => Ok(Distance::kilometers(31f64)),
            DynOrigin::Desdemona => Ok(Distance::kilometers(27f64)),
            DynOrigin::Juliet => Ok(Distance::kilometers(42f64)),
            DynOrigin::Portia => Ok(Distance::kilometers(54f64)),
            DynOrigin::Rosalind => Ok(Distance::kilometers(27f64)),
            DynOrigin::Belinda => Ok(Distance::kilometers(33f64)),
            DynOrigin::Puck => Ok(Distance::kilometers(77f64)),
            DynOrigin::Triton => Ok(Distance::kilometers(1352.6f64)),
            DynOrigin::Nereid => Ok(Distance::kilometers(170f64)),
            DynOrigin::Naiad => Ok(Distance::kilometers(29f64)),
            DynOrigin::Thalassa => Ok(Distance::kilometers(40f64)),
            DynOrigin::Despina => Ok(Distance::kilometers(74f64)),
            DynOrigin::Galatea => Ok(Distance::kilometers(79f64)),
            DynOrigin::Larissa => Ok(Distance::kilometers(96f64)),
            DynOrigin::Charon => Ok(Distance::kilometers(606f64)),
            DynOrigin::Ceres => Ok(Distance::kilometers(487.3f64)),
            _ => Err(UndefinedOriginPropertyError {
                origin: self.to_string(),
                prop: "equatorial radius".to_string(),
            }),
        }
    }
}
impl TryRotationalElements for DynOrigin {
    fn try_rotational_elements(&self, t: f64) -> Result<Elements, UndefinedOriginPropertyError> {
        match self {
            DynOrigin::Sun => Ok(Sun.rotational_elements(t)),
            DynOrigin::Mercury => Ok(Mercury.rotational_elements(t)),
            DynOrigin::Venus => Ok(Venus.rotational_elements(t)),
            DynOrigin::Earth => Ok(Earth.rotational_elements(t)),
            DynOrigin::Mars => Ok(Mars.rotational_elements(t)),
            DynOrigin::Jupiter => Ok(Jupiter.rotational_elements(t)),
            DynOrigin::Saturn => Ok(Saturn.rotational_elements(t)),
            DynOrigin::Uranus => Ok(Uranus.rotational_elements(t)),
            DynOrigin::Neptune => Ok(Neptune.rotational_elements(t)),
            DynOrigin::Pluto => Ok(Pluto.rotational_elements(t)),
            DynOrigin::Moon => Ok(Moon.rotational_elements(t)),
            DynOrigin::Phobos => Ok(Phobos.rotational_elements(t)),
            DynOrigin::Deimos => Ok(Deimos.rotational_elements(t)),
            DynOrigin::Io => Ok(Io.rotational_elements(t)),
            DynOrigin::Europa => Ok(Europa.rotational_elements(t)),
            DynOrigin::Ganymede => Ok(Ganymede.rotational_elements(t)),
            DynOrigin::Callisto => Ok(Callisto.rotational_elements(t)),
            DynOrigin::Amalthea => Ok(Amalthea.rotational_elements(t)),
            DynOrigin::Thebe => Ok(Thebe.rotational_elements(t)),
            DynOrigin::Adrastea => Ok(Adrastea.rotational_elements(t)),
            DynOrigin::Metis => Ok(Metis.rotational_elements(t)),
            DynOrigin::Mimas => Ok(Mimas.rotational_elements(t)),
            DynOrigin::Enceladus => Ok(Enceladus.rotational_elements(t)),
            DynOrigin::Tethys => Ok(Tethys.rotational_elements(t)),
            DynOrigin::Dione => Ok(Dione.rotational_elements(t)),
            DynOrigin::Rhea => Ok(Rhea.rotational_elements(t)),
            DynOrigin::Titan => Ok(Titan.rotational_elements(t)),
            DynOrigin::Iapetus => Ok(Iapetus.rotational_elements(t)),
            DynOrigin::Phoebe => Ok(Phoebe.rotational_elements(t)),
            DynOrigin::Janus => Ok(Janus.rotational_elements(t)),
            DynOrigin::Epimetheus => Ok(Epimetheus.rotational_elements(t)),
            DynOrigin::Helene => Ok(Helene.rotational_elements(t)),
            DynOrigin::Telesto => Ok(Telesto.rotational_elements(t)),
            DynOrigin::Calypso => Ok(Calypso.rotational_elements(t)),
            DynOrigin::Atlas => Ok(Atlas.rotational_elements(t)),
            DynOrigin::Prometheus => Ok(Prometheus.rotational_elements(t)),
            DynOrigin::Pandora => Ok(Pandora.rotational_elements(t)),
            DynOrigin::Pan => Ok(Pan.rotational_elements(t)),
            DynOrigin::Ariel => Ok(Ariel.rotational_elements(t)),
            DynOrigin::Umbriel => Ok(Umbriel.rotational_elements(t)),
            DynOrigin::Titania => Ok(Titania.rotational_elements(t)),
            DynOrigin::Oberon => Ok(Oberon.rotational_elements(t)),
            DynOrigin::Miranda => Ok(Miranda.rotational_elements(t)),
            DynOrigin::Cordelia => Ok(Cordelia.rotational_elements(t)),
            DynOrigin::Ophelia => Ok(Ophelia.rotational_elements(t)),
            DynOrigin::Bianca => Ok(Bianca.rotational_elements(t)),
            DynOrigin::Cressida => Ok(Cressida.rotational_elements(t)),
            DynOrigin::Desdemona => Ok(Desdemona.rotational_elements(t)),
            DynOrigin::Juliet => Ok(Juliet.rotational_elements(t)),
            DynOrigin::Portia => Ok(Portia.rotational_elements(t)),
            DynOrigin::Rosalind => Ok(Rosalind.rotational_elements(t)),
            DynOrigin::Belinda => Ok(Belinda.rotational_elements(t)),
            DynOrigin::Puck => Ok(Puck.rotational_elements(t)),
            DynOrigin::Triton => Ok(Triton.rotational_elements(t)),
            DynOrigin::Naiad => Ok(Naiad.rotational_elements(t)),
            DynOrigin::Thalassa => Ok(Thalassa.rotational_elements(t)),
            DynOrigin::Despina => Ok(Despina.rotational_elements(t)),
            DynOrigin::Galatea => Ok(Galatea.rotational_elements(t)),
            DynOrigin::Larissa => Ok(Larissa.rotational_elements(t)),
            DynOrigin::Proteus => Ok(Proteus.rotational_elements(t)),
            DynOrigin::Charon => Ok(Charon.rotational_elements(t)),
            DynOrigin::Gaspra => Ok(Gaspra.rotational_elements(t)),
            DynOrigin::Ida => Ok(Ida.rotational_elements(t)),
            DynOrigin::Ceres => Ok(Ceres.rotational_elements(t)),
            DynOrigin::Pallas => Ok(Pallas.rotational_elements(t)),
            DynOrigin::Vesta => Ok(Vesta.rotational_elements(t)),
            DynOrigin::Lutetia => Ok(Lutetia.rotational_elements(t)),
            DynOrigin::Eros => Ok(Eros.rotational_elements(t)),
            DynOrigin::Davida => Ok(Davida.rotational_elements(t)),
            DynOrigin::Steins => Ok(Steins.rotational_elements(t)),
            DynOrigin::Itokawa => Ok(Itokawa.rotational_elements(t)),
            _ => Err(UndefinedOriginPropertyError {
                origin: self.to_string(),
                prop: "rotational elements".to_string(),
            }),
        }
    }
    fn try_rotational_element_rates(
        &self,
        t: f64,
    ) -> Result<Elements, UndefinedOriginPropertyError> {
        match self {
            DynOrigin::Sun => Ok(Sun.rotational_element_rates(t)),
            DynOrigin::Mercury => Ok(Mercury.rotational_element_rates(t)),
            DynOrigin::Venus => Ok(Venus.rotational_element_rates(t)),
            DynOrigin::Earth => Ok(Earth.rotational_element_rates(t)),
            DynOrigin::Mars => Ok(Mars.rotational_element_rates(t)),
            DynOrigin::Jupiter => Ok(Jupiter.rotational_element_rates(t)),
            DynOrigin::Saturn => Ok(Saturn.rotational_element_rates(t)),
            DynOrigin::Uranus => Ok(Uranus.rotational_element_rates(t)),
            DynOrigin::Neptune => Ok(Neptune.rotational_element_rates(t)),
            DynOrigin::Pluto => Ok(Pluto.rotational_element_rates(t)),
            DynOrigin::Moon => Ok(Moon.rotational_element_rates(t)),
            DynOrigin::Phobos => Ok(Phobos.rotational_element_rates(t)),
            DynOrigin::Deimos => Ok(Deimos.rotational_element_rates(t)),
            DynOrigin::Io => Ok(Io.rotational_element_rates(t)),
            DynOrigin::Europa => Ok(Europa.rotational_element_rates(t)),
            DynOrigin::Ganymede => Ok(Ganymede.rotational_element_rates(t)),
            DynOrigin::Callisto => Ok(Callisto.rotational_element_rates(t)),
            DynOrigin::Amalthea => Ok(Amalthea.rotational_element_rates(t)),
            DynOrigin::Thebe => Ok(Thebe.rotational_element_rates(t)),
            DynOrigin::Adrastea => Ok(Adrastea.rotational_element_rates(t)),
            DynOrigin::Metis => Ok(Metis.rotational_element_rates(t)),
            DynOrigin::Mimas => Ok(Mimas.rotational_element_rates(t)),
            DynOrigin::Enceladus => Ok(Enceladus.rotational_element_rates(t)),
            DynOrigin::Tethys => Ok(Tethys.rotational_element_rates(t)),
            DynOrigin::Dione => Ok(Dione.rotational_element_rates(t)),
            DynOrigin::Rhea => Ok(Rhea.rotational_element_rates(t)),
            DynOrigin::Titan => Ok(Titan.rotational_element_rates(t)),
            DynOrigin::Iapetus => Ok(Iapetus.rotational_element_rates(t)),
            DynOrigin::Phoebe => Ok(Phoebe.rotational_element_rates(t)),
            DynOrigin::Janus => Ok(Janus.rotational_element_rates(t)),
            DynOrigin::Epimetheus => Ok(Epimetheus.rotational_element_rates(t)),
            DynOrigin::Helene => Ok(Helene.rotational_element_rates(t)),
            DynOrigin::Telesto => Ok(Telesto.rotational_element_rates(t)),
            DynOrigin::Calypso => Ok(Calypso.rotational_element_rates(t)),
            DynOrigin::Atlas => Ok(Atlas.rotational_element_rates(t)),
            DynOrigin::Prometheus => Ok(Prometheus.rotational_element_rates(t)),
            DynOrigin::Pandora => Ok(Pandora.rotational_element_rates(t)),
            DynOrigin::Pan => Ok(Pan.rotational_element_rates(t)),
            DynOrigin::Ariel => Ok(Ariel.rotational_element_rates(t)),
            DynOrigin::Umbriel => Ok(Umbriel.rotational_element_rates(t)),
            DynOrigin::Titania => Ok(Titania.rotational_element_rates(t)),
            DynOrigin::Oberon => Ok(Oberon.rotational_element_rates(t)),
            DynOrigin::Miranda => Ok(Miranda.rotational_element_rates(t)),
            DynOrigin::Cordelia => Ok(Cordelia.rotational_element_rates(t)),
            DynOrigin::Ophelia => Ok(Ophelia.rotational_element_rates(t)),
            DynOrigin::Bianca => Ok(Bianca.rotational_element_rates(t)),
            DynOrigin::Cressida => Ok(Cressida.rotational_element_rates(t)),
            DynOrigin::Desdemona => Ok(Desdemona.rotational_element_rates(t)),
            DynOrigin::Juliet => Ok(Juliet.rotational_element_rates(t)),
            DynOrigin::Portia => Ok(Portia.rotational_element_rates(t)),
            DynOrigin::Rosalind => Ok(Rosalind.rotational_element_rates(t)),
            DynOrigin::Belinda => Ok(Belinda.rotational_element_rates(t)),
            DynOrigin::Puck => Ok(Puck.rotational_element_rates(t)),
            DynOrigin::Triton => Ok(Triton.rotational_element_rates(t)),
            DynOrigin::Naiad => Ok(Naiad.rotational_element_rates(t)),
            DynOrigin::Thalassa => Ok(Thalassa.rotational_element_rates(t)),
            DynOrigin::Despina => Ok(Despina.rotational_element_rates(t)),
            DynOrigin::Galatea => Ok(Galatea.rotational_element_rates(t)),
            DynOrigin::Larissa => Ok(Larissa.rotational_element_rates(t)),
            DynOrigin::Proteus => Ok(Proteus.rotational_element_rates(t)),
            DynOrigin::Charon => Ok(Charon.rotational_element_rates(t)),
            DynOrigin::Gaspra => Ok(Gaspra.rotational_element_rates(t)),
            DynOrigin::Ida => Ok(Ida.rotational_element_rates(t)),
            DynOrigin::Ceres => Ok(Ceres.rotational_element_rates(t)),
            DynOrigin::Pallas => Ok(Pallas.rotational_element_rates(t)),
            DynOrigin::Vesta => Ok(Vesta.rotational_element_rates(t)),
            DynOrigin::Lutetia => Ok(Lutetia.rotational_element_rates(t)),
            DynOrigin::Eros => Ok(Eros.rotational_element_rates(t)),
            DynOrigin::Davida => Ok(Davida.rotational_element_rates(t)),
            DynOrigin::Steins => Ok(Steins.rotational_element_rates(t)),
            DynOrigin::Itokawa => Ok(Itokawa.rotational_element_rates(t)),
            _ => Err(UndefinedOriginPropertyError {
                origin: self.to_string(),
                prop: "rotational element rates".to_string(),
            }),
        }
    }
}
#[cfg(test)]
#[allow(clippy::approx_constant)]
mod tests {
    use crate::*;
    #[test]
    fn test_origin_10() {
        assert_eq!(Sun.id().0, 10i32);
        assert_eq!(Sun.to_string(), "Sun");
    }
    #[test]
    fn test_point_mass_10() {
        assert_eq!(
            Sun.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(132712440041.27942f64)
        );
        assert_eq!(
            DynOrigin::Sun.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(132712440041.27942f64))
        );
    }
    #[test]
    fn test_mean_radius_10() {
        assert!(DynOrigin::Sun.try_mean_radius().is_err());
    }
    #[test]
    fn test_spheroid_10() {
        assert_eq!(Sun.polar_radius(), Distance::kilometers(695700f64));
        assert_eq!(
            DynOrigin::Sun.try_polar_radius(),
            Ok(Distance::kilometers(695700f64))
        );
        assert_eq!(Sun.equatorial_radius(), Distance::kilometers(695700f64));
        assert_eq!(
            DynOrigin::Sun.try_equatorial_radius(),
            Ok(Distance::kilometers(695700f64))
        );
    }
    #[test]
    fn test_tri_axial_10() {
        assert_eq!(
            Sun.radii(),
            (
                Distance::kilometers(695700f64),
                Distance::kilometers(695700f64),
                Distance::kilometers(695700f64)
            )
        );
        assert_eq!(
            DynOrigin::Sun.try_radii(),
            Ok((
                Distance::kilometers(695700f64),
                Distance::kilometers(695700f64),
                Distance::kilometers(695700f64)
            ))
        );
    }
    #[test]
    fn test_origin_199() {
        assert_eq!(Mercury.id().0, 199i32);
        assert_eq!(Mercury.to_string(), "Mercury");
    }
    #[test]
    fn test_point_mass_199() {
        assert_eq!(
            Mercury.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(22031.868551400003f64)
        );
        assert_eq!(
            DynOrigin::Mercury.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(22031.868551400003f64))
        );
    }
    #[test]
    fn test_mean_radius_199() {
        assert_eq!(Mercury.mean_radius(), Distance::kilometers(2439.4f64));
        assert_eq!(
            DynOrigin::Mercury.try_mean_radius(),
            Ok(Distance::kilometers(2439.4f64))
        );
    }
    #[test]
    fn test_spheroid_199() {
        assert_eq!(Mercury.polar_radius(), Distance::kilometers(2438.26f64));
        assert_eq!(
            DynOrigin::Mercury.try_polar_radius(),
            Ok(Distance::kilometers(2438.26f64))
        );
        assert_eq!(
            Mercury.equatorial_radius(),
            Distance::kilometers(2440.53f64)
        );
        assert_eq!(
            DynOrigin::Mercury.try_equatorial_radius(),
            Ok(Distance::kilometers(2440.53f64))
        );
    }
    #[test]
    fn test_tri_axial_199() {
        assert_eq!(
            Mercury.radii(),
            (
                Distance::kilometers(2440.53f64),
                Distance::kilometers(2440.53f64),
                Distance::kilometers(2438.26f64)
            )
        );
        assert_eq!(
            DynOrigin::Mercury.try_radii(),
            Ok((
                Distance::kilometers(2440.53f64),
                Distance::kilometers(2440.53f64),
                Distance::kilometers(2438.26f64)
            ))
        );
    }
    #[test]
    fn test_origin_299() {
        assert_eq!(Venus.id().0, 299i32);
        assert_eq!(Venus.to_string(), "Venus");
    }
    #[test]
    fn test_point_mass_299() {
        assert_eq!(
            Venus.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(324858.592f64)
        );
        assert_eq!(
            DynOrigin::Venus.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(324858.592f64))
        );
    }
    #[test]
    fn test_mean_radius_299() {
        assert_eq!(Venus.mean_radius(), Distance::kilometers(6051.8f64));
        assert_eq!(
            DynOrigin::Venus.try_mean_radius(),
            Ok(Distance::kilometers(6051.8f64))
        );
    }
    #[test]
    fn test_spheroid_299() {
        assert_eq!(Venus.polar_radius(), Distance::kilometers(6051.8f64));
        assert_eq!(
            DynOrigin::Venus.try_polar_radius(),
            Ok(Distance::kilometers(6051.8f64))
        );
        assert_eq!(Venus.equatorial_radius(), Distance::kilometers(6051.8f64));
        assert_eq!(
            DynOrigin::Venus.try_equatorial_radius(),
            Ok(Distance::kilometers(6051.8f64))
        );
    }
    #[test]
    fn test_tri_axial_299() {
        assert_eq!(
            Venus.radii(),
            (
                Distance::kilometers(6051.8f64),
                Distance::kilometers(6051.8f64),
                Distance::kilometers(6051.8f64)
            )
        );
        assert_eq!(
            DynOrigin::Venus.try_radii(),
            Ok((
                Distance::kilometers(6051.8f64),
                Distance::kilometers(6051.8f64),
                Distance::kilometers(6051.8f64)
            ))
        );
    }
    #[test]
    fn test_origin_399() {
        assert_eq!(Earth.id().0, 399i32);
        assert_eq!(Earth.to_string(), "Earth");
    }
    #[test]
    fn test_point_mass_399() {
        assert_eq!(
            Earth.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(398600.43550702266f64)
        );
        assert_eq!(
            DynOrigin::Earth.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(398600.43550702266f64))
        );
    }
    #[test]
    fn test_mean_radius_399() {
        assert_eq!(Earth.mean_radius(), Distance::kilometers(6371.0084f64));
        assert_eq!(
            DynOrigin::Earth.try_mean_radius(),
            Ok(Distance::kilometers(6371.0084f64))
        );
    }
    #[test]
    fn test_spheroid_399() {
        assert_eq!(Earth.polar_radius(), Distance::kilometers(6356.7519f64));
        assert_eq!(
            DynOrigin::Earth.try_polar_radius(),
            Ok(Distance::kilometers(6356.7519f64))
        );
        assert_eq!(
            Earth.equatorial_radius(),
            Distance::kilometers(6378.1366f64)
        );
        assert_eq!(
            DynOrigin::Earth.try_equatorial_radius(),
            Ok(Distance::kilometers(6378.1366f64))
        );
    }
    #[test]
    fn test_tri_axial_399() {
        assert_eq!(
            Earth.radii(),
            (
                Distance::kilometers(6378.1366f64),
                Distance::kilometers(6378.1366f64),
                Distance::kilometers(6356.7519f64)
            )
        );
        assert_eq!(
            DynOrigin::Earth.try_radii(),
            Ok((
                Distance::kilometers(6378.1366f64),
                Distance::kilometers(6378.1366f64),
                Distance::kilometers(6356.7519f64)
            ))
        );
    }
    #[test]
    fn test_origin_499() {
        assert_eq!(Mars.id().0, 499i32);
        assert_eq!(Mars.to_string(), "Mars");
    }
    #[test]
    fn test_point_mass_499() {
        assert_eq!(
            Mars.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(42828.37362069909f64)
        );
        assert_eq!(
            DynOrigin::Mars.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(42828.37362069909f64))
        );
    }
    #[test]
    fn test_mean_radius_499() {
        assert_eq!(Mars.mean_radius(), Distance::kilometers(3389.5f64));
        assert_eq!(
            DynOrigin::Mars.try_mean_radius(),
            Ok(Distance::kilometers(3389.5f64))
        );
    }
    #[test]
    fn test_spheroid_499() {
        assert_eq!(Mars.polar_radius(), Distance::kilometers(3376.2f64));
        assert_eq!(
            DynOrigin::Mars.try_polar_radius(),
            Ok(Distance::kilometers(3376.2f64))
        );
        assert_eq!(Mars.equatorial_radius(), Distance::kilometers(3396.19f64));
        assert_eq!(
            DynOrigin::Mars.try_equatorial_radius(),
            Ok(Distance::kilometers(3396.19f64))
        );
    }
    #[test]
    fn test_tri_axial_499() {
        assert_eq!(
            Mars.radii(),
            (
                Distance::kilometers(3396.19f64),
                Distance::kilometers(3396.19f64),
                Distance::kilometers(3376.2f64)
            )
        );
        assert_eq!(
            DynOrigin::Mars.try_radii(),
            Ok((
                Distance::kilometers(3396.19f64),
                Distance::kilometers(3396.19f64),
                Distance::kilometers(3376.2f64)
            ))
        );
    }
    #[test]
    fn test_origin_599() {
        assert_eq!(Jupiter.id().0, 599i32);
        assert_eq!(Jupiter.to_string(), "Jupiter");
    }
    #[test]
    fn test_point_mass_599() {
        assert_eq!(
            Jupiter.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(126686531.9003704f64)
        );
        assert_eq!(
            DynOrigin::Jupiter.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(126686531.9003704f64))
        );
    }
    #[test]
    fn test_mean_radius_599() {
        assert_eq!(Jupiter.mean_radius(), Distance::kilometers(69911f64));
        assert_eq!(
            DynOrigin::Jupiter.try_mean_radius(),
            Ok(Distance::kilometers(69911f64))
        );
    }
    #[test]
    fn test_spheroid_599() {
        assert_eq!(Jupiter.polar_radius(), Distance::kilometers(66854f64));
        assert_eq!(
            DynOrigin::Jupiter.try_polar_radius(),
            Ok(Distance::kilometers(66854f64))
        );
        assert_eq!(Jupiter.equatorial_radius(), Distance::kilometers(71492f64));
        assert_eq!(
            DynOrigin::Jupiter.try_equatorial_radius(),
            Ok(Distance::kilometers(71492f64))
        );
    }
    #[test]
    fn test_tri_axial_599() {
        assert_eq!(
            Jupiter.radii(),
            (
                Distance::kilometers(71492f64),
                Distance::kilometers(71492f64),
                Distance::kilometers(66854f64)
            )
        );
        assert_eq!(
            DynOrigin::Jupiter.try_radii(),
            Ok((
                Distance::kilometers(71492f64),
                Distance::kilometers(71492f64),
                Distance::kilometers(66854f64)
            ))
        );
    }
    #[test]
    fn test_origin_699() {
        assert_eq!(Saturn.id().0, 699i32);
        assert_eq!(Saturn.to_string(), "Saturn");
    }
    #[test]
    fn test_point_mass_699() {
        assert_eq!(
            Saturn.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(37931206.23436167f64)
        );
        assert_eq!(
            DynOrigin::Saturn.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(37931206.23436167f64))
        );
    }
    #[test]
    fn test_mean_radius_699() {
        assert_eq!(Saturn.mean_radius(), Distance::kilometers(58232f64));
        assert_eq!(
            DynOrigin::Saturn.try_mean_radius(),
            Ok(Distance::kilometers(58232f64))
        );
    }
    #[test]
    fn test_spheroid_699() {
        assert_eq!(Saturn.polar_radius(), Distance::kilometers(54364f64));
        assert_eq!(
            DynOrigin::Saturn.try_polar_radius(),
            Ok(Distance::kilometers(54364f64))
        );
        assert_eq!(Saturn.equatorial_radius(), Distance::kilometers(60268f64));
        assert_eq!(
            DynOrigin::Saturn.try_equatorial_radius(),
            Ok(Distance::kilometers(60268f64))
        );
    }
    #[test]
    fn test_tri_axial_699() {
        assert_eq!(
            Saturn.radii(),
            (
                Distance::kilometers(60268f64),
                Distance::kilometers(60268f64),
                Distance::kilometers(54364f64)
            )
        );
        assert_eq!(
            DynOrigin::Saturn.try_radii(),
            Ok((
                Distance::kilometers(60268f64),
                Distance::kilometers(60268f64),
                Distance::kilometers(54364f64)
            ))
        );
    }
    #[test]
    fn test_origin_799() {
        assert_eq!(Uranus.id().0, 799i32);
        assert_eq!(Uranus.to_string(), "Uranus");
    }
    #[test]
    fn test_point_mass_799() {
        assert_eq!(
            Uranus.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(5793951.256527211f64)
        );
        assert_eq!(
            DynOrigin::Uranus.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(5793951.256527211f64))
        );
    }
    #[test]
    fn test_mean_radius_799() {
        assert_eq!(Uranus.mean_radius(), Distance::kilometers(25362f64));
        assert_eq!(
            DynOrigin::Uranus.try_mean_radius(),
            Ok(Distance::kilometers(25362f64))
        );
    }
    #[test]
    fn test_spheroid_799() {
        assert_eq!(Uranus.polar_radius(), Distance::kilometers(24973f64));
        assert_eq!(
            DynOrigin::Uranus.try_polar_radius(),
            Ok(Distance::kilometers(24973f64))
        );
        assert_eq!(Uranus.equatorial_radius(), Distance::kilometers(25559f64));
        assert_eq!(
            DynOrigin::Uranus.try_equatorial_radius(),
            Ok(Distance::kilometers(25559f64))
        );
    }
    #[test]
    fn test_tri_axial_799() {
        assert_eq!(
            Uranus.radii(),
            (
                Distance::kilometers(25559f64),
                Distance::kilometers(25559f64),
                Distance::kilometers(24973f64)
            )
        );
        assert_eq!(
            DynOrigin::Uranus.try_radii(),
            Ok((
                Distance::kilometers(25559f64),
                Distance::kilometers(25559f64),
                Distance::kilometers(24973f64)
            ))
        );
    }
    #[test]
    fn test_origin_899() {
        assert_eq!(Neptune.id().0, 899i32);
        assert_eq!(Neptune.to_string(), "Neptune");
    }
    #[test]
    fn test_point_mass_899() {
        assert_eq!(
            Neptune.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(6835103.145462294f64)
        );
        assert_eq!(
            DynOrigin::Neptune.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(6835103.145462294f64))
        );
    }
    #[test]
    fn test_mean_radius_899() {
        assert_eq!(Neptune.mean_radius(), Distance::kilometers(24622f64));
        assert_eq!(
            DynOrigin::Neptune.try_mean_radius(),
            Ok(Distance::kilometers(24622f64))
        );
    }
    #[test]
    fn test_spheroid_899() {
        assert_eq!(Neptune.polar_radius(), Distance::kilometers(24341f64));
        assert_eq!(
            DynOrigin::Neptune.try_polar_radius(),
            Ok(Distance::kilometers(24341f64))
        );
        assert_eq!(Neptune.equatorial_radius(), Distance::kilometers(24764f64));
        assert_eq!(
            DynOrigin::Neptune.try_equatorial_radius(),
            Ok(Distance::kilometers(24764f64))
        );
    }
    #[test]
    fn test_tri_axial_899() {
        assert_eq!(
            Neptune.radii(),
            (
                Distance::kilometers(24764f64),
                Distance::kilometers(24764f64),
                Distance::kilometers(24341f64)
            )
        );
        assert_eq!(
            DynOrigin::Neptune.try_radii(),
            Ok((
                Distance::kilometers(24764f64),
                Distance::kilometers(24764f64),
                Distance::kilometers(24341f64)
            ))
        );
    }
    #[test]
    fn test_origin_999() {
        assert_eq!(Pluto.id().0, 999i32);
        assert_eq!(Pluto.to_string(), "Pluto");
    }
    #[test]
    fn test_point_mass_999() {
        assert_eq!(
            Pluto.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(869.6138177608748f64)
        );
        assert_eq!(
            DynOrigin::Pluto.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(869.6138177608748f64))
        );
    }
    #[test]
    fn test_mean_radius_999() {
        assert_eq!(Pluto.mean_radius(), Distance::kilometers(1188.3f64));
        assert_eq!(
            DynOrigin::Pluto.try_mean_radius(),
            Ok(Distance::kilometers(1188.3f64))
        );
    }
    #[test]
    fn test_spheroid_999() {
        assert_eq!(Pluto.polar_radius(), Distance::kilometers(1188.3f64));
        assert_eq!(
            DynOrigin::Pluto.try_polar_radius(),
            Ok(Distance::kilometers(1188.3f64))
        );
        assert_eq!(Pluto.equatorial_radius(), Distance::kilometers(1188.3f64));
        assert_eq!(
            DynOrigin::Pluto.try_equatorial_radius(),
            Ok(Distance::kilometers(1188.3f64))
        );
    }
    #[test]
    fn test_tri_axial_999() {
        assert_eq!(
            Pluto.radii(),
            (
                Distance::kilometers(1188.3f64),
                Distance::kilometers(1188.3f64),
                Distance::kilometers(1188.3f64)
            )
        );
        assert_eq!(
            DynOrigin::Pluto.try_radii(),
            Ok((
                Distance::kilometers(1188.3f64),
                Distance::kilometers(1188.3f64),
                Distance::kilometers(1188.3f64)
            ))
        );
    }
    #[test]
    fn test_origin_0() {
        assert_eq!(SolarSystemBarycenter.id().0, 0i32);
        assert_eq!(SolarSystemBarycenter.to_string(), "Solar System Barycenter");
    }
    #[test]
    fn test_point_mass_0() {
        assert_eq!(
            SolarSystemBarycenter.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(132712440041.27942f64)
        );
        assert_eq!(
            DynOrigin::SolarSystemBarycenter.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(132712440041.27942f64))
        );
    }
    #[test]
    fn test_origin_1() {
        assert_eq!(MercuryBarycenter.id().0, 1i32);
        assert_eq!(MercuryBarycenter.to_string(), "Mercury Barycenter");
    }
    #[test]
    fn test_point_mass_1() {
        assert_eq!(
            MercuryBarycenter.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(22031.868551400003f64)
        );
        assert_eq!(
            DynOrigin::MercuryBarycenter.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(22031.868551400003f64))
        );
    }
    #[test]
    fn test_origin_2() {
        assert_eq!(VenusBarycenter.id().0, 2i32);
        assert_eq!(VenusBarycenter.to_string(), "Venus Barycenter");
    }
    #[test]
    fn test_point_mass_2() {
        assert_eq!(
            VenusBarycenter.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(324858.592f64)
        );
        assert_eq!(
            DynOrigin::VenusBarycenter.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(324858.592f64))
        );
    }
    #[test]
    fn test_origin_3() {
        assert_eq!(EarthBarycenter.id().0, 3i32);
        assert_eq!(EarthBarycenter.to_string(), "Earth Barycenter");
    }
    #[test]
    fn test_point_mass_3() {
        assert_eq!(
            EarthBarycenter.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(403503.2356254802f64)
        );
        assert_eq!(
            DynOrigin::EarthBarycenter.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(403503.2356254802f64))
        );
    }
    #[test]
    fn test_origin_4() {
        assert_eq!(MarsBarycenter.id().0, 4i32);
        assert_eq!(MarsBarycenter.to_string(), "Mars Barycenter");
    }
    #[test]
    fn test_point_mass_4() {
        assert_eq!(
            MarsBarycenter.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(42828.3758157561f64)
        );
        assert_eq!(
            DynOrigin::MarsBarycenter.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(42828.3758157561f64))
        );
    }
    #[test]
    fn test_origin_5() {
        assert_eq!(JupiterBarycenter.id().0, 5i32);
        assert_eq!(JupiterBarycenter.to_string(), "Jupiter Barycenter");
    }
    #[test]
    fn test_point_mass_5() {
        assert_eq!(
            JupiterBarycenter.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(126712764.09999998f64)
        );
        assert_eq!(
            DynOrigin::JupiterBarycenter.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(126712764.09999998f64))
        );
    }
    #[test]
    fn test_origin_6() {
        assert_eq!(SaturnBarycenter.id().0, 6i32);
        assert_eq!(SaturnBarycenter.to_string(), "Saturn Barycenter");
    }
    #[test]
    fn test_point_mass_6() {
        assert_eq!(
            SaturnBarycenter.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(37940584.8418f64)
        );
        assert_eq!(
            DynOrigin::SaturnBarycenter.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(37940584.8418f64))
        );
    }
    #[test]
    fn test_origin_7() {
        assert_eq!(UranusBarycenter.id().0, 7i32);
        assert_eq!(UranusBarycenter.to_string(), "Uranus Barycenter");
    }
    #[test]
    fn test_point_mass_7() {
        assert_eq!(
            UranusBarycenter.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(5794556.3999999985f64)
        );
        assert_eq!(
            DynOrigin::UranusBarycenter.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(5794556.3999999985f64))
        );
    }
    #[test]
    fn test_origin_8() {
        assert_eq!(NeptuneBarycenter.id().0, 8i32);
        assert_eq!(NeptuneBarycenter.to_string(), "Neptune Barycenter");
    }
    #[test]
    fn test_point_mass_8() {
        assert_eq!(
            NeptuneBarycenter.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(6836527.100580399f64)
        );
        assert_eq!(
            DynOrigin::NeptuneBarycenter.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(6836527.100580399f64))
        );
    }
    #[test]
    fn test_origin_9() {
        assert_eq!(PlutoBarycenter.id().0, 9i32);
        assert_eq!(PlutoBarycenter.to_string(), "Pluto Barycenter");
    }
    #[test]
    fn test_point_mass_9() {
        assert_eq!(
            PlutoBarycenter.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(975.5f64)
        );
        assert_eq!(
            DynOrigin::PlutoBarycenter.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(975.5f64))
        );
    }
    #[test]
    fn test_origin_301() {
        assert_eq!(Moon.id().0, 301i32);
        assert_eq!(Moon.to_string(), "Moon");
    }
    #[test]
    fn test_point_mass_301() {
        assert_eq!(
            Moon.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(4902.80011845755f64)
        );
        assert_eq!(
            DynOrigin::Moon.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(4902.80011845755f64))
        );
    }
    #[test]
    fn test_mean_radius_301() {
        assert_eq!(Moon.mean_radius(), Distance::kilometers(1737.4f64));
        assert_eq!(
            DynOrigin::Moon.try_mean_radius(),
            Ok(Distance::kilometers(1737.4f64))
        );
    }
    #[test]
    fn test_spheroid_301() {
        assert_eq!(Moon.polar_radius(), Distance::kilometers(1737.4f64));
        assert_eq!(
            DynOrigin::Moon.try_polar_radius(),
            Ok(Distance::kilometers(1737.4f64))
        );
        assert_eq!(Moon.equatorial_radius(), Distance::kilometers(1737.4f64));
        assert_eq!(
            DynOrigin::Moon.try_equatorial_radius(),
            Ok(Distance::kilometers(1737.4f64))
        );
    }
    #[test]
    fn test_tri_axial_301() {
        assert_eq!(
            Moon.radii(),
            (
                Distance::kilometers(1737.4f64),
                Distance::kilometers(1737.4f64),
                Distance::kilometers(1737.4f64)
            )
        );
        assert_eq!(
            DynOrigin::Moon.try_radii(),
            Ok((
                Distance::kilometers(1737.4f64),
                Distance::kilometers(1737.4f64),
                Distance::kilometers(1737.4f64)
            ))
        );
    }
    #[test]
    fn test_origin_401() {
        assert_eq!(Phobos.id().0, 401i32);
        assert_eq!(Phobos.to_string(), "Phobos");
    }
    #[test]
    fn test_point_mass_401() {
        assert_eq!(
            Phobos.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(0.0007087546066894452f64)
        );
        assert_eq!(
            DynOrigin::Phobos.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(0.0007087546066894452f64))
        );
    }
    #[test]
    fn test_mean_radius_401() {
        assert_eq!(Phobos.mean_radius(), Distance::kilometers(11.08f64));
        assert_eq!(
            DynOrigin::Phobos.try_mean_radius(),
            Ok(Distance::kilometers(11.08f64))
        );
    }
    #[test]
    fn test_spheroid_401() {
        assert!(DynOrigin::Phobos.try_polar_radius().is_err());
        assert!(DynOrigin::Phobos.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_tri_axial_401() {
        assert_eq!(
            Phobos.radii(),
            (
                Distance::kilometers(13f64),
                Distance::kilometers(11.4f64),
                Distance::kilometers(9.1f64)
            )
        );
        assert_eq!(
            DynOrigin::Phobos.try_radii(),
            Ok((
                Distance::kilometers(13f64),
                Distance::kilometers(11.4f64),
                Distance::kilometers(9.1f64)
            ))
        );
    }
    #[test]
    fn test_origin_402() {
        assert_eq!(Deimos.id().0, 402i32);
        assert_eq!(Deimos.to_string(), "Deimos");
    }
    #[test]
    fn test_point_mass_402() {
        assert_eq!(
            Deimos.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(0.00009615569648120313f64)
        );
        assert_eq!(
            DynOrigin::Deimos.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(
                0.00009615569648120313f64
            ))
        );
    }
    #[test]
    fn test_mean_radius_402() {
        assert_eq!(Deimos.mean_radius(), Distance::kilometers(6.2f64));
        assert_eq!(
            DynOrigin::Deimos.try_mean_radius(),
            Ok(Distance::kilometers(6.2f64))
        );
    }
    #[test]
    fn test_spheroid_402() {
        assert!(DynOrigin::Deimos.try_polar_radius().is_err());
        assert!(DynOrigin::Deimos.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_tri_axial_402() {
        assert_eq!(
            Deimos.radii(),
            (
                Distance::kilometers(7.8f64),
                Distance::kilometers(6f64),
                Distance::kilometers(5.1f64)
            )
        );
        assert_eq!(
            DynOrigin::Deimos.try_radii(),
            Ok((
                Distance::kilometers(7.8f64),
                Distance::kilometers(6f64),
                Distance::kilometers(5.1f64)
            ))
        );
    }
    #[test]
    fn test_origin_501() {
        assert_eq!(Io.id().0, 501i32);
        assert_eq!(Io.to_string(), "Io");
    }
    #[test]
    fn test_point_mass_501() {
        assert_eq!(
            Io.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(5959.915466180539f64)
        );
        assert_eq!(
            DynOrigin::Io.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(5959.915466180539f64))
        );
    }
    #[test]
    fn test_mean_radius_501() {
        assert_eq!(Io.mean_radius(), Distance::kilometers(1821.49f64));
        assert_eq!(
            DynOrigin::Io.try_mean_radius(),
            Ok(Distance::kilometers(1821.49f64))
        );
    }
    #[test]
    fn test_spheroid_501() {
        assert!(DynOrigin::Io.try_polar_radius().is_err());
        assert!(DynOrigin::Io.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_tri_axial_501() {
        assert_eq!(
            Io.radii(),
            (
                Distance::kilometers(1829.4f64),
                Distance::kilometers(1819.4f64),
                Distance::kilometers(1815.7f64)
            )
        );
        assert_eq!(
            DynOrigin::Io.try_radii(),
            Ok((
                Distance::kilometers(1829.4f64),
                Distance::kilometers(1819.4f64),
                Distance::kilometers(1815.7f64)
            ))
        );
    }
    #[test]
    fn test_origin_502() {
        assert_eq!(Europa.id().0, 502i32);
        assert_eq!(Europa.to_string(), "Europa");
    }
    #[test]
    fn test_point_mass_502() {
        assert_eq!(
            Europa.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(3202.712099607295f64)
        );
        assert_eq!(
            DynOrigin::Europa.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(3202.712099607295f64))
        );
    }
    #[test]
    fn test_mean_radius_502() {
        assert_eq!(Europa.mean_radius(), Distance::kilometers(1560.8f64));
        assert_eq!(
            DynOrigin::Europa.try_mean_radius(),
            Ok(Distance::kilometers(1560.8f64))
        );
    }
    #[test]
    fn test_spheroid_502() {
        assert!(DynOrigin::Europa.try_polar_radius().is_err());
        assert!(DynOrigin::Europa.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_tri_axial_502() {
        assert_eq!(
            Europa.radii(),
            (
                Distance::kilometers(1562.6f64),
                Distance::kilometers(1560.3f64),
                Distance::kilometers(1559.5f64)
            )
        );
        assert_eq!(
            DynOrigin::Europa.try_radii(),
            Ok((
                Distance::kilometers(1562.6f64),
                Distance::kilometers(1560.3f64),
                Distance::kilometers(1559.5f64)
            ))
        );
    }
    #[test]
    fn test_origin_503() {
        assert_eq!(Ganymede.id().0, 503i32);
        assert_eq!(Ganymede.to_string(), "Ganymede");
    }
    #[test]
    fn test_point_mass_503() {
        assert_eq!(
            Ganymede.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(9887.832752719638f64)
        );
        assert_eq!(
            DynOrigin::Ganymede.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(9887.832752719638f64))
        );
    }
    #[test]
    fn test_mean_radius_503() {
        assert_eq!(Ganymede.mean_radius(), Distance::kilometers(2631.2f64));
        assert_eq!(
            DynOrigin::Ganymede.try_mean_radius(),
            Ok(Distance::kilometers(2631.2f64))
        );
    }
    #[test]
    fn test_spheroid_503() {
        assert_eq!(Ganymede.polar_radius(), Distance::kilometers(2631.2f64));
        assert_eq!(
            DynOrigin::Ganymede.try_polar_radius(),
            Ok(Distance::kilometers(2631.2f64))
        );
        assert_eq!(
            Ganymede.equatorial_radius(),
            Distance::kilometers(2631.2f64)
        );
        assert_eq!(
            DynOrigin::Ganymede.try_equatorial_radius(),
            Ok(Distance::kilometers(2631.2f64))
        );
    }
    #[test]
    fn test_tri_axial_503() {
        assert_eq!(
            Ganymede.radii(),
            (
                Distance::kilometers(2631.2f64),
                Distance::kilometers(2631.2f64),
                Distance::kilometers(2631.2f64)
            )
        );
        assert_eq!(
            DynOrigin::Ganymede.try_radii(),
            Ok((
                Distance::kilometers(2631.2f64),
                Distance::kilometers(2631.2f64),
                Distance::kilometers(2631.2f64)
            ))
        );
    }
    #[test]
    fn test_origin_504() {
        assert_eq!(Callisto.id().0, 504i32);
        assert_eq!(Callisto.to_string(), "Callisto");
    }
    #[test]
    fn test_point_mass_504() {
        assert_eq!(
            Callisto.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(7179.283402579837f64)
        );
        assert_eq!(
            DynOrigin::Callisto.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(7179.283402579837f64))
        );
    }
    #[test]
    fn test_mean_radius_504() {
        assert_eq!(Callisto.mean_radius(), Distance::kilometers(2410.3f64));
        assert_eq!(
            DynOrigin::Callisto.try_mean_radius(),
            Ok(Distance::kilometers(2410.3f64))
        );
    }
    #[test]
    fn test_spheroid_504() {
        assert_eq!(Callisto.polar_radius(), Distance::kilometers(2410.3f64));
        assert_eq!(
            DynOrigin::Callisto.try_polar_radius(),
            Ok(Distance::kilometers(2410.3f64))
        );
        assert_eq!(
            Callisto.equatorial_radius(),
            Distance::kilometers(2410.3f64)
        );
        assert_eq!(
            DynOrigin::Callisto.try_equatorial_radius(),
            Ok(Distance::kilometers(2410.3f64))
        );
    }
    #[test]
    fn test_tri_axial_504() {
        assert_eq!(
            Callisto.radii(),
            (
                Distance::kilometers(2410.3f64),
                Distance::kilometers(2410.3f64),
                Distance::kilometers(2410.3f64)
            )
        );
        assert_eq!(
            DynOrigin::Callisto.try_radii(),
            Ok((
                Distance::kilometers(2410.3f64),
                Distance::kilometers(2410.3f64),
                Distance::kilometers(2410.3f64)
            ))
        );
    }
    #[test]
    fn test_origin_505() {
        assert_eq!(Amalthea.id().0, 505i32);
        assert_eq!(Amalthea.to_string(), "Amalthea");
    }
    #[test]
    fn test_point_mass_505() {
        assert_eq!(
            Amalthea.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(0.1645634534798259f64)
        );
        assert_eq!(
            DynOrigin::Amalthea.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(0.1645634534798259f64))
        );
    }
    #[test]
    fn test_mean_radius_505() {
        assert_eq!(Amalthea.mean_radius(), Distance::kilometers(83.5f64));
        assert_eq!(
            DynOrigin::Amalthea.try_mean_radius(),
            Ok(Distance::kilometers(83.5f64))
        );
    }
    #[test]
    fn test_spheroid_505() {
        assert!(DynOrigin::Amalthea.try_polar_radius().is_err());
        assert!(DynOrigin::Amalthea.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_tri_axial_505() {
        assert_eq!(
            Amalthea.radii(),
            (
                Distance::kilometers(125f64),
                Distance::kilometers(73f64),
                Distance::kilometers(64f64)
            )
        );
        assert_eq!(
            DynOrigin::Amalthea.try_radii(),
            Ok((
                Distance::kilometers(125f64),
                Distance::kilometers(73f64),
                Distance::kilometers(64f64)
            ))
        );
    }
    #[test]
    fn test_origin_506() {
        assert_eq!(Himalia.id().0, 506i32);
        assert_eq!(Himalia.to_string(), "Himalia");
    }
    #[test]
    fn test_point_mass_506() {
        assert_eq!(
            Himalia.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(0.1515524299611265f64)
        );
        assert_eq!(
            DynOrigin::Himalia.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(0.1515524299611265f64))
        );
    }
    #[test]
    fn test_mean_radius_506() {
        assert_eq!(Himalia.mean_radius(), Distance::kilometers(85f64));
        assert_eq!(
            DynOrigin::Himalia.try_mean_radius(),
            Ok(Distance::kilometers(85f64))
        );
    }
    #[test]
    fn test_spheroid_506() {
        assert_eq!(Himalia.polar_radius(), Distance::kilometers(85f64));
        assert_eq!(
            DynOrigin::Himalia.try_polar_radius(),
            Ok(Distance::kilometers(85f64))
        );
        assert_eq!(Himalia.equatorial_radius(), Distance::kilometers(85f64));
        assert_eq!(
            DynOrigin::Himalia.try_equatorial_radius(),
            Ok(Distance::kilometers(85f64))
        );
    }
    #[test]
    fn test_tri_axial_506() {
        assert_eq!(
            Himalia.radii(),
            (
                Distance::kilometers(85f64),
                Distance::kilometers(85f64),
                Distance::kilometers(85f64)
            )
        );
        assert_eq!(
            DynOrigin::Himalia.try_radii(),
            Ok((
                Distance::kilometers(85f64),
                Distance::kilometers(85f64),
                Distance::kilometers(85f64)
            ))
        );
    }
    #[test]
    fn test_origin_507() {
        assert_eq!(Elara.id().0, 507i32);
        assert_eq!(Elara.to_string(), "Elara");
    }
    #[test]
    fn test_point_mass_507() {
        assert!(DynOrigin::Elara.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_507() {
        assert_eq!(Elara.mean_radius(), Distance::kilometers(40f64));
        assert_eq!(
            DynOrigin::Elara.try_mean_radius(),
            Ok(Distance::kilometers(40f64))
        );
    }
    #[test]
    fn test_spheroid_507() {
        assert_eq!(Elara.polar_radius(), Distance::kilometers(40f64));
        assert_eq!(
            DynOrigin::Elara.try_polar_radius(),
            Ok(Distance::kilometers(40f64))
        );
        assert_eq!(Elara.equatorial_radius(), Distance::kilometers(40f64));
        assert_eq!(
            DynOrigin::Elara.try_equatorial_radius(),
            Ok(Distance::kilometers(40f64))
        );
    }
    #[test]
    fn test_tri_axial_507() {
        assert_eq!(
            Elara.radii(),
            (
                Distance::kilometers(40f64),
                Distance::kilometers(40f64),
                Distance::kilometers(40f64)
            )
        );
        assert_eq!(
            DynOrigin::Elara.try_radii(),
            Ok((
                Distance::kilometers(40f64),
                Distance::kilometers(40f64),
                Distance::kilometers(40f64)
            ))
        );
    }
    #[test]
    fn test_origin_508() {
        assert_eq!(Pasiphae.id().0, 508i32);
        assert_eq!(Pasiphae.to_string(), "Pasiphae");
    }
    #[test]
    fn test_point_mass_508() {
        assert!(DynOrigin::Pasiphae.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_508() {
        assert_eq!(Pasiphae.mean_radius(), Distance::kilometers(18f64));
        assert_eq!(
            DynOrigin::Pasiphae.try_mean_radius(),
            Ok(Distance::kilometers(18f64))
        );
    }
    #[test]
    fn test_spheroid_508() {
        assert_eq!(Pasiphae.polar_radius(), Distance::kilometers(18f64));
        assert_eq!(
            DynOrigin::Pasiphae.try_polar_radius(),
            Ok(Distance::kilometers(18f64))
        );
        assert_eq!(Pasiphae.equatorial_radius(), Distance::kilometers(18f64));
        assert_eq!(
            DynOrigin::Pasiphae.try_equatorial_radius(),
            Ok(Distance::kilometers(18f64))
        );
    }
    #[test]
    fn test_tri_axial_508() {
        assert_eq!(
            Pasiphae.radii(),
            (
                Distance::kilometers(18f64),
                Distance::kilometers(18f64),
                Distance::kilometers(18f64)
            )
        );
        assert_eq!(
            DynOrigin::Pasiphae.try_radii(),
            Ok((
                Distance::kilometers(18f64),
                Distance::kilometers(18f64),
                Distance::kilometers(18f64)
            ))
        );
    }
    #[test]
    fn test_origin_509() {
        assert_eq!(Sinope.id().0, 509i32);
        assert_eq!(Sinope.to_string(), "Sinope");
    }
    #[test]
    fn test_point_mass_509() {
        assert!(DynOrigin::Sinope.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_509() {
        assert_eq!(Sinope.mean_radius(), Distance::kilometers(14f64));
        assert_eq!(
            DynOrigin::Sinope.try_mean_radius(),
            Ok(Distance::kilometers(14f64))
        );
    }
    #[test]
    fn test_spheroid_509() {
        assert_eq!(Sinope.polar_radius(), Distance::kilometers(14f64));
        assert_eq!(
            DynOrigin::Sinope.try_polar_radius(),
            Ok(Distance::kilometers(14f64))
        );
        assert_eq!(Sinope.equatorial_radius(), Distance::kilometers(14f64));
        assert_eq!(
            DynOrigin::Sinope.try_equatorial_radius(),
            Ok(Distance::kilometers(14f64))
        );
    }
    #[test]
    fn test_tri_axial_509() {
        assert_eq!(
            Sinope.radii(),
            (
                Distance::kilometers(14f64),
                Distance::kilometers(14f64),
                Distance::kilometers(14f64)
            )
        );
        assert_eq!(
            DynOrigin::Sinope.try_radii(),
            Ok((
                Distance::kilometers(14f64),
                Distance::kilometers(14f64),
                Distance::kilometers(14f64)
            ))
        );
    }
    #[test]
    fn test_origin_510() {
        assert_eq!(Lysithea.id().0, 510i32);
        assert_eq!(Lysithea.to_string(), "Lysithea");
    }
    #[test]
    fn test_point_mass_510() {
        assert!(DynOrigin::Lysithea.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_510() {
        assert_eq!(Lysithea.mean_radius(), Distance::kilometers(12f64));
        assert_eq!(
            DynOrigin::Lysithea.try_mean_radius(),
            Ok(Distance::kilometers(12f64))
        );
    }
    #[test]
    fn test_spheroid_510() {
        assert_eq!(Lysithea.polar_radius(), Distance::kilometers(12f64));
        assert_eq!(
            DynOrigin::Lysithea.try_polar_radius(),
            Ok(Distance::kilometers(12f64))
        );
        assert_eq!(Lysithea.equatorial_radius(), Distance::kilometers(12f64));
        assert_eq!(
            DynOrigin::Lysithea.try_equatorial_radius(),
            Ok(Distance::kilometers(12f64))
        );
    }
    #[test]
    fn test_tri_axial_510() {
        assert_eq!(
            Lysithea.radii(),
            (
                Distance::kilometers(12f64),
                Distance::kilometers(12f64),
                Distance::kilometers(12f64)
            )
        );
        assert_eq!(
            DynOrigin::Lysithea.try_radii(),
            Ok((
                Distance::kilometers(12f64),
                Distance::kilometers(12f64),
                Distance::kilometers(12f64)
            ))
        );
    }
    #[test]
    fn test_origin_511() {
        assert_eq!(Carme.id().0, 511i32);
        assert_eq!(Carme.to_string(), "Carme");
    }
    #[test]
    fn test_point_mass_511() {
        assert!(DynOrigin::Carme.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_511() {
        assert_eq!(Carme.mean_radius(), Distance::kilometers(15f64));
        assert_eq!(
            DynOrigin::Carme.try_mean_radius(),
            Ok(Distance::kilometers(15f64))
        );
    }
    #[test]
    fn test_spheroid_511() {
        assert_eq!(Carme.polar_radius(), Distance::kilometers(15f64));
        assert_eq!(
            DynOrigin::Carme.try_polar_radius(),
            Ok(Distance::kilometers(15f64))
        );
        assert_eq!(Carme.equatorial_radius(), Distance::kilometers(15f64));
        assert_eq!(
            DynOrigin::Carme.try_equatorial_radius(),
            Ok(Distance::kilometers(15f64))
        );
    }
    #[test]
    fn test_tri_axial_511() {
        assert_eq!(
            Carme.radii(),
            (
                Distance::kilometers(15f64),
                Distance::kilometers(15f64),
                Distance::kilometers(15f64)
            )
        );
        assert_eq!(
            DynOrigin::Carme.try_radii(),
            Ok((
                Distance::kilometers(15f64),
                Distance::kilometers(15f64),
                Distance::kilometers(15f64)
            ))
        );
    }
    #[test]
    fn test_origin_512() {
        assert_eq!(Ananke.id().0, 512i32);
        assert_eq!(Ananke.to_string(), "Ananke");
    }
    #[test]
    fn test_point_mass_512() {
        assert!(DynOrigin::Ananke.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_512() {
        assert_eq!(Ananke.mean_radius(), Distance::kilometers(10f64));
        assert_eq!(
            DynOrigin::Ananke.try_mean_radius(),
            Ok(Distance::kilometers(10f64))
        );
    }
    #[test]
    fn test_spheroid_512() {
        assert_eq!(Ananke.polar_radius(), Distance::kilometers(10f64));
        assert_eq!(
            DynOrigin::Ananke.try_polar_radius(),
            Ok(Distance::kilometers(10f64))
        );
        assert_eq!(Ananke.equatorial_radius(), Distance::kilometers(10f64));
        assert_eq!(
            DynOrigin::Ananke.try_equatorial_radius(),
            Ok(Distance::kilometers(10f64))
        );
    }
    #[test]
    fn test_tri_axial_512() {
        assert_eq!(
            Ananke.radii(),
            (
                Distance::kilometers(10f64),
                Distance::kilometers(10f64),
                Distance::kilometers(10f64)
            )
        );
        assert_eq!(
            DynOrigin::Ananke.try_radii(),
            Ok((
                Distance::kilometers(10f64),
                Distance::kilometers(10f64),
                Distance::kilometers(10f64)
            ))
        );
    }
    #[test]
    fn test_origin_513() {
        assert_eq!(Leda.id().0, 513i32);
        assert_eq!(Leda.to_string(), "Leda");
    }
    #[test]
    fn test_point_mass_513() {
        assert!(DynOrigin::Leda.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_513() {
        assert_eq!(Leda.mean_radius(), Distance::kilometers(5f64));
        assert_eq!(
            DynOrigin::Leda.try_mean_radius(),
            Ok(Distance::kilometers(5f64))
        );
    }
    #[test]
    fn test_spheroid_513() {
        assert_eq!(Leda.polar_radius(), Distance::kilometers(5f64));
        assert_eq!(
            DynOrigin::Leda.try_polar_radius(),
            Ok(Distance::kilometers(5f64))
        );
        assert_eq!(Leda.equatorial_radius(), Distance::kilometers(5f64));
        assert_eq!(
            DynOrigin::Leda.try_equatorial_radius(),
            Ok(Distance::kilometers(5f64))
        );
    }
    #[test]
    fn test_tri_axial_513() {
        assert_eq!(
            Leda.radii(),
            (
                Distance::kilometers(5f64),
                Distance::kilometers(5f64),
                Distance::kilometers(5f64)
            )
        );
        assert_eq!(
            DynOrigin::Leda.try_radii(),
            Ok((
                Distance::kilometers(5f64),
                Distance::kilometers(5f64),
                Distance::kilometers(5f64)
            ))
        );
    }
    #[test]
    fn test_origin_514() {
        assert_eq!(Thebe.id().0, 514i32);
        assert_eq!(Thebe.to_string(), "Thebe");
    }
    #[test]
    fn test_point_mass_514() {
        assert_eq!(
            Thebe.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(0.030148f64)
        );
        assert_eq!(
            DynOrigin::Thebe.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(0.030148f64))
        );
    }
    #[test]
    fn test_mean_radius_514() {
        assert_eq!(Thebe.mean_radius(), Distance::kilometers(49.3f64));
        assert_eq!(
            DynOrigin::Thebe.try_mean_radius(),
            Ok(Distance::kilometers(49.3f64))
        );
    }
    #[test]
    fn test_spheroid_514() {
        assert!(DynOrigin::Thebe.try_polar_radius().is_err());
        assert!(DynOrigin::Thebe.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_tri_axial_514() {
        assert_eq!(
            Thebe.radii(),
            (
                Distance::kilometers(58f64),
                Distance::kilometers(49f64),
                Distance::kilometers(42f64)
            )
        );
        assert_eq!(
            DynOrigin::Thebe.try_radii(),
            Ok((
                Distance::kilometers(58f64),
                Distance::kilometers(49f64),
                Distance::kilometers(42f64)
            ))
        );
    }
    #[test]
    fn test_origin_515() {
        assert_eq!(Adrastea.id().0, 515i32);
        assert_eq!(Adrastea.to_string(), "Adrastea");
    }
    #[test]
    fn test_point_mass_515() {
        assert_eq!(
            Adrastea.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(0.000139f64)
        );
        assert_eq!(
            DynOrigin::Adrastea.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(0.000139f64))
        );
    }
    #[test]
    fn test_mean_radius_515() {
        assert_eq!(Adrastea.mean_radius(), Distance::kilometers(8.2f64));
        assert_eq!(
            DynOrigin::Adrastea.try_mean_radius(),
            Ok(Distance::kilometers(8.2f64))
        );
    }
    #[test]
    fn test_spheroid_515() {
        assert!(DynOrigin::Adrastea.try_polar_radius().is_err());
        assert!(DynOrigin::Adrastea.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_tri_axial_515() {
        assert_eq!(
            Adrastea.radii(),
            (
                Distance::kilometers(10f64),
                Distance::kilometers(8f64),
                Distance::kilometers(7f64)
            )
        );
        assert_eq!(
            DynOrigin::Adrastea.try_radii(),
            Ok((
                Distance::kilometers(10f64),
                Distance::kilometers(8f64),
                Distance::kilometers(7f64)
            ))
        );
    }
    #[test]
    fn test_origin_516() {
        assert_eq!(Metis.id().0, 516i32);
        assert_eq!(Metis.to_string(), "Metis");
    }
    #[test]
    fn test_point_mass_516() {
        assert_eq!(
            Metis.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(0.002501f64)
        );
        assert_eq!(
            DynOrigin::Metis.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(0.002501f64))
        );
    }
    #[test]
    fn test_mean_radius_516() {
        assert_eq!(Metis.mean_radius(), Distance::kilometers(21.5f64));
        assert_eq!(
            DynOrigin::Metis.try_mean_radius(),
            Ok(Distance::kilometers(21.5f64))
        );
    }
    #[test]
    fn test_spheroid_516() {
        assert!(DynOrigin::Metis.try_polar_radius().is_err());
        assert!(DynOrigin::Metis.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_tri_axial_516() {
        assert_eq!(
            Metis.radii(),
            (
                Distance::kilometers(30f64),
                Distance::kilometers(20f64),
                Distance::kilometers(17f64)
            )
        );
        assert_eq!(
            DynOrigin::Metis.try_radii(),
            Ok((
                Distance::kilometers(30f64),
                Distance::kilometers(20f64),
                Distance::kilometers(17f64)
            ))
        );
    }
    #[test]
    fn test_origin_517() {
        assert_eq!(Callirrhoe.id().0, 517i32);
        assert_eq!(Callirrhoe.to_string(), "Callirrhoe");
    }
    #[test]
    fn test_point_mass_517() {
        assert!(DynOrigin::Callirrhoe.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_517() {
        assert!(DynOrigin::Callirrhoe.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_517() {
        assert!(DynOrigin::Callirrhoe.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_517() {
        assert!(DynOrigin::Callirrhoe.try_polar_radius().is_err());
        assert!(DynOrigin::Callirrhoe.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_518() {
        assert_eq!(Themisto.id().0, 518i32);
        assert_eq!(Themisto.to_string(), "Themisto");
    }
    #[test]
    fn test_point_mass_518() {
        assert!(DynOrigin::Themisto.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_518() {
        assert!(DynOrigin::Themisto.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_518() {
        assert!(DynOrigin::Themisto.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_518() {
        assert!(DynOrigin::Themisto.try_polar_radius().is_err());
        assert!(DynOrigin::Themisto.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_519() {
        assert_eq!(Magaclite.id().0, 519i32);
        assert_eq!(Magaclite.to_string(), "Magaclite");
    }
    #[test]
    fn test_point_mass_519() {
        assert!(DynOrigin::Magaclite.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_519() {
        assert!(DynOrigin::Magaclite.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_519() {
        assert!(DynOrigin::Magaclite.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_519() {
        assert!(DynOrigin::Magaclite.try_polar_radius().is_err());
        assert!(DynOrigin::Magaclite.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_520() {
        assert_eq!(Taygete.id().0, 520i32);
        assert_eq!(Taygete.to_string(), "Taygete");
    }
    #[test]
    fn test_point_mass_520() {
        assert!(DynOrigin::Taygete.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_520() {
        assert!(DynOrigin::Taygete.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_520() {
        assert!(DynOrigin::Taygete.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_520() {
        assert!(DynOrigin::Taygete.try_polar_radius().is_err());
        assert!(DynOrigin::Taygete.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_521() {
        assert_eq!(Chaldene.id().0, 521i32);
        assert_eq!(Chaldene.to_string(), "Chaldene");
    }
    #[test]
    fn test_point_mass_521() {
        assert!(DynOrigin::Chaldene.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_521() {
        assert!(DynOrigin::Chaldene.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_521() {
        assert!(DynOrigin::Chaldene.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_521() {
        assert!(DynOrigin::Chaldene.try_polar_radius().is_err());
        assert!(DynOrigin::Chaldene.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_522() {
        assert_eq!(Harpalyke.id().0, 522i32);
        assert_eq!(Harpalyke.to_string(), "Harpalyke");
    }
    #[test]
    fn test_point_mass_522() {
        assert!(DynOrigin::Harpalyke.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_522() {
        assert!(DynOrigin::Harpalyke.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_522() {
        assert!(DynOrigin::Harpalyke.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_522() {
        assert!(DynOrigin::Harpalyke.try_polar_radius().is_err());
        assert!(DynOrigin::Harpalyke.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_523() {
        assert_eq!(Kalyke.id().0, 523i32);
        assert_eq!(Kalyke.to_string(), "Kalyke");
    }
    #[test]
    fn test_point_mass_523() {
        assert!(DynOrigin::Kalyke.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_523() {
        assert!(DynOrigin::Kalyke.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_523() {
        assert!(DynOrigin::Kalyke.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_523() {
        assert!(DynOrigin::Kalyke.try_polar_radius().is_err());
        assert!(DynOrigin::Kalyke.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_524() {
        assert_eq!(Iocaste.id().0, 524i32);
        assert_eq!(Iocaste.to_string(), "Iocaste");
    }
    #[test]
    fn test_point_mass_524() {
        assert!(DynOrigin::Iocaste.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_524() {
        assert!(DynOrigin::Iocaste.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_524() {
        assert!(DynOrigin::Iocaste.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_524() {
        assert!(DynOrigin::Iocaste.try_polar_radius().is_err());
        assert!(DynOrigin::Iocaste.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_525() {
        assert_eq!(Erinome.id().0, 525i32);
        assert_eq!(Erinome.to_string(), "Erinome");
    }
    #[test]
    fn test_point_mass_525() {
        assert!(DynOrigin::Erinome.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_525() {
        assert!(DynOrigin::Erinome.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_525() {
        assert!(DynOrigin::Erinome.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_525() {
        assert!(DynOrigin::Erinome.try_polar_radius().is_err());
        assert!(DynOrigin::Erinome.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_526() {
        assert_eq!(Isonoe.id().0, 526i32);
        assert_eq!(Isonoe.to_string(), "Isonoe");
    }
    #[test]
    fn test_point_mass_526() {
        assert!(DynOrigin::Isonoe.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_526() {
        assert!(DynOrigin::Isonoe.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_526() {
        assert!(DynOrigin::Isonoe.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_526() {
        assert!(DynOrigin::Isonoe.try_polar_radius().is_err());
        assert!(DynOrigin::Isonoe.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_527() {
        assert_eq!(Praxidike.id().0, 527i32);
        assert_eq!(Praxidike.to_string(), "Praxidike");
    }
    #[test]
    fn test_point_mass_527() {
        assert!(DynOrigin::Praxidike.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_527() {
        assert!(DynOrigin::Praxidike.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_527() {
        assert!(DynOrigin::Praxidike.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_527() {
        assert!(DynOrigin::Praxidike.try_polar_radius().is_err());
        assert!(DynOrigin::Praxidike.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_528() {
        assert_eq!(Autonoe.id().0, 528i32);
        assert_eq!(Autonoe.to_string(), "Autonoe");
    }
    #[test]
    fn test_point_mass_528() {
        assert!(DynOrigin::Autonoe.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_528() {
        assert!(DynOrigin::Autonoe.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_528() {
        assert!(DynOrigin::Autonoe.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_528() {
        assert!(DynOrigin::Autonoe.try_polar_radius().is_err());
        assert!(DynOrigin::Autonoe.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_529() {
        assert_eq!(Thyone.id().0, 529i32);
        assert_eq!(Thyone.to_string(), "Thyone");
    }
    #[test]
    fn test_point_mass_529() {
        assert!(DynOrigin::Thyone.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_529() {
        assert!(DynOrigin::Thyone.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_529() {
        assert!(DynOrigin::Thyone.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_529() {
        assert!(DynOrigin::Thyone.try_polar_radius().is_err());
        assert!(DynOrigin::Thyone.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_530() {
        assert_eq!(Hermippe.id().0, 530i32);
        assert_eq!(Hermippe.to_string(), "Hermippe");
    }
    #[test]
    fn test_point_mass_530() {
        assert!(DynOrigin::Hermippe.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_530() {
        assert!(DynOrigin::Hermippe.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_530() {
        assert!(DynOrigin::Hermippe.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_530() {
        assert!(DynOrigin::Hermippe.try_polar_radius().is_err());
        assert!(DynOrigin::Hermippe.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_531() {
        assert_eq!(Aitne.id().0, 531i32);
        assert_eq!(Aitne.to_string(), "Aitne");
    }
    #[test]
    fn test_point_mass_531() {
        assert!(DynOrigin::Aitne.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_531() {
        assert!(DynOrigin::Aitne.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_531() {
        assert!(DynOrigin::Aitne.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_531() {
        assert!(DynOrigin::Aitne.try_polar_radius().is_err());
        assert!(DynOrigin::Aitne.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_532() {
        assert_eq!(Eurydome.id().0, 532i32);
        assert_eq!(Eurydome.to_string(), "Eurydome");
    }
    #[test]
    fn test_point_mass_532() {
        assert!(DynOrigin::Eurydome.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_532() {
        assert!(DynOrigin::Eurydome.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_532() {
        assert!(DynOrigin::Eurydome.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_532() {
        assert!(DynOrigin::Eurydome.try_polar_radius().is_err());
        assert!(DynOrigin::Eurydome.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_533() {
        assert_eq!(Euanthe.id().0, 533i32);
        assert_eq!(Euanthe.to_string(), "Euanthe");
    }
    #[test]
    fn test_point_mass_533() {
        assert!(DynOrigin::Euanthe.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_533() {
        assert!(DynOrigin::Euanthe.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_533() {
        assert!(DynOrigin::Euanthe.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_533() {
        assert!(DynOrigin::Euanthe.try_polar_radius().is_err());
        assert!(DynOrigin::Euanthe.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_534() {
        assert_eq!(Euporie.id().0, 534i32);
        assert_eq!(Euporie.to_string(), "Euporie");
    }
    #[test]
    fn test_point_mass_534() {
        assert!(DynOrigin::Euporie.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_534() {
        assert!(DynOrigin::Euporie.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_534() {
        assert!(DynOrigin::Euporie.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_534() {
        assert!(DynOrigin::Euporie.try_polar_radius().is_err());
        assert!(DynOrigin::Euporie.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_535() {
        assert_eq!(Orthosie.id().0, 535i32);
        assert_eq!(Orthosie.to_string(), "Orthosie");
    }
    #[test]
    fn test_point_mass_535() {
        assert!(DynOrigin::Orthosie.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_535() {
        assert!(DynOrigin::Orthosie.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_535() {
        assert!(DynOrigin::Orthosie.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_535() {
        assert!(DynOrigin::Orthosie.try_polar_radius().is_err());
        assert!(DynOrigin::Orthosie.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_536() {
        assert_eq!(Sponde.id().0, 536i32);
        assert_eq!(Sponde.to_string(), "Sponde");
    }
    #[test]
    fn test_point_mass_536() {
        assert!(DynOrigin::Sponde.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_536() {
        assert!(DynOrigin::Sponde.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_536() {
        assert!(DynOrigin::Sponde.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_536() {
        assert!(DynOrigin::Sponde.try_polar_radius().is_err());
        assert!(DynOrigin::Sponde.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_537() {
        assert_eq!(Kale.id().0, 537i32);
        assert_eq!(Kale.to_string(), "Kale");
    }
    #[test]
    fn test_point_mass_537() {
        assert!(DynOrigin::Kale.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_537() {
        assert!(DynOrigin::Kale.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_537() {
        assert!(DynOrigin::Kale.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_537() {
        assert!(DynOrigin::Kale.try_polar_radius().is_err());
        assert!(DynOrigin::Kale.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_538() {
        assert_eq!(Pasithee.id().0, 538i32);
        assert_eq!(Pasithee.to_string(), "Pasithee");
    }
    #[test]
    fn test_point_mass_538() {
        assert!(DynOrigin::Pasithee.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_538() {
        assert!(DynOrigin::Pasithee.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_538() {
        assert!(DynOrigin::Pasithee.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_538() {
        assert!(DynOrigin::Pasithee.try_polar_radius().is_err());
        assert!(DynOrigin::Pasithee.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_539() {
        assert_eq!(Hegemone.id().0, 539i32);
        assert_eq!(Hegemone.to_string(), "Hegemone");
    }
    #[test]
    fn test_point_mass_539() {
        assert!(DynOrigin::Hegemone.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_539() {
        assert!(DynOrigin::Hegemone.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_539() {
        assert!(DynOrigin::Hegemone.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_539() {
        assert!(DynOrigin::Hegemone.try_polar_radius().is_err());
        assert!(DynOrigin::Hegemone.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_540() {
        assert_eq!(Mneme.id().0, 540i32);
        assert_eq!(Mneme.to_string(), "Mneme");
    }
    #[test]
    fn test_point_mass_540() {
        assert!(DynOrigin::Mneme.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_540() {
        assert!(DynOrigin::Mneme.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_540() {
        assert!(DynOrigin::Mneme.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_540() {
        assert!(DynOrigin::Mneme.try_polar_radius().is_err());
        assert!(DynOrigin::Mneme.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_541() {
        assert_eq!(Aoede.id().0, 541i32);
        assert_eq!(Aoede.to_string(), "Aoede");
    }
    #[test]
    fn test_point_mass_541() {
        assert!(DynOrigin::Aoede.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_541() {
        assert!(DynOrigin::Aoede.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_541() {
        assert!(DynOrigin::Aoede.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_541() {
        assert!(DynOrigin::Aoede.try_polar_radius().is_err());
        assert!(DynOrigin::Aoede.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_542() {
        assert_eq!(Thelxinoe.id().0, 542i32);
        assert_eq!(Thelxinoe.to_string(), "Thelxinoe");
    }
    #[test]
    fn test_point_mass_542() {
        assert!(DynOrigin::Thelxinoe.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_542() {
        assert!(DynOrigin::Thelxinoe.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_542() {
        assert!(DynOrigin::Thelxinoe.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_542() {
        assert!(DynOrigin::Thelxinoe.try_polar_radius().is_err());
        assert!(DynOrigin::Thelxinoe.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_543() {
        assert_eq!(Arche.id().0, 543i32);
        assert_eq!(Arche.to_string(), "Arche");
    }
    #[test]
    fn test_point_mass_543() {
        assert!(DynOrigin::Arche.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_543() {
        assert!(DynOrigin::Arche.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_543() {
        assert!(DynOrigin::Arche.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_543() {
        assert!(DynOrigin::Arche.try_polar_radius().is_err());
        assert!(DynOrigin::Arche.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_544() {
        assert_eq!(Kallichore.id().0, 544i32);
        assert_eq!(Kallichore.to_string(), "Kallichore");
    }
    #[test]
    fn test_point_mass_544() {
        assert!(DynOrigin::Kallichore.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_544() {
        assert!(DynOrigin::Kallichore.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_544() {
        assert!(DynOrigin::Kallichore.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_544() {
        assert!(DynOrigin::Kallichore.try_polar_radius().is_err());
        assert!(DynOrigin::Kallichore.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_545() {
        assert_eq!(Helike.id().0, 545i32);
        assert_eq!(Helike.to_string(), "Helike");
    }
    #[test]
    fn test_point_mass_545() {
        assert!(DynOrigin::Helike.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_545() {
        assert!(DynOrigin::Helike.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_545() {
        assert!(DynOrigin::Helike.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_545() {
        assert!(DynOrigin::Helike.try_polar_radius().is_err());
        assert!(DynOrigin::Helike.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_546() {
        assert_eq!(Carpo.id().0, 546i32);
        assert_eq!(Carpo.to_string(), "Carpo");
    }
    #[test]
    fn test_point_mass_546() {
        assert!(DynOrigin::Carpo.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_546() {
        assert!(DynOrigin::Carpo.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_546() {
        assert!(DynOrigin::Carpo.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_546() {
        assert!(DynOrigin::Carpo.try_polar_radius().is_err());
        assert!(DynOrigin::Carpo.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_547() {
        assert_eq!(Eukelade.id().0, 547i32);
        assert_eq!(Eukelade.to_string(), "Eukelade");
    }
    #[test]
    fn test_point_mass_547() {
        assert!(DynOrigin::Eukelade.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_547() {
        assert!(DynOrigin::Eukelade.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_547() {
        assert!(DynOrigin::Eukelade.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_547() {
        assert!(DynOrigin::Eukelade.try_polar_radius().is_err());
        assert!(DynOrigin::Eukelade.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_548() {
        assert_eq!(Cyllene.id().0, 548i32);
        assert_eq!(Cyllene.to_string(), "Cyllene");
    }
    #[test]
    fn test_point_mass_548() {
        assert!(DynOrigin::Cyllene.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_548() {
        assert!(DynOrigin::Cyllene.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_548() {
        assert!(DynOrigin::Cyllene.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_548() {
        assert!(DynOrigin::Cyllene.try_polar_radius().is_err());
        assert!(DynOrigin::Cyllene.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_549() {
        assert_eq!(Kore.id().0, 549i32);
        assert_eq!(Kore.to_string(), "Kore");
    }
    #[test]
    fn test_point_mass_549() {
        assert!(DynOrigin::Kore.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_549() {
        assert!(DynOrigin::Kore.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_549() {
        assert!(DynOrigin::Kore.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_549() {
        assert!(DynOrigin::Kore.try_polar_radius().is_err());
        assert!(DynOrigin::Kore.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_550() {
        assert_eq!(Herse.id().0, 550i32);
        assert_eq!(Herse.to_string(), "Herse");
    }
    #[test]
    fn test_point_mass_550() {
        assert!(DynOrigin::Herse.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_550() {
        assert!(DynOrigin::Herse.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_550() {
        assert!(DynOrigin::Herse.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_550() {
        assert!(DynOrigin::Herse.try_polar_radius().is_err());
        assert!(DynOrigin::Herse.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_553() {
        assert_eq!(Dia.id().0, 553i32);
        assert_eq!(Dia.to_string(), "Dia");
    }
    #[test]
    fn test_point_mass_553() {
        assert!(DynOrigin::Dia.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_553() {
        assert!(DynOrigin::Dia.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_553() {
        assert!(DynOrigin::Dia.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_553() {
        assert!(DynOrigin::Dia.try_polar_radius().is_err());
        assert!(DynOrigin::Dia.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_601() {
        assert_eq!(Mimas.id().0, 601i32);
        assert_eq!(Mimas.to_string(), "Mimas");
    }
    #[test]
    fn test_point_mass_601() {
        assert_eq!(
            Mimas.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(2.503488768152587f64)
        );
        assert_eq!(
            DynOrigin::Mimas.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(2.503488768152587f64))
        );
    }
    #[test]
    fn test_mean_radius_601() {
        assert_eq!(Mimas.mean_radius(), Distance::kilometers(198.2f64));
        assert_eq!(
            DynOrigin::Mimas.try_mean_radius(),
            Ok(Distance::kilometers(198.2f64))
        );
    }
    #[test]
    fn test_spheroid_601() {
        assert!(DynOrigin::Mimas.try_polar_radius().is_err());
        assert!(DynOrigin::Mimas.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_tri_axial_601() {
        assert_eq!(
            Mimas.radii(),
            (
                Distance::kilometers(207.8f64),
                Distance::kilometers(196.7f64),
                Distance::kilometers(190.6f64)
            )
        );
        assert_eq!(
            DynOrigin::Mimas.try_radii(),
            Ok((
                Distance::kilometers(207.8f64),
                Distance::kilometers(196.7f64),
                Distance::kilometers(190.6f64)
            ))
        );
    }
    #[test]
    fn test_origin_602() {
        assert_eq!(Enceladus.id().0, 602i32);
        assert_eq!(Enceladus.to_string(), "Enceladus");
    }
    #[test]
    fn test_point_mass_602() {
        assert_eq!(
            Enceladus.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(7.210366688598896f64)
        );
        assert_eq!(
            DynOrigin::Enceladus.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(7.210366688598896f64))
        );
    }
    #[test]
    fn test_mean_radius_602() {
        assert_eq!(Enceladus.mean_radius(), Distance::kilometers(252.1f64));
        assert_eq!(
            DynOrigin::Enceladus.try_mean_radius(),
            Ok(Distance::kilometers(252.1f64))
        );
    }
    #[test]
    fn test_spheroid_602() {
        assert!(DynOrigin::Enceladus.try_polar_radius().is_err());
        assert!(DynOrigin::Enceladus.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_tri_axial_602() {
        assert_eq!(
            Enceladus.radii(),
            (
                Distance::kilometers(256.6f64),
                Distance::kilometers(251.4f64),
                Distance::kilometers(248.3f64)
            )
        );
        assert_eq!(
            DynOrigin::Enceladus.try_radii(),
            Ok((
                Distance::kilometers(256.6f64),
                Distance::kilometers(251.4f64),
                Distance::kilometers(248.3f64)
            ))
        );
    }
    #[test]
    fn test_origin_603() {
        assert_eq!(Tethys.id().0, 603i32);
        assert_eq!(Tethys.to_string(), "Tethys");
    }
    #[test]
    fn test_point_mass_603() {
        assert_eq!(
            Tethys.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(41.21352885489587f64)
        );
        assert_eq!(
            DynOrigin::Tethys.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(41.21352885489587f64))
        );
    }
    #[test]
    fn test_mean_radius_603() {
        assert_eq!(Tethys.mean_radius(), Distance::kilometers(531f64));
        assert_eq!(
            DynOrigin::Tethys.try_mean_radius(),
            Ok(Distance::kilometers(531f64))
        );
    }
    #[test]
    fn test_spheroid_603() {
        assert!(DynOrigin::Tethys.try_polar_radius().is_err());
        assert!(DynOrigin::Tethys.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_tri_axial_603() {
        assert_eq!(
            Tethys.radii(),
            (
                Distance::kilometers(538.4f64),
                Distance::kilometers(528.3f64),
                Distance::kilometers(526.3f64)
            )
        );
        assert_eq!(
            DynOrigin::Tethys.try_radii(),
            Ok((
                Distance::kilometers(538.4f64),
                Distance::kilometers(528.3f64),
                Distance::kilometers(526.3f64)
            ))
        );
    }
    #[test]
    fn test_origin_604() {
        assert_eq!(Dione.id().0, 604i32);
        assert_eq!(Dione.to_string(), "Dione");
    }
    #[test]
    fn test_point_mass_604() {
        assert_eq!(
            Dione.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(73.11607172482067f64)
        );
        assert_eq!(
            DynOrigin::Dione.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(73.11607172482067f64))
        );
    }
    #[test]
    fn test_mean_radius_604() {
        assert_eq!(Dione.mean_radius(), Distance::kilometers(561.4f64));
        assert_eq!(
            DynOrigin::Dione.try_mean_radius(),
            Ok(Distance::kilometers(561.4f64))
        );
    }
    #[test]
    fn test_spheroid_604() {
        assert!(DynOrigin::Dione.try_polar_radius().is_err());
        assert!(DynOrigin::Dione.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_tri_axial_604() {
        assert_eq!(
            Dione.radii(),
            (
                Distance::kilometers(563.4f64),
                Distance::kilometers(561.3f64),
                Distance::kilometers(559.6f64)
            )
        );
        assert_eq!(
            DynOrigin::Dione.try_radii(),
            Ok((
                Distance::kilometers(563.4f64),
                Distance::kilometers(561.3f64),
                Distance::kilometers(559.6f64)
            ))
        );
    }
    #[test]
    fn test_origin_605() {
        assert_eq!(Rhea.id().0, 605i32);
        assert_eq!(Rhea.to_string(), "Rhea");
    }
    #[test]
    fn test_point_mass_605() {
        assert_eq!(
            Rhea.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(153.9417519146563f64)
        );
        assert_eq!(
            DynOrigin::Rhea.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(153.9417519146563f64))
        );
    }
    #[test]
    fn test_mean_radius_605() {
        assert_eq!(Rhea.mean_radius(), Distance::kilometers(763.5f64));
        assert_eq!(
            DynOrigin::Rhea.try_mean_radius(),
            Ok(Distance::kilometers(763.5f64))
        );
    }
    #[test]
    fn test_spheroid_605() {
        assert!(DynOrigin::Rhea.try_polar_radius().is_err());
        assert!(DynOrigin::Rhea.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_tri_axial_605() {
        assert_eq!(
            Rhea.radii(),
            (
                Distance::kilometers(765f64),
                Distance::kilometers(763.1f64),
                Distance::kilometers(762.4f64)
            )
        );
        assert_eq!(
            DynOrigin::Rhea.try_radii(),
            Ok((
                Distance::kilometers(765f64),
                Distance::kilometers(763.1f64),
                Distance::kilometers(762.4f64)
            ))
        );
    }
    #[test]
    fn test_origin_606() {
        assert_eq!(Titan.id().0, 606i32);
        assert_eq!(Titan.to_string(), "Titan");
    }
    #[test]
    fn test_point_mass_606() {
        assert_eq!(
            Titan.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(8978.137095521046f64)
        );
        assert_eq!(
            DynOrigin::Titan.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(8978.137095521046f64))
        );
    }
    #[test]
    fn test_mean_radius_606() {
        assert_eq!(Titan.mean_radius(), Distance::kilometers(2575f64));
        assert_eq!(
            DynOrigin::Titan.try_mean_radius(),
            Ok(Distance::kilometers(2575f64))
        );
    }
    #[test]
    fn test_spheroid_606() {
        assert!(DynOrigin::Titan.try_polar_radius().is_err());
        assert!(DynOrigin::Titan.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_tri_axial_606() {
        assert_eq!(
            Titan.radii(),
            (
                Distance::kilometers(2575.15f64),
                Distance::kilometers(2574.78f64),
                Distance::kilometers(2574.47f64)
            )
        );
        assert_eq!(
            DynOrigin::Titan.try_radii(),
            Ok((
                Distance::kilometers(2575.15f64),
                Distance::kilometers(2574.78f64),
                Distance::kilometers(2574.47f64)
            ))
        );
    }
    #[test]
    fn test_origin_607() {
        assert_eq!(Hyperion.id().0, 607i32);
        assert_eq!(Hyperion.to_string(), "Hyperion");
    }
    #[test]
    fn test_point_mass_607() {
        assert_eq!(
            Hyperion.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(0.3704913747932265f64)
        );
        assert_eq!(
            DynOrigin::Hyperion.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(0.3704913747932265f64))
        );
    }
    #[test]
    fn test_mean_radius_607() {
        assert_eq!(Hyperion.mean_radius(), Distance::kilometers(135f64));
        assert_eq!(
            DynOrigin::Hyperion.try_mean_radius(),
            Ok(Distance::kilometers(135f64))
        );
    }
    #[test]
    fn test_spheroid_607() {
        assert!(DynOrigin::Hyperion.try_polar_radius().is_err());
        assert!(DynOrigin::Hyperion.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_tri_axial_607() {
        assert_eq!(
            Hyperion.radii(),
            (
                Distance::kilometers(180.1f64),
                Distance::kilometers(133f64),
                Distance::kilometers(102.7f64)
            )
        );
        assert_eq!(
            DynOrigin::Hyperion.try_radii(),
            Ok((
                Distance::kilometers(180.1f64),
                Distance::kilometers(133f64),
                Distance::kilometers(102.7f64)
            ))
        );
    }
    #[test]
    fn test_origin_608() {
        assert_eq!(Iapetus.id().0, 608i32);
        assert_eq!(Iapetus.to_string(), "Iapetus");
    }
    #[test]
    fn test_point_mass_608() {
        assert_eq!(
            Iapetus.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(120.5151060137642f64)
        );
        assert_eq!(
            DynOrigin::Iapetus.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(120.5151060137642f64))
        );
    }
    #[test]
    fn test_mean_radius_608() {
        assert_eq!(Iapetus.mean_radius(), Distance::kilometers(734.3f64));
        assert_eq!(
            DynOrigin::Iapetus.try_mean_radius(),
            Ok(Distance::kilometers(734.3f64))
        );
    }
    #[test]
    fn test_spheroid_608() {
        assert_eq!(Iapetus.polar_radius(), Distance::kilometers(712.1f64));
        assert_eq!(
            DynOrigin::Iapetus.try_polar_radius(),
            Ok(Distance::kilometers(712.1f64))
        );
        assert_eq!(Iapetus.equatorial_radius(), Distance::kilometers(745.7f64));
        assert_eq!(
            DynOrigin::Iapetus.try_equatorial_radius(),
            Ok(Distance::kilometers(745.7f64))
        );
    }
    #[test]
    fn test_tri_axial_608() {
        assert_eq!(
            Iapetus.radii(),
            (
                Distance::kilometers(745.7f64),
                Distance::kilometers(745.7f64),
                Distance::kilometers(712.1f64)
            )
        );
        assert_eq!(
            DynOrigin::Iapetus.try_radii(),
            Ok((
                Distance::kilometers(745.7f64),
                Distance::kilometers(745.7f64),
                Distance::kilometers(712.1f64)
            ))
        );
    }
    #[test]
    fn test_origin_609() {
        assert_eq!(Phoebe.id().0, 609i32);
        assert_eq!(Phoebe.to_string(), "Phoebe");
    }
    #[test]
    fn test_point_mass_609() {
        assert_eq!(
            Phoebe.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(0.5547860052791678f64)
        );
        assert_eq!(
            DynOrigin::Phoebe.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(0.5547860052791678f64))
        );
    }
    #[test]
    fn test_mean_radius_609() {
        assert_eq!(Phoebe.mean_radius(), Distance::kilometers(106.5f64));
        assert_eq!(
            DynOrigin::Phoebe.try_mean_radius(),
            Ok(Distance::kilometers(106.5f64))
        );
    }
    #[test]
    fn test_spheroid_609() {
        assert!(DynOrigin::Phoebe.try_polar_radius().is_err());
        assert!(DynOrigin::Phoebe.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_tri_axial_609() {
        assert_eq!(
            Phoebe.radii(),
            (
                Distance::kilometers(109.4f64),
                Distance::kilometers(108.5f64),
                Distance::kilometers(101.8f64)
            )
        );
        assert_eq!(
            DynOrigin::Phoebe.try_radii(),
            Ok((
                Distance::kilometers(109.4f64),
                Distance::kilometers(108.5f64),
                Distance::kilometers(101.8f64)
            ))
        );
    }
    #[test]
    fn test_origin_610() {
        assert_eq!(Janus.id().0, 610i32);
        assert_eq!(Janus.to_string(), "Janus");
    }
    #[test]
    fn test_point_mass_610() {
        assert_eq!(
            Janus.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(0.1265765099012197f64)
        );
        assert_eq!(
            DynOrigin::Janus.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(0.1265765099012197f64))
        );
    }
    #[test]
    fn test_mean_radius_610() {
        assert_eq!(Janus.mean_radius(), Distance::kilometers(89.2f64));
        assert_eq!(
            DynOrigin::Janus.try_mean_radius(),
            Ok(Distance::kilometers(89.2f64))
        );
    }
    #[test]
    fn test_spheroid_610() {
        assert!(DynOrigin::Janus.try_polar_radius().is_err());
        assert!(DynOrigin::Janus.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_tri_axial_610() {
        assert_eq!(
            Janus.radii(),
            (
                Distance::kilometers(101.7f64),
                Distance::kilometers(93f64),
                Distance::kilometers(76.3f64)
            )
        );
        assert_eq!(
            DynOrigin::Janus.try_radii(),
            Ok((
                Distance::kilometers(101.7f64),
                Distance::kilometers(93f64),
                Distance::kilometers(76.3f64)
            ))
        );
    }
    #[test]
    fn test_origin_611() {
        assert_eq!(Epimetheus.id().0, 611i32);
        assert_eq!(Epimetheus.to_string(), "Epimetheus");
    }
    #[test]
    fn test_point_mass_611() {
        assert_eq!(
            Epimetheus.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(0.03512333288208074f64)
        );
        assert_eq!(
            DynOrigin::Epimetheus.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(0.03512333288208074f64))
        );
    }
    #[test]
    fn test_mean_radius_611() {
        assert_eq!(Epimetheus.mean_radius(), Distance::kilometers(58.2f64));
        assert_eq!(
            DynOrigin::Epimetheus.try_mean_radius(),
            Ok(Distance::kilometers(58.2f64))
        );
    }
    #[test]
    fn test_spheroid_611() {
        assert!(DynOrigin::Epimetheus.try_polar_radius().is_err());
        assert!(DynOrigin::Epimetheus.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_tri_axial_611() {
        assert_eq!(
            Epimetheus.radii(),
            (
                Distance::kilometers(64.9f64),
                Distance::kilometers(57.3f64),
                Distance::kilometers(53f64)
            )
        );
        assert_eq!(
            DynOrigin::Epimetheus.try_radii(),
            Ok((
                Distance::kilometers(64.9f64),
                Distance::kilometers(57.3f64),
                Distance::kilometers(53f64)
            ))
        );
    }
    #[test]
    fn test_origin_612() {
        assert_eq!(Helene.id().0, 612i32);
        assert_eq!(Helene.to_string(), "Helene");
    }
    #[test]
    fn test_point_mass_612() {
        assert_eq!(
            Helene.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(0.0004757419551776972f64)
        );
        assert_eq!(
            DynOrigin::Helene.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(0.0004757419551776972f64))
        );
    }
    #[test]
    fn test_mean_radius_612() {
        assert_eq!(Helene.mean_radius(), Distance::kilometers(18f64));
        assert_eq!(
            DynOrigin::Helene.try_mean_radius(),
            Ok(Distance::kilometers(18f64))
        );
    }
    #[test]
    fn test_spheroid_612() {
        assert!(DynOrigin::Helene.try_polar_radius().is_err());
        assert!(DynOrigin::Helene.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_tri_axial_612() {
        assert_eq!(
            Helene.radii(),
            (
                Distance::kilometers(22.5f64),
                Distance::kilometers(19.6f64),
                Distance::kilometers(13.3f64)
            )
        );
        assert_eq!(
            DynOrigin::Helene.try_radii(),
            Ok((
                Distance::kilometers(22.5f64),
                Distance::kilometers(19.6f64),
                Distance::kilometers(13.3f64)
            ))
        );
    }
    #[test]
    fn test_origin_613() {
        assert_eq!(Telesto.id().0, 613i32);
        assert_eq!(Telesto.to_string(), "Telesto");
    }
    #[test]
    fn test_point_mass_613() {
        assert!(DynOrigin::Telesto.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_613() {
        assert_eq!(Telesto.mean_radius(), Distance::kilometers(12.4f64));
        assert_eq!(
            DynOrigin::Telesto.try_mean_radius(),
            Ok(Distance::kilometers(12.4f64))
        );
    }
    #[test]
    fn test_spheroid_613() {
        assert!(DynOrigin::Telesto.try_polar_radius().is_err());
        assert!(DynOrigin::Telesto.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_tri_axial_613() {
        assert_eq!(
            Telesto.radii(),
            (
                Distance::kilometers(16.3f64),
                Distance::kilometers(11.8f64),
                Distance::kilometers(9.8f64)
            )
        );
        assert_eq!(
            DynOrigin::Telesto.try_radii(),
            Ok((
                Distance::kilometers(16.3f64),
                Distance::kilometers(11.8f64),
                Distance::kilometers(9.8f64)
            ))
        );
    }
    #[test]
    fn test_origin_614() {
        assert_eq!(Calypso.id().0, 614i32);
        assert_eq!(Calypso.to_string(), "Calypso");
    }
    #[test]
    fn test_point_mass_614() {
        assert!(DynOrigin::Calypso.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_614() {
        assert_eq!(Calypso.mean_radius(), Distance::kilometers(9.6f64));
        assert_eq!(
            DynOrigin::Calypso.try_mean_radius(),
            Ok(Distance::kilometers(9.6f64))
        );
    }
    #[test]
    fn test_spheroid_614() {
        assert!(DynOrigin::Calypso.try_polar_radius().is_err());
        assert!(DynOrigin::Calypso.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_tri_axial_614() {
        assert_eq!(
            Calypso.radii(),
            (
                Distance::kilometers(15.3f64),
                Distance::kilometers(9.3f64),
                Distance::kilometers(6.3f64)
            )
        );
        assert_eq!(
            DynOrigin::Calypso.try_radii(),
            Ok((
                Distance::kilometers(15.3f64),
                Distance::kilometers(9.3f64),
                Distance::kilometers(6.3f64)
            ))
        );
    }
    #[test]
    fn test_origin_615() {
        assert_eq!(Atlas.id().0, 615i32);
        assert_eq!(Atlas.to_string(), "Atlas");
    }
    #[test]
    fn test_point_mass_615() {
        assert_eq!(
            Atlas.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(0.0003718871247516475f64)
        );
        assert_eq!(
            DynOrigin::Atlas.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(0.0003718871247516475f64))
        );
    }
    #[test]
    fn test_mean_radius_615() {
        assert_eq!(Atlas.mean_radius(), Distance::kilometers(15.1f64));
        assert_eq!(
            DynOrigin::Atlas.try_mean_radius(),
            Ok(Distance::kilometers(15.1f64))
        );
    }
    #[test]
    fn test_spheroid_615() {
        assert!(DynOrigin::Atlas.try_polar_radius().is_err());
        assert!(DynOrigin::Atlas.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_tri_axial_615() {
        assert_eq!(
            Atlas.radii(),
            (
                Distance::kilometers(20.5f64),
                Distance::kilometers(17.8f64),
                Distance::kilometers(9.4f64)
            )
        );
        assert_eq!(
            DynOrigin::Atlas.try_radii(),
            Ok((
                Distance::kilometers(20.5f64),
                Distance::kilometers(17.8f64),
                Distance::kilometers(9.4f64)
            ))
        );
    }
    #[test]
    fn test_origin_616() {
        assert_eq!(Prometheus.id().0, 616i32);
        assert_eq!(Prometheus.to_string(), "Prometheus");
    }
    #[test]
    fn test_point_mass_616() {
        assert_eq!(
            Prometheus.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(0.0107520800100761f64)
        );
        assert_eq!(
            DynOrigin::Prometheus.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(0.0107520800100761f64))
        );
    }
    #[test]
    fn test_mean_radius_616() {
        assert_eq!(Prometheus.mean_radius(), Distance::kilometers(43.1f64));
        assert_eq!(
            DynOrigin::Prometheus.try_mean_radius(),
            Ok(Distance::kilometers(43.1f64))
        );
    }
    #[test]
    fn test_spheroid_616() {
        assert!(DynOrigin::Prometheus.try_polar_radius().is_err());
        assert!(DynOrigin::Prometheus.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_tri_axial_616() {
        assert_eq!(
            Prometheus.radii(),
            (
                Distance::kilometers(68.2f64),
                Distance::kilometers(41.6f64),
                Distance::kilometers(28.2f64)
            )
        );
        assert_eq!(
            DynOrigin::Prometheus.try_radii(),
            Ok((
                Distance::kilometers(68.2f64),
                Distance::kilometers(41.6f64),
                Distance::kilometers(28.2f64)
            ))
        );
    }
    #[test]
    fn test_origin_617() {
        assert_eq!(Pandora.id().0, 617i32);
        assert_eq!(Pandora.to_string(), "Pandora");
    }
    #[test]
    fn test_point_mass_617() {
        assert_eq!(
            Pandora.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(0.009290325122028795f64)
        );
        assert_eq!(
            DynOrigin::Pandora.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(0.009290325122028795f64))
        );
    }
    #[test]
    fn test_mean_radius_617() {
        assert_eq!(Pandora.mean_radius(), Distance::kilometers(40.6f64));
        assert_eq!(
            DynOrigin::Pandora.try_mean_radius(),
            Ok(Distance::kilometers(40.6f64))
        );
    }
    #[test]
    fn test_spheroid_617() {
        assert!(DynOrigin::Pandora.try_polar_radius().is_err());
        assert!(DynOrigin::Pandora.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_tri_axial_617() {
        assert_eq!(
            Pandora.radii(),
            (
                Distance::kilometers(52.2f64),
                Distance::kilometers(40.8f64),
                Distance::kilometers(31.5f64)
            )
        );
        assert_eq!(
            DynOrigin::Pandora.try_radii(),
            Ok((
                Distance::kilometers(52.2f64),
                Distance::kilometers(40.8f64),
                Distance::kilometers(31.5f64)
            ))
        );
    }
    #[test]
    fn test_origin_618() {
        assert_eq!(Pan.id().0, 618i32);
        assert_eq!(Pan.to_string(), "Pan");
    }
    #[test]
    fn test_point_mass_618() {
        assert!(DynOrigin::Pan.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_618() {
        assert_eq!(Pan.mean_radius(), Distance::kilometers(14f64));
        assert_eq!(
            DynOrigin::Pan.try_mean_radius(),
            Ok(Distance::kilometers(14f64))
        );
    }
    #[test]
    fn test_spheroid_618() {
        assert!(DynOrigin::Pan.try_polar_radius().is_err());
        assert!(DynOrigin::Pan.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_tri_axial_618() {
        assert_eq!(
            Pan.radii(),
            (
                Distance::kilometers(17.2f64),
                Distance::kilometers(15.4f64),
                Distance::kilometers(10.4f64)
            )
        );
        assert_eq!(
            DynOrigin::Pan.try_radii(),
            Ok((
                Distance::kilometers(17.2f64),
                Distance::kilometers(15.4f64),
                Distance::kilometers(10.4f64)
            ))
        );
    }
    #[test]
    fn test_origin_619() {
        assert_eq!(Ymir.id().0, 619i32);
        assert_eq!(Ymir.to_string(), "Ymir");
    }
    #[test]
    fn test_point_mass_619() {
        assert!(DynOrigin::Ymir.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_619() {
        assert!(DynOrigin::Ymir.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_619() {
        assert!(DynOrigin::Ymir.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_619() {
        assert!(DynOrigin::Ymir.try_polar_radius().is_err());
        assert!(DynOrigin::Ymir.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_620() {
        assert_eq!(Paaliaq.id().0, 620i32);
        assert_eq!(Paaliaq.to_string(), "Paaliaq");
    }
    #[test]
    fn test_point_mass_620() {
        assert!(DynOrigin::Paaliaq.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_620() {
        assert!(DynOrigin::Paaliaq.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_620() {
        assert!(DynOrigin::Paaliaq.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_620() {
        assert!(DynOrigin::Paaliaq.try_polar_radius().is_err());
        assert!(DynOrigin::Paaliaq.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_621() {
        assert_eq!(Tarvos.id().0, 621i32);
        assert_eq!(Tarvos.to_string(), "Tarvos");
    }
    #[test]
    fn test_point_mass_621() {
        assert!(DynOrigin::Tarvos.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_621() {
        assert!(DynOrigin::Tarvos.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_621() {
        assert!(DynOrigin::Tarvos.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_621() {
        assert!(DynOrigin::Tarvos.try_polar_radius().is_err());
        assert!(DynOrigin::Tarvos.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_622() {
        assert_eq!(Ijiraq.id().0, 622i32);
        assert_eq!(Ijiraq.to_string(), "Ijiraq");
    }
    #[test]
    fn test_point_mass_622() {
        assert!(DynOrigin::Ijiraq.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_622() {
        assert!(DynOrigin::Ijiraq.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_622() {
        assert!(DynOrigin::Ijiraq.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_622() {
        assert!(DynOrigin::Ijiraq.try_polar_radius().is_err());
        assert!(DynOrigin::Ijiraq.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_623() {
        assert_eq!(Suttungr.id().0, 623i32);
        assert_eq!(Suttungr.to_string(), "Suttungr");
    }
    #[test]
    fn test_point_mass_623() {
        assert!(DynOrigin::Suttungr.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_623() {
        assert!(DynOrigin::Suttungr.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_623() {
        assert!(DynOrigin::Suttungr.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_623() {
        assert!(DynOrigin::Suttungr.try_polar_radius().is_err());
        assert!(DynOrigin::Suttungr.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_624() {
        assert_eq!(Kiviuq.id().0, 624i32);
        assert_eq!(Kiviuq.to_string(), "Kiviuq");
    }
    #[test]
    fn test_point_mass_624() {
        assert!(DynOrigin::Kiviuq.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_624() {
        assert!(DynOrigin::Kiviuq.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_624() {
        assert!(DynOrigin::Kiviuq.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_624() {
        assert!(DynOrigin::Kiviuq.try_polar_radius().is_err());
        assert!(DynOrigin::Kiviuq.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_625() {
        assert_eq!(Mundilfari.id().0, 625i32);
        assert_eq!(Mundilfari.to_string(), "Mundilfari");
    }
    #[test]
    fn test_point_mass_625() {
        assert!(DynOrigin::Mundilfari.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_625() {
        assert!(DynOrigin::Mundilfari.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_625() {
        assert!(DynOrigin::Mundilfari.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_625() {
        assert!(DynOrigin::Mundilfari.try_polar_radius().is_err());
        assert!(DynOrigin::Mundilfari.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_626() {
        assert_eq!(Albiorix.id().0, 626i32);
        assert_eq!(Albiorix.to_string(), "Albiorix");
    }
    #[test]
    fn test_point_mass_626() {
        assert!(DynOrigin::Albiorix.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_626() {
        assert!(DynOrigin::Albiorix.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_626() {
        assert!(DynOrigin::Albiorix.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_626() {
        assert!(DynOrigin::Albiorix.try_polar_radius().is_err());
        assert!(DynOrigin::Albiorix.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_627() {
        assert_eq!(Skathi.id().0, 627i32);
        assert_eq!(Skathi.to_string(), "Skathi");
    }
    #[test]
    fn test_point_mass_627() {
        assert!(DynOrigin::Skathi.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_627() {
        assert!(DynOrigin::Skathi.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_627() {
        assert!(DynOrigin::Skathi.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_627() {
        assert!(DynOrigin::Skathi.try_polar_radius().is_err());
        assert!(DynOrigin::Skathi.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_628() {
        assert_eq!(Erriapus.id().0, 628i32);
        assert_eq!(Erriapus.to_string(), "Erriapus");
    }
    #[test]
    fn test_point_mass_628() {
        assert!(DynOrigin::Erriapus.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_628() {
        assert!(DynOrigin::Erriapus.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_628() {
        assert!(DynOrigin::Erriapus.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_628() {
        assert!(DynOrigin::Erriapus.try_polar_radius().is_err());
        assert!(DynOrigin::Erriapus.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_629() {
        assert_eq!(Siarnaq.id().0, 629i32);
        assert_eq!(Siarnaq.to_string(), "Siarnaq");
    }
    #[test]
    fn test_point_mass_629() {
        assert!(DynOrigin::Siarnaq.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_629() {
        assert!(DynOrigin::Siarnaq.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_629() {
        assert!(DynOrigin::Siarnaq.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_629() {
        assert!(DynOrigin::Siarnaq.try_polar_radius().is_err());
        assert!(DynOrigin::Siarnaq.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_630() {
        assert_eq!(Thrymr.id().0, 630i32);
        assert_eq!(Thrymr.to_string(), "Thrymr");
    }
    #[test]
    fn test_point_mass_630() {
        assert!(DynOrigin::Thrymr.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_630() {
        assert!(DynOrigin::Thrymr.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_630() {
        assert!(DynOrigin::Thrymr.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_630() {
        assert!(DynOrigin::Thrymr.try_polar_radius().is_err());
        assert!(DynOrigin::Thrymr.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_631() {
        assert_eq!(Narvi.id().0, 631i32);
        assert_eq!(Narvi.to_string(), "Narvi");
    }
    #[test]
    fn test_point_mass_631() {
        assert!(DynOrigin::Narvi.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_631() {
        assert!(DynOrigin::Narvi.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_631() {
        assert!(DynOrigin::Narvi.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_631() {
        assert!(DynOrigin::Narvi.try_polar_radius().is_err());
        assert!(DynOrigin::Narvi.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_632() {
        assert_eq!(Methone.id().0, 632i32);
        assert_eq!(Methone.to_string(), "Methone");
    }
    #[test]
    fn test_point_mass_632() {
        assert!(DynOrigin::Methone.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_632() {
        assert_eq!(Methone.mean_radius(), Distance::kilometers(1.45f64));
        assert_eq!(
            DynOrigin::Methone.try_mean_radius(),
            Ok(Distance::kilometers(1.45f64))
        );
    }
    #[test]
    fn test_spheroid_632() {
        assert!(DynOrigin::Methone.try_polar_radius().is_err());
        assert!(DynOrigin::Methone.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_tri_axial_632() {
        assert_eq!(
            Methone.radii(),
            (
                Distance::kilometers(1.94f64),
                Distance::kilometers(1.29f64),
                Distance::kilometers(1.21f64)
            )
        );
        assert_eq!(
            DynOrigin::Methone.try_radii(),
            Ok((
                Distance::kilometers(1.94f64),
                Distance::kilometers(1.29f64),
                Distance::kilometers(1.21f64)
            ))
        );
    }
    #[test]
    fn test_origin_633() {
        assert_eq!(Pallene.id().0, 633i32);
        assert_eq!(Pallene.to_string(), "Pallene");
    }
    #[test]
    fn test_point_mass_633() {
        assert!(DynOrigin::Pallene.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_633() {
        assert_eq!(Pallene.mean_radius(), Distance::kilometers(2.23f64));
        assert_eq!(
            DynOrigin::Pallene.try_mean_radius(),
            Ok(Distance::kilometers(2.23f64))
        );
    }
    #[test]
    fn test_spheroid_633() {
        assert!(DynOrigin::Pallene.try_polar_radius().is_err());
        assert!(DynOrigin::Pallene.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_tri_axial_633() {
        assert_eq!(
            Pallene.radii(),
            (
                Distance::kilometers(2.88f64),
                Distance::kilometers(2.08f64),
                Distance::kilometers(1.8f64)
            )
        );
        assert_eq!(
            DynOrigin::Pallene.try_radii(),
            Ok((
                Distance::kilometers(2.88f64),
                Distance::kilometers(2.08f64),
                Distance::kilometers(1.8f64)
            ))
        );
    }
    #[test]
    fn test_origin_634() {
        assert_eq!(Polydeuces.id().0, 634i32);
        assert_eq!(Polydeuces.to_string(), "Polydeuces");
    }
    #[test]
    fn test_point_mass_634() {
        assert!(DynOrigin::Polydeuces.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_634() {
        assert_eq!(Polydeuces.mean_radius(), Distance::kilometers(1.3f64));
        assert_eq!(
            DynOrigin::Polydeuces.try_mean_radius(),
            Ok(Distance::kilometers(1.3f64))
        );
    }
    #[test]
    fn test_spheroid_634() {
        assert!(DynOrigin::Polydeuces.try_polar_radius().is_err());
        assert!(DynOrigin::Polydeuces.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_tri_axial_634() {
        assert_eq!(
            Polydeuces.radii(),
            (
                Distance::kilometers(1.5f64),
                Distance::kilometers(1.2f64),
                Distance::kilometers(1f64)
            )
        );
        assert_eq!(
            DynOrigin::Polydeuces.try_radii(),
            Ok((
                Distance::kilometers(1.5f64),
                Distance::kilometers(1.2f64),
                Distance::kilometers(1f64)
            ))
        );
    }
    #[test]
    fn test_origin_635() {
        assert_eq!(Daphnis.id().0, 635i32);
        assert_eq!(Daphnis.to_string(), "Daphnis");
    }
    #[test]
    fn test_point_mass_635() {
        assert!(DynOrigin::Daphnis.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_635() {
        assert_eq!(Daphnis.mean_radius(), Distance::kilometers(3.8f64));
        assert_eq!(
            DynOrigin::Daphnis.try_mean_radius(),
            Ok(Distance::kilometers(3.8f64))
        );
    }
    #[test]
    fn test_spheroid_635() {
        assert!(DynOrigin::Daphnis.try_polar_radius().is_err());
        assert!(DynOrigin::Daphnis.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_tri_axial_635() {
        assert_eq!(
            Daphnis.radii(),
            (
                Distance::kilometers(4.6f64),
                Distance::kilometers(4.5f64),
                Distance::kilometers(2.8f64)
            )
        );
        assert_eq!(
            DynOrigin::Daphnis.try_radii(),
            Ok((
                Distance::kilometers(4.6f64),
                Distance::kilometers(4.5f64),
                Distance::kilometers(2.8f64)
            ))
        );
    }
    #[test]
    fn test_origin_636() {
        assert_eq!(Aegir.id().0, 636i32);
        assert_eq!(Aegir.to_string(), "Aegir");
    }
    #[test]
    fn test_point_mass_636() {
        assert!(DynOrigin::Aegir.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_636() {
        assert!(DynOrigin::Aegir.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_636() {
        assert!(DynOrigin::Aegir.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_636() {
        assert!(DynOrigin::Aegir.try_polar_radius().is_err());
        assert!(DynOrigin::Aegir.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_637() {
        assert_eq!(Bebhionn.id().0, 637i32);
        assert_eq!(Bebhionn.to_string(), "Bebhionn");
    }
    #[test]
    fn test_point_mass_637() {
        assert!(DynOrigin::Bebhionn.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_637() {
        assert!(DynOrigin::Bebhionn.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_637() {
        assert!(DynOrigin::Bebhionn.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_637() {
        assert!(DynOrigin::Bebhionn.try_polar_radius().is_err());
        assert!(DynOrigin::Bebhionn.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_638() {
        assert_eq!(Bergelmir.id().0, 638i32);
        assert_eq!(Bergelmir.to_string(), "Bergelmir");
    }
    #[test]
    fn test_point_mass_638() {
        assert!(DynOrigin::Bergelmir.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_638() {
        assert!(DynOrigin::Bergelmir.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_638() {
        assert!(DynOrigin::Bergelmir.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_638() {
        assert!(DynOrigin::Bergelmir.try_polar_radius().is_err());
        assert!(DynOrigin::Bergelmir.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_639() {
        assert_eq!(Bestla.id().0, 639i32);
        assert_eq!(Bestla.to_string(), "Bestla");
    }
    #[test]
    fn test_point_mass_639() {
        assert!(DynOrigin::Bestla.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_639() {
        assert!(DynOrigin::Bestla.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_639() {
        assert!(DynOrigin::Bestla.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_639() {
        assert!(DynOrigin::Bestla.try_polar_radius().is_err());
        assert!(DynOrigin::Bestla.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_640() {
        assert_eq!(Farbauti.id().0, 640i32);
        assert_eq!(Farbauti.to_string(), "Farbauti");
    }
    #[test]
    fn test_point_mass_640() {
        assert!(DynOrigin::Farbauti.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_640() {
        assert!(DynOrigin::Farbauti.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_640() {
        assert!(DynOrigin::Farbauti.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_640() {
        assert!(DynOrigin::Farbauti.try_polar_radius().is_err());
        assert!(DynOrigin::Farbauti.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_641() {
        assert_eq!(Fenrir.id().0, 641i32);
        assert_eq!(Fenrir.to_string(), "Fenrir");
    }
    #[test]
    fn test_point_mass_641() {
        assert!(DynOrigin::Fenrir.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_641() {
        assert!(DynOrigin::Fenrir.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_641() {
        assert!(DynOrigin::Fenrir.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_641() {
        assert!(DynOrigin::Fenrir.try_polar_radius().is_err());
        assert!(DynOrigin::Fenrir.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_642() {
        assert_eq!(Fornjot.id().0, 642i32);
        assert_eq!(Fornjot.to_string(), "Fornjot");
    }
    #[test]
    fn test_point_mass_642() {
        assert!(DynOrigin::Fornjot.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_642() {
        assert!(DynOrigin::Fornjot.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_642() {
        assert!(DynOrigin::Fornjot.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_642() {
        assert!(DynOrigin::Fornjot.try_polar_radius().is_err());
        assert!(DynOrigin::Fornjot.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_643() {
        assert_eq!(Hati.id().0, 643i32);
        assert_eq!(Hati.to_string(), "Hati");
    }
    #[test]
    fn test_point_mass_643() {
        assert!(DynOrigin::Hati.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_643() {
        assert!(DynOrigin::Hati.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_643() {
        assert!(DynOrigin::Hati.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_643() {
        assert!(DynOrigin::Hati.try_polar_radius().is_err());
        assert!(DynOrigin::Hati.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_644() {
        assert_eq!(Hyrrokkin.id().0, 644i32);
        assert_eq!(Hyrrokkin.to_string(), "Hyrrokkin");
    }
    #[test]
    fn test_point_mass_644() {
        assert!(DynOrigin::Hyrrokkin.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_644() {
        assert!(DynOrigin::Hyrrokkin.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_644() {
        assert!(DynOrigin::Hyrrokkin.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_644() {
        assert!(DynOrigin::Hyrrokkin.try_polar_radius().is_err());
        assert!(DynOrigin::Hyrrokkin.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_645() {
        assert_eq!(Kari.id().0, 645i32);
        assert_eq!(Kari.to_string(), "Kari");
    }
    #[test]
    fn test_point_mass_645() {
        assert!(DynOrigin::Kari.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_645() {
        assert!(DynOrigin::Kari.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_645() {
        assert!(DynOrigin::Kari.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_645() {
        assert!(DynOrigin::Kari.try_polar_radius().is_err());
        assert!(DynOrigin::Kari.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_646() {
        assert_eq!(Loge.id().0, 646i32);
        assert_eq!(Loge.to_string(), "Loge");
    }
    #[test]
    fn test_point_mass_646() {
        assert!(DynOrigin::Loge.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_646() {
        assert!(DynOrigin::Loge.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_646() {
        assert!(DynOrigin::Loge.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_646() {
        assert!(DynOrigin::Loge.try_polar_radius().is_err());
        assert!(DynOrigin::Loge.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_647() {
        assert_eq!(Skoll.id().0, 647i32);
        assert_eq!(Skoll.to_string(), "Skoll");
    }
    #[test]
    fn test_point_mass_647() {
        assert!(DynOrigin::Skoll.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_647() {
        assert!(DynOrigin::Skoll.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_647() {
        assert!(DynOrigin::Skoll.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_647() {
        assert!(DynOrigin::Skoll.try_polar_radius().is_err());
        assert!(DynOrigin::Skoll.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_648() {
        assert_eq!(Surtur.id().0, 648i32);
        assert_eq!(Surtur.to_string(), "Surtur");
    }
    #[test]
    fn test_point_mass_648() {
        assert!(DynOrigin::Surtur.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_648() {
        assert!(DynOrigin::Surtur.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_648() {
        assert!(DynOrigin::Surtur.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_648() {
        assert!(DynOrigin::Surtur.try_polar_radius().is_err());
        assert!(DynOrigin::Surtur.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_649() {
        assert_eq!(Anthe.id().0, 649i32);
        assert_eq!(Anthe.to_string(), "Anthe");
    }
    #[test]
    fn test_point_mass_649() {
        assert!(DynOrigin::Anthe.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_649() {
        assert_eq!(Anthe.mean_radius(), Distance::kilometers(0.5f64));
        assert_eq!(
            DynOrigin::Anthe.try_mean_radius(),
            Ok(Distance::kilometers(0.5f64))
        );
    }
    #[test]
    fn test_spheroid_649() {
        assert_eq!(Anthe.polar_radius(), Distance::kilometers(0.5f64));
        assert_eq!(
            DynOrigin::Anthe.try_polar_radius(),
            Ok(Distance::kilometers(0.5f64))
        );
        assert_eq!(Anthe.equatorial_radius(), Distance::kilometers(0.5f64));
        assert_eq!(
            DynOrigin::Anthe.try_equatorial_radius(),
            Ok(Distance::kilometers(0.5f64))
        );
    }
    #[test]
    fn test_tri_axial_649() {
        assert_eq!(
            Anthe.radii(),
            (
                Distance::kilometers(0.5f64),
                Distance::kilometers(0.5f64),
                Distance::kilometers(0.5f64)
            )
        );
        assert_eq!(
            DynOrigin::Anthe.try_radii(),
            Ok((
                Distance::kilometers(0.5f64),
                Distance::kilometers(0.5f64),
                Distance::kilometers(0.5f64)
            ))
        );
    }
    #[test]
    fn test_origin_650() {
        assert_eq!(Jarnsaxa.id().0, 650i32);
        assert_eq!(Jarnsaxa.to_string(), "Jarnsaxa");
    }
    #[test]
    fn test_point_mass_650() {
        assert!(DynOrigin::Jarnsaxa.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_650() {
        assert!(DynOrigin::Jarnsaxa.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_650() {
        assert!(DynOrigin::Jarnsaxa.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_650() {
        assert!(DynOrigin::Jarnsaxa.try_polar_radius().is_err());
        assert!(DynOrigin::Jarnsaxa.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_651() {
        assert_eq!(Greip.id().0, 651i32);
        assert_eq!(Greip.to_string(), "Greip");
    }
    #[test]
    fn test_point_mass_651() {
        assert!(DynOrigin::Greip.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_651() {
        assert!(DynOrigin::Greip.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_651() {
        assert!(DynOrigin::Greip.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_651() {
        assert!(DynOrigin::Greip.try_polar_radius().is_err());
        assert!(DynOrigin::Greip.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_652() {
        assert_eq!(Tarqeq.id().0, 652i32);
        assert_eq!(Tarqeq.to_string(), "Tarqeq");
    }
    #[test]
    fn test_point_mass_652() {
        assert!(DynOrigin::Tarqeq.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_652() {
        assert!(DynOrigin::Tarqeq.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_652() {
        assert!(DynOrigin::Tarqeq.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_652() {
        assert!(DynOrigin::Tarqeq.try_polar_radius().is_err());
        assert!(DynOrigin::Tarqeq.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_653() {
        assert_eq!(Aegaeon.id().0, 653i32);
        assert_eq!(Aegaeon.to_string(), "Aegaeon");
    }
    #[test]
    fn test_point_mass_653() {
        assert!(DynOrigin::Aegaeon.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_653() {
        assert_eq!(Aegaeon.mean_radius(), Distance::kilometers(0.33f64));
        assert_eq!(
            DynOrigin::Aegaeon.try_mean_radius(),
            Ok(Distance::kilometers(0.33f64))
        );
    }
    #[test]
    fn test_spheroid_653() {
        assert!(DynOrigin::Aegaeon.try_polar_radius().is_err());
        assert!(DynOrigin::Aegaeon.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_tri_axial_653() {
        assert_eq!(
            Aegaeon.radii(),
            (
                Distance::kilometers(0.7f64),
                Distance::kilometers(0.25f64),
                Distance::kilometers(0.2f64)
            )
        );
        assert_eq!(
            DynOrigin::Aegaeon.try_radii(),
            Ok((
                Distance::kilometers(0.7f64),
                Distance::kilometers(0.25f64),
                Distance::kilometers(0.2f64)
            ))
        );
    }
    #[test]
    fn test_origin_701() {
        assert_eq!(Ariel.id().0, 701i32);
        assert_eq!(Ariel.to_string(), "Ariel");
    }
    #[test]
    fn test_point_mass_701() {
        assert_eq!(
            Ariel.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(83.46344431770477f64)
        );
        assert_eq!(
            DynOrigin::Ariel.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(83.46344431770477f64))
        );
    }
    #[test]
    fn test_mean_radius_701() {
        assert_eq!(Ariel.mean_radius(), Distance::kilometers(578.9f64));
        assert_eq!(
            DynOrigin::Ariel.try_mean_radius(),
            Ok(Distance::kilometers(578.9f64))
        );
    }
    #[test]
    fn test_spheroid_701() {
        assert!(DynOrigin::Ariel.try_polar_radius().is_err());
        assert!(DynOrigin::Ariel.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_tri_axial_701() {
        assert_eq!(
            Ariel.radii(),
            (
                Distance::kilometers(581.1f64),
                Distance::kilometers(577.9f64),
                Distance::kilometers(577.7f64)
            )
        );
        assert_eq!(
            DynOrigin::Ariel.try_radii(),
            Ok((
                Distance::kilometers(581.1f64),
                Distance::kilometers(577.9f64),
                Distance::kilometers(577.7f64)
            ))
        );
    }
    #[test]
    fn test_origin_702() {
        assert_eq!(Umbriel.id().0, 702i32);
        assert_eq!(Umbriel.to_string(), "Umbriel");
    }
    #[test]
    fn test_point_mass_702() {
        assert_eq!(
            Umbriel.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(85.09338094489388f64)
        );
        assert_eq!(
            DynOrigin::Umbriel.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(85.09338094489388f64))
        );
    }
    #[test]
    fn test_mean_radius_702() {
        assert_eq!(Umbriel.mean_radius(), Distance::kilometers(584.7f64));
        assert_eq!(
            DynOrigin::Umbriel.try_mean_radius(),
            Ok(Distance::kilometers(584.7f64))
        );
    }
    #[test]
    fn test_spheroid_702() {
        assert_eq!(Umbriel.polar_radius(), Distance::kilometers(584.7f64));
        assert_eq!(
            DynOrigin::Umbriel.try_polar_radius(),
            Ok(Distance::kilometers(584.7f64))
        );
        assert_eq!(Umbriel.equatorial_radius(), Distance::kilometers(584.7f64));
        assert_eq!(
            DynOrigin::Umbriel.try_equatorial_radius(),
            Ok(Distance::kilometers(584.7f64))
        );
    }
    #[test]
    fn test_tri_axial_702() {
        assert_eq!(
            Umbriel.radii(),
            (
                Distance::kilometers(584.7f64),
                Distance::kilometers(584.7f64),
                Distance::kilometers(584.7f64)
            )
        );
        assert_eq!(
            DynOrigin::Umbriel.try_radii(),
            Ok((
                Distance::kilometers(584.7f64),
                Distance::kilometers(584.7f64),
                Distance::kilometers(584.7f64)
            ))
        );
    }
    #[test]
    fn test_origin_703() {
        assert_eq!(Titania.id().0, 703i32);
        assert_eq!(Titania.to_string(), "Titania");
    }
    #[test]
    fn test_point_mass_703() {
        assert_eq!(
            Titania.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(226.9437003741248f64)
        );
        assert_eq!(
            DynOrigin::Titania.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(226.9437003741248f64))
        );
    }
    #[test]
    fn test_mean_radius_703() {
        assert_eq!(Titania.mean_radius(), Distance::kilometers(788.9f64));
        assert_eq!(
            DynOrigin::Titania.try_mean_radius(),
            Ok(Distance::kilometers(788.9f64))
        );
    }
    #[test]
    fn test_spheroid_703() {
        assert_eq!(Titania.polar_radius(), Distance::kilometers(788.9f64));
        assert_eq!(
            DynOrigin::Titania.try_polar_radius(),
            Ok(Distance::kilometers(788.9f64))
        );
        assert_eq!(Titania.equatorial_radius(), Distance::kilometers(788.9f64));
        assert_eq!(
            DynOrigin::Titania.try_equatorial_radius(),
            Ok(Distance::kilometers(788.9f64))
        );
    }
    #[test]
    fn test_tri_axial_703() {
        assert_eq!(
            Titania.radii(),
            (
                Distance::kilometers(788.9f64),
                Distance::kilometers(788.9f64),
                Distance::kilometers(788.9f64)
            )
        );
        assert_eq!(
            DynOrigin::Titania.try_radii(),
            Ok((
                Distance::kilometers(788.9f64),
                Distance::kilometers(788.9f64),
                Distance::kilometers(788.9f64)
            ))
        );
    }
    #[test]
    fn test_origin_704() {
        assert_eq!(Oberon.id().0, 704i32);
        assert_eq!(Oberon.to_string(), "Oberon");
    }
    #[test]
    fn test_point_mass_704() {
        assert_eq!(
            Oberon.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(205.3234302535623f64)
        );
        assert_eq!(
            DynOrigin::Oberon.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(205.3234302535623f64))
        );
    }
    #[test]
    fn test_mean_radius_704() {
        assert_eq!(Oberon.mean_radius(), Distance::kilometers(761.4f64));
        assert_eq!(
            DynOrigin::Oberon.try_mean_radius(),
            Ok(Distance::kilometers(761.4f64))
        );
    }
    #[test]
    fn test_spheroid_704() {
        assert_eq!(Oberon.polar_radius(), Distance::kilometers(761.4f64));
        assert_eq!(
            DynOrigin::Oberon.try_polar_radius(),
            Ok(Distance::kilometers(761.4f64))
        );
        assert_eq!(Oberon.equatorial_radius(), Distance::kilometers(761.4f64));
        assert_eq!(
            DynOrigin::Oberon.try_equatorial_radius(),
            Ok(Distance::kilometers(761.4f64))
        );
    }
    #[test]
    fn test_tri_axial_704() {
        assert_eq!(
            Oberon.radii(),
            (
                Distance::kilometers(761.4f64),
                Distance::kilometers(761.4f64),
                Distance::kilometers(761.4f64)
            )
        );
        assert_eq!(
            DynOrigin::Oberon.try_radii(),
            Ok((
                Distance::kilometers(761.4f64),
                Distance::kilometers(761.4f64),
                Distance::kilometers(761.4f64)
            ))
        );
    }
    #[test]
    fn test_origin_705() {
        assert_eq!(Miranda.id().0, 705i32);
        assert_eq!(Miranda.to_string(), "Miranda");
    }
    #[test]
    fn test_point_mass_705() {
        assert_eq!(
            Miranda.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(4.3195168992321f64)
        );
        assert_eq!(
            DynOrigin::Miranda.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(4.3195168992321f64))
        );
    }
    #[test]
    fn test_mean_radius_705() {
        assert_eq!(Miranda.mean_radius(), Distance::kilometers(235.8f64));
        assert_eq!(
            DynOrigin::Miranda.try_mean_radius(),
            Ok(Distance::kilometers(235.8f64))
        );
    }
    #[test]
    fn test_spheroid_705() {
        assert!(DynOrigin::Miranda.try_polar_radius().is_err());
        assert!(DynOrigin::Miranda.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_tri_axial_705() {
        assert_eq!(
            Miranda.radii(),
            (
                Distance::kilometers(240.4f64),
                Distance::kilometers(234.2f64),
                Distance::kilometers(232.9f64)
            )
        );
        assert_eq!(
            DynOrigin::Miranda.try_radii(),
            Ok((
                Distance::kilometers(240.4f64),
                Distance::kilometers(234.2f64),
                Distance::kilometers(232.9f64)
            ))
        );
    }
    #[test]
    fn test_origin_706() {
        assert_eq!(Cordelia.id().0, 706i32);
        assert_eq!(Cordelia.to_string(), "Cordelia");
    }
    #[test]
    fn test_point_mass_706() {
        assert!(DynOrigin::Cordelia.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_706() {
        assert_eq!(Cordelia.mean_radius(), Distance::kilometers(13f64));
        assert_eq!(
            DynOrigin::Cordelia.try_mean_radius(),
            Ok(Distance::kilometers(13f64))
        );
    }
    #[test]
    fn test_spheroid_706() {
        assert_eq!(Cordelia.polar_radius(), Distance::kilometers(13f64));
        assert_eq!(
            DynOrigin::Cordelia.try_polar_radius(),
            Ok(Distance::kilometers(13f64))
        );
        assert_eq!(Cordelia.equatorial_radius(), Distance::kilometers(13f64));
        assert_eq!(
            DynOrigin::Cordelia.try_equatorial_radius(),
            Ok(Distance::kilometers(13f64))
        );
    }
    #[test]
    fn test_tri_axial_706() {
        assert_eq!(
            Cordelia.radii(),
            (
                Distance::kilometers(13f64),
                Distance::kilometers(13f64),
                Distance::kilometers(13f64)
            )
        );
        assert_eq!(
            DynOrigin::Cordelia.try_radii(),
            Ok((
                Distance::kilometers(13f64),
                Distance::kilometers(13f64),
                Distance::kilometers(13f64)
            ))
        );
    }
    #[test]
    fn test_origin_707() {
        assert_eq!(Ophelia.id().0, 707i32);
        assert_eq!(Ophelia.to_string(), "Ophelia");
    }
    #[test]
    fn test_point_mass_707() {
        assert!(DynOrigin::Ophelia.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_707() {
        assert_eq!(Ophelia.mean_radius(), Distance::kilometers(15f64));
        assert_eq!(
            DynOrigin::Ophelia.try_mean_radius(),
            Ok(Distance::kilometers(15f64))
        );
    }
    #[test]
    fn test_spheroid_707() {
        assert_eq!(Ophelia.polar_radius(), Distance::kilometers(15f64));
        assert_eq!(
            DynOrigin::Ophelia.try_polar_radius(),
            Ok(Distance::kilometers(15f64))
        );
        assert_eq!(Ophelia.equatorial_radius(), Distance::kilometers(15f64));
        assert_eq!(
            DynOrigin::Ophelia.try_equatorial_radius(),
            Ok(Distance::kilometers(15f64))
        );
    }
    #[test]
    fn test_tri_axial_707() {
        assert_eq!(
            Ophelia.radii(),
            (
                Distance::kilometers(15f64),
                Distance::kilometers(15f64),
                Distance::kilometers(15f64)
            )
        );
        assert_eq!(
            DynOrigin::Ophelia.try_radii(),
            Ok((
                Distance::kilometers(15f64),
                Distance::kilometers(15f64),
                Distance::kilometers(15f64)
            ))
        );
    }
    #[test]
    fn test_origin_708() {
        assert_eq!(Bianca.id().0, 708i32);
        assert_eq!(Bianca.to_string(), "Bianca");
    }
    #[test]
    fn test_point_mass_708() {
        assert!(DynOrigin::Bianca.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_708() {
        assert_eq!(Bianca.mean_radius(), Distance::kilometers(21f64));
        assert_eq!(
            DynOrigin::Bianca.try_mean_radius(),
            Ok(Distance::kilometers(21f64))
        );
    }
    #[test]
    fn test_spheroid_708() {
        assert_eq!(Bianca.polar_radius(), Distance::kilometers(21f64));
        assert_eq!(
            DynOrigin::Bianca.try_polar_radius(),
            Ok(Distance::kilometers(21f64))
        );
        assert_eq!(Bianca.equatorial_radius(), Distance::kilometers(21f64));
        assert_eq!(
            DynOrigin::Bianca.try_equatorial_radius(),
            Ok(Distance::kilometers(21f64))
        );
    }
    #[test]
    fn test_tri_axial_708() {
        assert_eq!(
            Bianca.radii(),
            (
                Distance::kilometers(21f64),
                Distance::kilometers(21f64),
                Distance::kilometers(21f64)
            )
        );
        assert_eq!(
            DynOrigin::Bianca.try_radii(),
            Ok((
                Distance::kilometers(21f64),
                Distance::kilometers(21f64),
                Distance::kilometers(21f64)
            ))
        );
    }
    #[test]
    fn test_origin_709() {
        assert_eq!(Cressida.id().0, 709i32);
        assert_eq!(Cressida.to_string(), "Cressida");
    }
    #[test]
    fn test_point_mass_709() {
        assert!(DynOrigin::Cressida.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_709() {
        assert_eq!(Cressida.mean_radius(), Distance::kilometers(31f64));
        assert_eq!(
            DynOrigin::Cressida.try_mean_radius(),
            Ok(Distance::kilometers(31f64))
        );
    }
    #[test]
    fn test_spheroid_709() {
        assert_eq!(Cressida.polar_radius(), Distance::kilometers(31f64));
        assert_eq!(
            DynOrigin::Cressida.try_polar_radius(),
            Ok(Distance::kilometers(31f64))
        );
        assert_eq!(Cressida.equatorial_radius(), Distance::kilometers(31f64));
        assert_eq!(
            DynOrigin::Cressida.try_equatorial_radius(),
            Ok(Distance::kilometers(31f64))
        );
    }
    #[test]
    fn test_tri_axial_709() {
        assert_eq!(
            Cressida.radii(),
            (
                Distance::kilometers(31f64),
                Distance::kilometers(31f64),
                Distance::kilometers(31f64)
            )
        );
        assert_eq!(
            DynOrigin::Cressida.try_radii(),
            Ok((
                Distance::kilometers(31f64),
                Distance::kilometers(31f64),
                Distance::kilometers(31f64)
            ))
        );
    }
    #[test]
    fn test_origin_710() {
        assert_eq!(Desdemona.id().0, 710i32);
        assert_eq!(Desdemona.to_string(), "Desdemona");
    }
    #[test]
    fn test_point_mass_710() {
        assert!(DynOrigin::Desdemona.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_710() {
        assert_eq!(Desdemona.mean_radius(), Distance::kilometers(27f64));
        assert_eq!(
            DynOrigin::Desdemona.try_mean_radius(),
            Ok(Distance::kilometers(27f64))
        );
    }
    #[test]
    fn test_spheroid_710() {
        assert_eq!(Desdemona.polar_radius(), Distance::kilometers(27f64));
        assert_eq!(
            DynOrigin::Desdemona.try_polar_radius(),
            Ok(Distance::kilometers(27f64))
        );
        assert_eq!(Desdemona.equatorial_radius(), Distance::kilometers(27f64));
        assert_eq!(
            DynOrigin::Desdemona.try_equatorial_radius(),
            Ok(Distance::kilometers(27f64))
        );
    }
    #[test]
    fn test_tri_axial_710() {
        assert_eq!(
            Desdemona.radii(),
            (
                Distance::kilometers(27f64),
                Distance::kilometers(27f64),
                Distance::kilometers(27f64)
            )
        );
        assert_eq!(
            DynOrigin::Desdemona.try_radii(),
            Ok((
                Distance::kilometers(27f64),
                Distance::kilometers(27f64),
                Distance::kilometers(27f64)
            ))
        );
    }
    #[test]
    fn test_origin_711() {
        assert_eq!(Juliet.id().0, 711i32);
        assert_eq!(Juliet.to_string(), "Juliet");
    }
    #[test]
    fn test_point_mass_711() {
        assert!(DynOrigin::Juliet.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_711() {
        assert_eq!(Juliet.mean_radius(), Distance::kilometers(42f64));
        assert_eq!(
            DynOrigin::Juliet.try_mean_radius(),
            Ok(Distance::kilometers(42f64))
        );
    }
    #[test]
    fn test_spheroid_711() {
        assert_eq!(Juliet.polar_radius(), Distance::kilometers(42f64));
        assert_eq!(
            DynOrigin::Juliet.try_polar_radius(),
            Ok(Distance::kilometers(42f64))
        );
        assert_eq!(Juliet.equatorial_radius(), Distance::kilometers(42f64));
        assert_eq!(
            DynOrigin::Juliet.try_equatorial_radius(),
            Ok(Distance::kilometers(42f64))
        );
    }
    #[test]
    fn test_tri_axial_711() {
        assert_eq!(
            Juliet.radii(),
            (
                Distance::kilometers(42f64),
                Distance::kilometers(42f64),
                Distance::kilometers(42f64)
            )
        );
        assert_eq!(
            DynOrigin::Juliet.try_radii(),
            Ok((
                Distance::kilometers(42f64),
                Distance::kilometers(42f64),
                Distance::kilometers(42f64)
            ))
        );
    }
    #[test]
    fn test_origin_712() {
        assert_eq!(Portia.id().0, 712i32);
        assert_eq!(Portia.to_string(), "Portia");
    }
    #[test]
    fn test_point_mass_712() {
        assert!(DynOrigin::Portia.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_712() {
        assert_eq!(Portia.mean_radius(), Distance::kilometers(54f64));
        assert_eq!(
            DynOrigin::Portia.try_mean_radius(),
            Ok(Distance::kilometers(54f64))
        );
    }
    #[test]
    fn test_spheroid_712() {
        assert_eq!(Portia.polar_radius(), Distance::kilometers(54f64));
        assert_eq!(
            DynOrigin::Portia.try_polar_radius(),
            Ok(Distance::kilometers(54f64))
        );
        assert_eq!(Portia.equatorial_radius(), Distance::kilometers(54f64));
        assert_eq!(
            DynOrigin::Portia.try_equatorial_radius(),
            Ok(Distance::kilometers(54f64))
        );
    }
    #[test]
    fn test_tri_axial_712() {
        assert_eq!(
            Portia.radii(),
            (
                Distance::kilometers(54f64),
                Distance::kilometers(54f64),
                Distance::kilometers(54f64)
            )
        );
        assert_eq!(
            DynOrigin::Portia.try_radii(),
            Ok((
                Distance::kilometers(54f64),
                Distance::kilometers(54f64),
                Distance::kilometers(54f64)
            ))
        );
    }
    #[test]
    fn test_origin_713() {
        assert_eq!(Rosalind.id().0, 713i32);
        assert_eq!(Rosalind.to_string(), "Rosalind");
    }
    #[test]
    fn test_point_mass_713() {
        assert!(DynOrigin::Rosalind.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_713() {
        assert_eq!(Rosalind.mean_radius(), Distance::kilometers(27f64));
        assert_eq!(
            DynOrigin::Rosalind.try_mean_radius(),
            Ok(Distance::kilometers(27f64))
        );
    }
    #[test]
    fn test_spheroid_713() {
        assert_eq!(Rosalind.polar_radius(), Distance::kilometers(27f64));
        assert_eq!(
            DynOrigin::Rosalind.try_polar_radius(),
            Ok(Distance::kilometers(27f64))
        );
        assert_eq!(Rosalind.equatorial_radius(), Distance::kilometers(27f64));
        assert_eq!(
            DynOrigin::Rosalind.try_equatorial_radius(),
            Ok(Distance::kilometers(27f64))
        );
    }
    #[test]
    fn test_tri_axial_713() {
        assert_eq!(
            Rosalind.radii(),
            (
                Distance::kilometers(27f64),
                Distance::kilometers(27f64),
                Distance::kilometers(27f64)
            )
        );
        assert_eq!(
            DynOrigin::Rosalind.try_radii(),
            Ok((
                Distance::kilometers(27f64),
                Distance::kilometers(27f64),
                Distance::kilometers(27f64)
            ))
        );
    }
    #[test]
    fn test_origin_714() {
        assert_eq!(Belinda.id().0, 714i32);
        assert_eq!(Belinda.to_string(), "Belinda");
    }
    #[test]
    fn test_point_mass_714() {
        assert!(DynOrigin::Belinda.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_714() {
        assert_eq!(Belinda.mean_radius(), Distance::kilometers(33f64));
        assert_eq!(
            DynOrigin::Belinda.try_mean_radius(),
            Ok(Distance::kilometers(33f64))
        );
    }
    #[test]
    fn test_spheroid_714() {
        assert_eq!(Belinda.polar_radius(), Distance::kilometers(33f64));
        assert_eq!(
            DynOrigin::Belinda.try_polar_radius(),
            Ok(Distance::kilometers(33f64))
        );
        assert_eq!(Belinda.equatorial_radius(), Distance::kilometers(33f64));
        assert_eq!(
            DynOrigin::Belinda.try_equatorial_radius(),
            Ok(Distance::kilometers(33f64))
        );
    }
    #[test]
    fn test_tri_axial_714() {
        assert_eq!(
            Belinda.radii(),
            (
                Distance::kilometers(33f64),
                Distance::kilometers(33f64),
                Distance::kilometers(33f64)
            )
        );
        assert_eq!(
            DynOrigin::Belinda.try_radii(),
            Ok((
                Distance::kilometers(33f64),
                Distance::kilometers(33f64),
                Distance::kilometers(33f64)
            ))
        );
    }
    #[test]
    fn test_origin_715() {
        assert_eq!(Puck.id().0, 715i32);
        assert_eq!(Puck.to_string(), "Puck");
    }
    #[test]
    fn test_point_mass_715() {
        assert!(DynOrigin::Puck.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_715() {
        assert_eq!(Puck.mean_radius(), Distance::kilometers(77f64));
        assert_eq!(
            DynOrigin::Puck.try_mean_radius(),
            Ok(Distance::kilometers(77f64))
        );
    }
    #[test]
    fn test_spheroid_715() {
        assert_eq!(Puck.polar_radius(), Distance::kilometers(77f64));
        assert_eq!(
            DynOrigin::Puck.try_polar_radius(),
            Ok(Distance::kilometers(77f64))
        );
        assert_eq!(Puck.equatorial_radius(), Distance::kilometers(77f64));
        assert_eq!(
            DynOrigin::Puck.try_equatorial_radius(),
            Ok(Distance::kilometers(77f64))
        );
    }
    #[test]
    fn test_tri_axial_715() {
        assert_eq!(
            Puck.radii(),
            (
                Distance::kilometers(77f64),
                Distance::kilometers(77f64),
                Distance::kilometers(77f64)
            )
        );
        assert_eq!(
            DynOrigin::Puck.try_radii(),
            Ok((
                Distance::kilometers(77f64),
                Distance::kilometers(77f64),
                Distance::kilometers(77f64)
            ))
        );
    }
    #[test]
    fn test_origin_716() {
        assert_eq!(Caliban.id().0, 716i32);
        assert_eq!(Caliban.to_string(), "Caliban");
    }
    #[test]
    fn test_point_mass_716() {
        assert!(DynOrigin::Caliban.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_716() {
        assert!(DynOrigin::Caliban.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_716() {
        assert!(DynOrigin::Caliban.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_716() {
        assert!(DynOrigin::Caliban.try_polar_radius().is_err());
        assert!(DynOrigin::Caliban.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_717() {
        assert_eq!(Sycorax.id().0, 717i32);
        assert_eq!(Sycorax.to_string(), "Sycorax");
    }
    #[test]
    fn test_point_mass_717() {
        assert!(DynOrigin::Sycorax.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_717() {
        assert!(DynOrigin::Sycorax.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_717() {
        assert!(DynOrigin::Sycorax.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_717() {
        assert!(DynOrigin::Sycorax.try_polar_radius().is_err());
        assert!(DynOrigin::Sycorax.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_718() {
        assert_eq!(Prospero.id().0, 718i32);
        assert_eq!(Prospero.to_string(), "Prospero");
    }
    #[test]
    fn test_point_mass_718() {
        assert!(DynOrigin::Prospero.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_718() {
        assert!(DynOrigin::Prospero.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_718() {
        assert!(DynOrigin::Prospero.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_718() {
        assert!(DynOrigin::Prospero.try_polar_radius().is_err());
        assert!(DynOrigin::Prospero.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_719() {
        assert_eq!(Setebos.id().0, 719i32);
        assert_eq!(Setebos.to_string(), "Setebos");
    }
    #[test]
    fn test_point_mass_719() {
        assert!(DynOrigin::Setebos.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_719() {
        assert!(DynOrigin::Setebos.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_719() {
        assert!(DynOrigin::Setebos.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_719() {
        assert!(DynOrigin::Setebos.try_polar_radius().is_err());
        assert!(DynOrigin::Setebos.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_720() {
        assert_eq!(Stephano.id().0, 720i32);
        assert_eq!(Stephano.to_string(), "Stephano");
    }
    #[test]
    fn test_point_mass_720() {
        assert!(DynOrigin::Stephano.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_720() {
        assert!(DynOrigin::Stephano.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_720() {
        assert!(DynOrigin::Stephano.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_720() {
        assert!(DynOrigin::Stephano.try_polar_radius().is_err());
        assert!(DynOrigin::Stephano.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_721() {
        assert_eq!(Trinculo.id().0, 721i32);
        assert_eq!(Trinculo.to_string(), "Trinculo");
    }
    #[test]
    fn test_point_mass_721() {
        assert!(DynOrigin::Trinculo.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_721() {
        assert!(DynOrigin::Trinculo.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_721() {
        assert!(DynOrigin::Trinculo.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_721() {
        assert!(DynOrigin::Trinculo.try_polar_radius().is_err());
        assert!(DynOrigin::Trinculo.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_722() {
        assert_eq!(Francisco.id().0, 722i32);
        assert_eq!(Francisco.to_string(), "Francisco");
    }
    #[test]
    fn test_point_mass_722() {
        assert!(DynOrigin::Francisco.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_722() {
        assert!(DynOrigin::Francisco.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_722() {
        assert!(DynOrigin::Francisco.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_722() {
        assert!(DynOrigin::Francisco.try_polar_radius().is_err());
        assert!(DynOrigin::Francisco.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_723() {
        assert_eq!(Margaret.id().0, 723i32);
        assert_eq!(Margaret.to_string(), "Margaret");
    }
    #[test]
    fn test_point_mass_723() {
        assert!(DynOrigin::Margaret.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_723() {
        assert!(DynOrigin::Margaret.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_723() {
        assert!(DynOrigin::Margaret.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_723() {
        assert!(DynOrigin::Margaret.try_polar_radius().is_err());
        assert!(DynOrigin::Margaret.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_724() {
        assert_eq!(Ferdinand.id().0, 724i32);
        assert_eq!(Ferdinand.to_string(), "Ferdinand");
    }
    #[test]
    fn test_point_mass_724() {
        assert!(DynOrigin::Ferdinand.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_724() {
        assert!(DynOrigin::Ferdinand.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_724() {
        assert!(DynOrigin::Ferdinand.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_724() {
        assert!(DynOrigin::Ferdinand.try_polar_radius().is_err());
        assert!(DynOrigin::Ferdinand.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_725() {
        assert_eq!(Perdita.id().0, 725i32);
        assert_eq!(Perdita.to_string(), "Perdita");
    }
    #[test]
    fn test_point_mass_725() {
        assert!(DynOrigin::Perdita.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_725() {
        assert!(DynOrigin::Perdita.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_725() {
        assert!(DynOrigin::Perdita.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_725() {
        assert!(DynOrigin::Perdita.try_polar_radius().is_err());
        assert!(DynOrigin::Perdita.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_726() {
        assert_eq!(Mab.id().0, 726i32);
        assert_eq!(Mab.to_string(), "Mab");
    }
    #[test]
    fn test_point_mass_726() {
        assert!(DynOrigin::Mab.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_726() {
        assert!(DynOrigin::Mab.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_726() {
        assert!(DynOrigin::Mab.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_726() {
        assert!(DynOrigin::Mab.try_polar_radius().is_err());
        assert!(DynOrigin::Mab.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_727() {
        assert_eq!(Cupid.id().0, 727i32);
        assert_eq!(Cupid.to_string(), "Cupid");
    }
    #[test]
    fn test_point_mass_727() {
        assert!(DynOrigin::Cupid.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_727() {
        assert!(DynOrigin::Cupid.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_727() {
        assert!(DynOrigin::Cupid.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_727() {
        assert!(DynOrigin::Cupid.try_polar_radius().is_err());
        assert!(DynOrigin::Cupid.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_801() {
        assert_eq!(Triton.id().0, 801i32);
        assert_eq!(Triton.to_string(), "Triton");
    }
    #[test]
    fn test_point_mass_801() {
        assert_eq!(
            Triton.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(1428.495462910464f64)
        );
        assert_eq!(
            DynOrigin::Triton.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(1428.495462910464f64))
        );
    }
    #[test]
    fn test_mean_radius_801() {
        assert_eq!(Triton.mean_radius(), Distance::kilometers(1352.6f64));
        assert_eq!(
            DynOrigin::Triton.try_mean_radius(),
            Ok(Distance::kilometers(1352.6f64))
        );
    }
    #[test]
    fn test_spheroid_801() {
        assert_eq!(Triton.polar_radius(), Distance::kilometers(1352.6f64));
        assert_eq!(
            DynOrigin::Triton.try_polar_radius(),
            Ok(Distance::kilometers(1352.6f64))
        );
        assert_eq!(Triton.equatorial_radius(), Distance::kilometers(1352.6f64));
        assert_eq!(
            DynOrigin::Triton.try_equatorial_radius(),
            Ok(Distance::kilometers(1352.6f64))
        );
    }
    #[test]
    fn test_tri_axial_801() {
        assert_eq!(
            Triton.radii(),
            (
                Distance::kilometers(1352.6f64),
                Distance::kilometers(1352.6f64),
                Distance::kilometers(1352.6f64)
            )
        );
        assert_eq!(
            DynOrigin::Triton.try_radii(),
            Ok((
                Distance::kilometers(1352.6f64),
                Distance::kilometers(1352.6f64),
                Distance::kilometers(1352.6f64)
            ))
        );
    }
    #[test]
    fn test_origin_802() {
        assert_eq!(Nereid.id().0, 802i32);
        assert_eq!(Nereid.to_string(), "Nereid");
    }
    #[test]
    fn test_point_mass_802() {
        assert!(DynOrigin::Nereid.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_802() {
        assert_eq!(Nereid.mean_radius(), Distance::kilometers(170f64));
        assert_eq!(
            DynOrigin::Nereid.try_mean_radius(),
            Ok(Distance::kilometers(170f64))
        );
    }
    #[test]
    fn test_spheroid_802() {
        assert_eq!(Nereid.polar_radius(), Distance::kilometers(170f64));
        assert_eq!(
            DynOrigin::Nereid.try_polar_radius(),
            Ok(Distance::kilometers(170f64))
        );
        assert_eq!(Nereid.equatorial_radius(), Distance::kilometers(170f64));
        assert_eq!(
            DynOrigin::Nereid.try_equatorial_radius(),
            Ok(Distance::kilometers(170f64))
        );
    }
    #[test]
    fn test_tri_axial_802() {
        assert_eq!(
            Nereid.radii(),
            (
                Distance::kilometers(170f64),
                Distance::kilometers(170f64),
                Distance::kilometers(170f64)
            )
        );
        assert_eq!(
            DynOrigin::Nereid.try_radii(),
            Ok((
                Distance::kilometers(170f64),
                Distance::kilometers(170f64),
                Distance::kilometers(170f64)
            ))
        );
    }
    #[test]
    fn test_origin_803() {
        assert_eq!(Naiad.id().0, 803i32);
        assert_eq!(Naiad.to_string(), "Naiad");
    }
    #[test]
    fn test_point_mass_803() {
        assert_eq!(
            Naiad.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(0.008530281246540886f64)
        );
        assert_eq!(
            DynOrigin::Naiad.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(0.008530281246540886f64))
        );
    }
    #[test]
    fn test_mean_radius_803() {
        assert_eq!(Naiad.mean_radius(), Distance::kilometers(29f64));
        assert_eq!(
            DynOrigin::Naiad.try_mean_radius(),
            Ok(Distance::kilometers(29f64))
        );
    }
    #[test]
    fn test_spheroid_803() {
        assert_eq!(Naiad.polar_radius(), Distance::kilometers(29f64));
        assert_eq!(
            DynOrigin::Naiad.try_polar_radius(),
            Ok(Distance::kilometers(29f64))
        );
        assert_eq!(Naiad.equatorial_radius(), Distance::kilometers(29f64));
        assert_eq!(
            DynOrigin::Naiad.try_equatorial_radius(),
            Ok(Distance::kilometers(29f64))
        );
    }
    #[test]
    fn test_tri_axial_803() {
        assert_eq!(
            Naiad.radii(),
            (
                Distance::kilometers(29f64),
                Distance::kilometers(29f64),
                Distance::kilometers(29f64)
            )
        );
        assert_eq!(
            DynOrigin::Naiad.try_radii(),
            Ok((
                Distance::kilometers(29f64),
                Distance::kilometers(29f64),
                Distance::kilometers(29f64)
            ))
        );
    }
    #[test]
    fn test_origin_804() {
        assert_eq!(Thalassa.id().0, 804i32);
        assert_eq!(Thalassa.to_string(), "Thalassa");
    }
    #[test]
    fn test_point_mass_804() {
        assert_eq!(
            Thalassa.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(0.0235887319799217f64)
        );
        assert_eq!(
            DynOrigin::Thalassa.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(0.0235887319799217f64))
        );
    }
    #[test]
    fn test_mean_radius_804() {
        assert_eq!(Thalassa.mean_radius(), Distance::kilometers(40f64));
        assert_eq!(
            DynOrigin::Thalassa.try_mean_radius(),
            Ok(Distance::kilometers(40f64))
        );
    }
    #[test]
    fn test_spheroid_804() {
        assert_eq!(Thalassa.polar_radius(), Distance::kilometers(40f64));
        assert_eq!(
            DynOrigin::Thalassa.try_polar_radius(),
            Ok(Distance::kilometers(40f64))
        );
        assert_eq!(Thalassa.equatorial_radius(), Distance::kilometers(40f64));
        assert_eq!(
            DynOrigin::Thalassa.try_equatorial_radius(),
            Ok(Distance::kilometers(40f64))
        );
    }
    #[test]
    fn test_tri_axial_804() {
        assert_eq!(
            Thalassa.radii(),
            (
                Distance::kilometers(40f64),
                Distance::kilometers(40f64),
                Distance::kilometers(40f64)
            )
        );
        assert_eq!(
            DynOrigin::Thalassa.try_radii(),
            Ok((
                Distance::kilometers(40f64),
                Distance::kilometers(40f64),
                Distance::kilometers(40f64)
            ))
        );
    }
    #[test]
    fn test_origin_805() {
        assert_eq!(Despina.id().0, 805i32);
        assert_eq!(Despina.to_string(), "Despina");
    }
    #[test]
    fn test_point_mass_805() {
        assert_eq!(
            Despina.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(0.1167318403814998f64)
        );
        assert_eq!(
            DynOrigin::Despina.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(0.1167318403814998f64))
        );
    }
    #[test]
    fn test_mean_radius_805() {
        assert_eq!(Despina.mean_radius(), Distance::kilometers(74f64));
        assert_eq!(
            DynOrigin::Despina.try_mean_radius(),
            Ok(Distance::kilometers(74f64))
        );
    }
    #[test]
    fn test_spheroid_805() {
        assert_eq!(Despina.polar_radius(), Distance::kilometers(74f64));
        assert_eq!(
            DynOrigin::Despina.try_polar_radius(),
            Ok(Distance::kilometers(74f64))
        );
        assert_eq!(Despina.equatorial_radius(), Distance::kilometers(74f64));
        assert_eq!(
            DynOrigin::Despina.try_equatorial_radius(),
            Ok(Distance::kilometers(74f64))
        );
    }
    #[test]
    fn test_tri_axial_805() {
        assert_eq!(
            Despina.radii(),
            (
                Distance::kilometers(74f64),
                Distance::kilometers(74f64),
                Distance::kilometers(74f64)
            )
        );
        assert_eq!(
            DynOrigin::Despina.try_radii(),
            Ok((
                Distance::kilometers(74f64),
                Distance::kilometers(74f64),
                Distance::kilometers(74f64)
            ))
        );
    }
    #[test]
    fn test_origin_806() {
        assert_eq!(Galatea.id().0, 806i32);
        assert_eq!(Galatea.to_string(), "Galatea");
    }
    #[test]
    fn test_point_mass_806() {
        assert_eq!(
            Galatea.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(0.189898503906069f64)
        );
        assert_eq!(
            DynOrigin::Galatea.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(0.189898503906069f64))
        );
    }
    #[test]
    fn test_mean_radius_806() {
        assert_eq!(Galatea.mean_radius(), Distance::kilometers(79f64));
        assert_eq!(
            DynOrigin::Galatea.try_mean_radius(),
            Ok(Distance::kilometers(79f64))
        );
    }
    #[test]
    fn test_spheroid_806() {
        assert_eq!(Galatea.polar_radius(), Distance::kilometers(79f64));
        assert_eq!(
            DynOrigin::Galatea.try_polar_radius(),
            Ok(Distance::kilometers(79f64))
        );
        assert_eq!(Galatea.equatorial_radius(), Distance::kilometers(79f64));
        assert_eq!(
            DynOrigin::Galatea.try_equatorial_radius(),
            Ok(Distance::kilometers(79f64))
        );
    }
    #[test]
    fn test_tri_axial_806() {
        assert_eq!(
            Galatea.radii(),
            (
                Distance::kilometers(79f64),
                Distance::kilometers(79f64),
                Distance::kilometers(79f64)
            )
        );
        assert_eq!(
            DynOrigin::Galatea.try_radii(),
            Ok((
                Distance::kilometers(79f64),
                Distance::kilometers(79f64),
                Distance::kilometers(79f64)
            ))
        );
    }
    #[test]
    fn test_origin_807() {
        assert_eq!(Larissa.id().0, 807i32);
        assert_eq!(Larissa.to_string(), "Larissa");
    }
    #[test]
    fn test_point_mass_807() {
        assert_eq!(
            Larissa.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(0.2548437405693583f64)
        );
        assert_eq!(
            DynOrigin::Larissa.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(0.2548437405693583f64))
        );
    }
    #[test]
    fn test_mean_radius_807() {
        assert_eq!(Larissa.mean_radius(), Distance::kilometers(96f64));
        assert_eq!(
            DynOrigin::Larissa.try_mean_radius(),
            Ok(Distance::kilometers(96f64))
        );
    }
    #[test]
    fn test_spheroid_807() {
        assert_eq!(Larissa.polar_radius(), Distance::kilometers(96f64));
        assert_eq!(
            DynOrigin::Larissa.try_polar_radius(),
            Ok(Distance::kilometers(96f64))
        );
        assert_eq!(Larissa.equatorial_radius(), Distance::kilometers(96f64));
        assert_eq!(
            DynOrigin::Larissa.try_equatorial_radius(),
            Ok(Distance::kilometers(96f64))
        );
    }
    #[test]
    fn test_tri_axial_807() {
        assert_eq!(
            Larissa.radii(),
            (
                Distance::kilometers(96f64),
                Distance::kilometers(96f64),
                Distance::kilometers(96f64)
            )
        );
        assert_eq!(
            DynOrigin::Larissa.try_radii(),
            Ok((
                Distance::kilometers(96f64),
                Distance::kilometers(96f64),
                Distance::kilometers(96f64)
            ))
        );
    }
    #[test]
    fn test_origin_808() {
        assert_eq!(Proteus.id().0, 808i32);
        assert_eq!(Proteus.to_string(), "Proteus");
    }
    #[test]
    fn test_point_mass_808() {
        assert_eq!(
            Proteus.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(2.583422379120727f64)
        );
        assert_eq!(
            DynOrigin::Proteus.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(2.583422379120727f64))
        );
    }
    #[test]
    fn test_mean_radius_808() {
        assert_eq!(Proteus.mean_radius(), Distance::kilometers(208f64));
        assert_eq!(
            DynOrigin::Proteus.try_mean_radius(),
            Ok(Distance::kilometers(208f64))
        );
    }
    #[test]
    fn test_spheroid_808() {
        assert!(DynOrigin::Proteus.try_polar_radius().is_err());
        assert!(DynOrigin::Proteus.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_tri_axial_808() {
        assert_eq!(
            Proteus.radii(),
            (
                Distance::kilometers(218f64),
                Distance::kilometers(208f64),
                Distance::kilometers(201f64)
            )
        );
        assert_eq!(
            DynOrigin::Proteus.try_radii(),
            Ok((
                Distance::kilometers(218f64),
                Distance::kilometers(208f64),
                Distance::kilometers(201f64)
            ))
        );
    }
    #[test]
    fn test_origin_809() {
        assert_eq!(Halimede.id().0, 809i32);
        assert_eq!(Halimede.to_string(), "Halimede");
    }
    #[test]
    fn test_point_mass_809() {
        assert!(DynOrigin::Halimede.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_809() {
        assert!(DynOrigin::Halimede.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_809() {
        assert!(DynOrigin::Halimede.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_809() {
        assert!(DynOrigin::Halimede.try_polar_radius().is_err());
        assert!(DynOrigin::Halimede.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_810() {
        assert_eq!(Psamathe.id().0, 810i32);
        assert_eq!(Psamathe.to_string(), "Psamathe");
    }
    #[test]
    fn test_point_mass_810() {
        assert!(DynOrigin::Psamathe.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_810() {
        assert!(DynOrigin::Psamathe.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_810() {
        assert!(DynOrigin::Psamathe.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_810() {
        assert!(DynOrigin::Psamathe.try_polar_radius().is_err());
        assert!(DynOrigin::Psamathe.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_811() {
        assert_eq!(Sao.id().0, 811i32);
        assert_eq!(Sao.to_string(), "Sao");
    }
    #[test]
    fn test_point_mass_811() {
        assert!(DynOrigin::Sao.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_811() {
        assert!(DynOrigin::Sao.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_811() {
        assert!(DynOrigin::Sao.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_811() {
        assert!(DynOrigin::Sao.try_polar_radius().is_err());
        assert!(DynOrigin::Sao.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_812() {
        assert_eq!(Laomedeia.id().0, 812i32);
        assert_eq!(Laomedeia.to_string(), "Laomedeia");
    }
    #[test]
    fn test_point_mass_812() {
        assert!(DynOrigin::Laomedeia.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_812() {
        assert!(DynOrigin::Laomedeia.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_812() {
        assert!(DynOrigin::Laomedeia.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_812() {
        assert!(DynOrigin::Laomedeia.try_polar_radius().is_err());
        assert!(DynOrigin::Laomedeia.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_813() {
        assert_eq!(Neso.id().0, 813i32);
        assert_eq!(Neso.to_string(), "Neso");
    }
    #[test]
    fn test_point_mass_813() {
        assert!(DynOrigin::Neso.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_813() {
        assert!(DynOrigin::Neso.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_813() {
        assert!(DynOrigin::Neso.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_813() {
        assert!(DynOrigin::Neso.try_polar_radius().is_err());
        assert!(DynOrigin::Neso.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_901() {
        assert_eq!(Charon.id().0, 901i32);
        assert_eq!(Charon.to_string(), "Charon");
    }
    #[test]
    fn test_point_mass_901() {
        assert_eq!(
            Charon.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(105.8799888601881f64)
        );
        assert_eq!(
            DynOrigin::Charon.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(105.8799888601881f64))
        );
    }
    #[test]
    fn test_mean_radius_901() {
        assert_eq!(Charon.mean_radius(), Distance::kilometers(606f64));
        assert_eq!(
            DynOrigin::Charon.try_mean_radius(),
            Ok(Distance::kilometers(606f64))
        );
    }
    #[test]
    fn test_spheroid_901() {
        assert_eq!(Charon.polar_radius(), Distance::kilometers(606f64));
        assert_eq!(
            DynOrigin::Charon.try_polar_radius(),
            Ok(Distance::kilometers(606f64))
        );
        assert_eq!(Charon.equatorial_radius(), Distance::kilometers(606f64));
        assert_eq!(
            DynOrigin::Charon.try_equatorial_radius(),
            Ok(Distance::kilometers(606f64))
        );
    }
    #[test]
    fn test_tri_axial_901() {
        assert_eq!(
            Charon.radii(),
            (
                Distance::kilometers(606f64),
                Distance::kilometers(606f64),
                Distance::kilometers(606f64)
            )
        );
        assert_eq!(
            DynOrigin::Charon.try_radii(),
            Ok((
                Distance::kilometers(606f64),
                Distance::kilometers(606f64),
                Distance::kilometers(606f64)
            ))
        );
    }
    #[test]
    fn test_origin_902() {
        assert_eq!(Nix.id().0, 902i32);
        assert_eq!(Nix.to_string(), "Nix");
    }
    #[test]
    fn test_point_mass_902() {
        assert_eq!(
            Nix.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(0.00304817564816976f64)
        );
        assert_eq!(
            DynOrigin::Nix.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(0.00304817564816976f64))
        );
    }
    #[test]
    fn test_mean_radius_902() {
        assert!(DynOrigin::Nix.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_902() {
        assert!(DynOrigin::Nix.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_902() {
        assert!(DynOrigin::Nix.try_polar_radius().is_err());
        assert!(DynOrigin::Nix.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_903() {
        assert_eq!(Hydra.id().0, 903i32);
        assert_eq!(Hydra.to_string(), "Hydra");
    }
    #[test]
    fn test_point_mass_903() {
        assert_eq!(
            Hydra.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(0.003211039206155255f64)
        );
        assert_eq!(
            DynOrigin::Hydra.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(0.003211039206155255f64))
        );
    }
    #[test]
    fn test_mean_radius_903() {
        assert!(DynOrigin::Hydra.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_903() {
        assert!(DynOrigin::Hydra.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_903() {
        assert!(DynOrigin::Hydra.try_polar_radius().is_err());
        assert!(DynOrigin::Hydra.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_904() {
        assert_eq!(Kerberos.id().0, 904i32);
        assert_eq!(Kerberos.to_string(), "Kerberos");
    }
    #[test]
    fn test_point_mass_904() {
        assert_eq!(
            Kerberos.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(0.001110040850536676f64)
        );
        assert_eq!(
            DynOrigin::Kerberos.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(0.001110040850536676f64))
        );
    }
    #[test]
    fn test_mean_radius_904() {
        assert!(DynOrigin::Kerberos.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_904() {
        assert!(DynOrigin::Kerberos.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_904() {
        assert!(DynOrigin::Kerberos.try_polar_radius().is_err());
        assert!(DynOrigin::Kerberos.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_905() {
        assert_eq!(Styx.id().0, 905i32);
        assert_eq!(Styx.to_string(), "Styx");
    }
    #[test]
    fn test_point_mass_905() {
        assert_eq!(
            Styx.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(0f64)
        );
        assert_eq!(
            DynOrigin::Styx.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(0f64))
        );
    }
    #[test]
    fn test_mean_radius_905() {
        assert!(DynOrigin::Styx.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_905() {
        assert!(DynOrigin::Styx.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_905() {
        assert!(DynOrigin::Styx.try_polar_radius().is_err());
        assert!(DynOrigin::Styx.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_9511010() {
        assert_eq!(Gaspra.id().0, 9511010i32);
        assert_eq!(Gaspra.to_string(), "Gaspra");
    }
    #[test]
    fn test_point_mass_9511010() {
        assert!(DynOrigin::Gaspra.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_9511010() {
        assert_eq!(Gaspra.mean_radius(), Distance::kilometers(6.1f64));
        assert_eq!(
            DynOrigin::Gaspra.try_mean_radius(),
            Ok(Distance::kilometers(6.1f64))
        );
    }
    #[test]
    fn test_spheroid_9511010() {
        assert!(DynOrigin::Gaspra.try_polar_radius().is_err());
        assert!(DynOrigin::Gaspra.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_tri_axial_9511010() {
        assert_eq!(
            Gaspra.radii(),
            (
                Distance::kilometers(9.1f64),
                Distance::kilometers(5.2f64),
                Distance::kilometers(4.4f64)
            )
        );
        assert_eq!(
            DynOrigin::Gaspra.try_radii(),
            Ok((
                Distance::kilometers(9.1f64),
                Distance::kilometers(5.2f64),
                Distance::kilometers(4.4f64)
            ))
        );
    }
    #[test]
    fn test_origin_2431010() {
        assert_eq!(Ida.id().0, 2431010i32);
        assert_eq!(Ida.to_string(), "Ida");
    }
    #[test]
    fn test_point_mass_2431010() {
        assert!(DynOrigin::Ida.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_2431010() {
        assert_eq!(Ida.mean_radius(), Distance::kilometers(15.65f64));
        assert_eq!(
            DynOrigin::Ida.try_mean_radius(),
            Ok(Distance::kilometers(15.65f64))
        );
    }
    #[test]
    fn test_spheroid_2431010() {
        assert!(DynOrigin::Ida.try_polar_radius().is_err());
        assert!(DynOrigin::Ida.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_tri_axial_2431010() {
        assert_eq!(
            Ida.radii(),
            (
                Distance::kilometers(26.8f64),
                Distance::kilometers(12f64),
                Distance::kilometers(7.6f64)
            )
        );
        assert_eq!(
            DynOrigin::Ida.try_radii(),
            Ok((
                Distance::kilometers(26.8f64),
                Distance::kilometers(12f64),
                Distance::kilometers(7.6f64)
            ))
        );
    }
    #[test]
    fn test_origin_2431011() {
        assert_eq!(Dactyl.id().0, 2431011i32);
        assert_eq!(Dactyl.to_string(), "Dactyl");
    }
    #[test]
    fn test_point_mass_2431011() {
        assert!(DynOrigin::Dactyl.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_2431011() {
        assert!(DynOrigin::Dactyl.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_2431011() {
        assert!(DynOrigin::Dactyl.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_2431011() {
        assert!(DynOrigin::Dactyl.try_polar_radius().is_err());
        assert!(DynOrigin::Dactyl.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_2000001() {
        assert_eq!(Ceres.id().0, 2000001i32);
        assert_eq!(Ceres.to_string(), "Ceres");
    }
    #[test]
    fn test_point_mass_2000001() {
        assert_eq!(
            Ceres.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(62.62888864440993f64)
        );
        assert_eq!(
            DynOrigin::Ceres.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(62.62888864440993f64))
        );
    }
    #[test]
    fn test_mean_radius_2000001() {
        assert_eq!(Ceres.mean_radius(), Distance::kilometers(470f64));
        assert_eq!(
            DynOrigin::Ceres.try_mean_radius(),
            Ok(Distance::kilometers(470f64))
        );
    }
    #[test]
    fn test_spheroid_2000001() {
        assert_eq!(Ceres.polar_radius(), Distance::kilometers(446f64));
        assert_eq!(
            DynOrigin::Ceres.try_polar_radius(),
            Ok(Distance::kilometers(446f64))
        );
        assert_eq!(Ceres.equatorial_radius(), Distance::kilometers(487.3f64));
        assert_eq!(
            DynOrigin::Ceres.try_equatorial_radius(),
            Ok(Distance::kilometers(487.3f64))
        );
    }
    #[test]
    fn test_tri_axial_2000001() {
        assert_eq!(
            Ceres.radii(),
            (
                Distance::kilometers(487.3f64),
                Distance::kilometers(487.3f64),
                Distance::kilometers(446f64)
            )
        );
        assert_eq!(
            DynOrigin::Ceres.try_radii(),
            Ok((
                Distance::kilometers(487.3f64),
                Distance::kilometers(487.3f64),
                Distance::kilometers(446f64)
            ))
        );
    }
    #[test]
    fn test_origin_2000002() {
        assert_eq!(Pallas.id().0, 2000002i32);
        assert_eq!(Pallas.to_string(), "Pallas");
    }
    #[test]
    fn test_point_mass_2000002() {
        assert_eq!(
            Pallas.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(13.665878145967422f64)
        );
        assert_eq!(
            DynOrigin::Pallas.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(13.665878145967422f64))
        );
    }
    #[test]
    fn test_mean_radius_2000002() {
        assert!(DynOrigin::Pallas.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_2000002() {
        assert!(DynOrigin::Pallas.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_2000002() {
        assert!(DynOrigin::Pallas.try_polar_radius().is_err());
        assert!(DynOrigin::Pallas.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_2000004() {
        assert_eq!(Vesta.id().0, 2000004i32);
        assert_eq!(Vesta.to_string(), "Vesta");
    }
    #[test]
    fn test_point_mass_2000004() {
        assert_eq!(
            Vesta.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(17.288232879171513f64)
        );
        assert_eq!(
            DynOrigin::Vesta.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(17.288232879171513f64))
        );
    }
    #[test]
    fn test_mean_radius_2000004() {
        assert!(DynOrigin::Vesta.try_mean_radius().is_err());
    }
    #[test]
    fn test_spheroid_2000004() {
        assert!(DynOrigin::Vesta.try_polar_radius().is_err());
        assert!(DynOrigin::Vesta.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_tri_axial_2000004() {
        assert_eq!(
            Vesta.radii(),
            (
                Distance::kilometers(289f64),
                Distance::kilometers(280f64),
                Distance::kilometers(229f64)
            )
        );
        assert_eq!(
            DynOrigin::Vesta.try_radii(),
            Ok((
                Distance::kilometers(289f64),
                Distance::kilometers(280f64),
                Distance::kilometers(229f64)
            ))
        );
    }
    #[test]
    fn test_origin_2000016() {
        assert_eq!(Psyche.id().0, 2000016i32);
        assert_eq!(Psyche.to_string(), "Psyche");
    }
    #[test]
    fn test_point_mass_2000016() {
        assert_eq!(
            Psyche.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(1.5896582441709424f64)
        );
        assert_eq!(
            DynOrigin::Psyche.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(1.5896582441709424f64))
        );
    }
    #[test]
    fn test_mean_radius_2000016() {
        assert_eq!(Psyche.mean_radius(), Distance::kilometers(113f64));
        assert_eq!(
            DynOrigin::Psyche.try_mean_radius(),
            Ok(Distance::kilometers(113f64))
        );
    }
    #[test]
    fn test_spheroid_2000016() {
        assert!(DynOrigin::Psyche.try_polar_radius().is_err());
        assert!(DynOrigin::Psyche.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_tri_axial_2000016() {
        assert_eq!(
            Psyche.radii(),
            (
                Distance::kilometers(139.5f64),
                Distance::kilometers(116f64),
                Distance::kilometers(94.5f64)
            )
        );
        assert_eq!(
            DynOrigin::Psyche.try_radii(),
            Ok((
                Distance::kilometers(139.5f64),
                Distance::kilometers(116f64),
                Distance::kilometers(94.5f64)
            ))
        );
    }
    #[test]
    fn test_origin_2000021() {
        assert_eq!(Lutetia.id().0, 2000021i32);
        assert_eq!(Lutetia.to_string(), "Lutetia");
    }
    #[test]
    fn test_point_mass_2000021() {
        assert!(DynOrigin::Lutetia.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_2000021() {
        assert_eq!(Lutetia.mean_radius(), Distance::kilometers(52.5f64));
        assert_eq!(
            DynOrigin::Lutetia.try_mean_radius(),
            Ok(Distance::kilometers(52.5f64))
        );
    }
    #[test]
    fn test_spheroid_2000021() {
        assert!(DynOrigin::Lutetia.try_polar_radius().is_err());
        assert!(DynOrigin::Lutetia.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_tri_axial_2000021() {
        assert_eq!(
            Lutetia.radii(),
            (
                Distance::kilometers(62f64),
                Distance::kilometers(50.5f64),
                Distance::kilometers(46.5f64)
            )
        );
        assert_eq!(
            DynOrigin::Lutetia.try_radii(),
            Ok((
                Distance::kilometers(62f64),
                Distance::kilometers(50.5f64),
                Distance::kilometers(46.5f64)
            ))
        );
    }
    #[test]
    fn test_origin_2000216() {
        assert_eq!(Kleopatra.id().0, 2000216i32);
        assert_eq!(Kleopatra.to_string(), "Kleopatra");
    }
    #[test]
    fn test_point_mass_2000216() {
        assert!(DynOrigin::Kleopatra.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_2000216() {
        assert!(DynOrigin::Kleopatra.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_2000216() {
        assert!(DynOrigin::Kleopatra.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_2000216() {
        assert!(DynOrigin::Kleopatra.try_polar_radius().is_err());
        assert!(DynOrigin::Kleopatra.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_2000433() {
        assert_eq!(Eros.id().0, 2000433i32);
        assert_eq!(Eros.to_string(), "Eros");
    }
    #[test]
    fn test_point_mass_2000433() {
        assert_eq!(
            Eros.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(0.0004463f64)
        );
        assert_eq!(
            DynOrigin::Eros.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(0.0004463f64))
        );
    }
    #[test]
    fn test_mean_radius_2000433() {
        assert_eq!(Eros.mean_radius(), Distance::kilometers(8.45f64));
        assert_eq!(
            DynOrigin::Eros.try_mean_radius(),
            Ok(Distance::kilometers(8.45f64))
        );
    }
    #[test]
    fn test_spheroid_2000433() {
        assert!(DynOrigin::Eros.try_polar_radius().is_err());
        assert!(DynOrigin::Eros.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_tri_axial_2000433() {
        assert_eq!(
            Eros.radii(),
            (
                Distance::kilometers(17f64),
                Distance::kilometers(5.5f64),
                Distance::kilometers(5.5f64)
            )
        );
        assert_eq!(
            DynOrigin::Eros.try_radii(),
            Ok((
                Distance::kilometers(17f64),
                Distance::kilometers(5.5f64),
                Distance::kilometers(5.5f64)
            ))
        );
    }
    #[test]
    fn test_origin_2000511() {
        assert_eq!(Davida.id().0, 2000511i32);
        assert_eq!(Davida.to_string(), "Davida");
    }
    #[test]
    fn test_point_mass_2000511() {
        assert_eq!(
            Davida.gravitational_parameter(),
            GravitationalParameter::km3_per_s2(3.8944831481705644f64)
        );
        assert_eq!(
            DynOrigin::Davida.try_gravitational_parameter(),
            Ok(GravitationalParameter::km3_per_s2(3.8944831481705644f64))
        );
    }
    #[test]
    fn test_mean_radius_2000511() {
        assert_eq!(Davida.mean_radius(), Distance::kilometers(150f64));
        assert_eq!(
            DynOrigin::Davida.try_mean_radius(),
            Ok(Distance::kilometers(150f64))
        );
    }
    #[test]
    fn test_spheroid_2000511() {
        assert!(DynOrigin::Davida.try_polar_radius().is_err());
        assert!(DynOrigin::Davida.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_tri_axial_2000511() {
        assert_eq!(
            Davida.radii(),
            (
                Distance::kilometers(180f64),
                Distance::kilometers(147f64),
                Distance::kilometers(127f64)
            )
        );
        assert_eq!(
            DynOrigin::Davida.try_radii(),
            Ok((
                Distance::kilometers(180f64),
                Distance::kilometers(147f64),
                Distance::kilometers(127f64)
            ))
        );
    }
    #[test]
    fn test_origin_2000253() {
        assert_eq!(Mathilde.id().0, 2000253i32);
        assert_eq!(Mathilde.to_string(), "Mathilde");
    }
    #[test]
    fn test_point_mass_2000253() {
        assert!(DynOrigin::Mathilde.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_2000253() {
        assert_eq!(Mathilde.mean_radius(), Distance::kilometers(26.5f64));
        assert_eq!(
            DynOrigin::Mathilde.try_mean_radius(),
            Ok(Distance::kilometers(26.5f64))
        );
    }
    #[test]
    fn test_spheroid_2000253() {
        assert!(DynOrigin::Mathilde.try_polar_radius().is_err());
        assert!(DynOrigin::Mathilde.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_tri_axial_2000253() {
        assert_eq!(
            Mathilde.radii(),
            (
                Distance::kilometers(33f64),
                Distance::kilometers(24f64),
                Distance::kilometers(23f64)
            )
        );
        assert_eq!(
            DynOrigin::Mathilde.try_radii(),
            Ok((
                Distance::kilometers(33f64),
                Distance::kilometers(24f64),
                Distance::kilometers(23f64)
            ))
        );
    }
    #[test]
    fn test_origin_2002867() {
        assert_eq!(Steins.id().0, 2002867i32);
        assert_eq!(Steins.to_string(), "Steins");
    }
    #[test]
    fn test_point_mass_2002867() {
        assert!(DynOrigin::Steins.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_2002867() {
        assert_eq!(Steins.mean_radius(), Distance::kilometers(2.7f64));
        assert_eq!(
            DynOrigin::Steins.try_mean_radius(),
            Ok(Distance::kilometers(2.7f64))
        );
    }
    #[test]
    fn test_spheroid_2002867() {
        assert!(DynOrigin::Steins.try_polar_radius().is_err());
        assert!(DynOrigin::Steins.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_tri_axial_2002867() {
        assert_eq!(
            Steins.radii(),
            (
                Distance::kilometers(3.24f64),
                Distance::kilometers(2.73f64),
                Distance::kilometers(2.04f64)
            )
        );
        assert_eq!(
            DynOrigin::Steins.try_radii(),
            Ok((
                Distance::kilometers(3.24f64),
                Distance::kilometers(2.73f64),
                Distance::kilometers(2.04f64)
            ))
        );
    }
    #[test]
    fn test_origin_2009969() {
        assert_eq!(Braille.id().0, 2009969i32);
        assert_eq!(Braille.to_string(), "Braille");
    }
    #[test]
    fn test_point_mass_2009969() {
        assert!(DynOrigin::Braille.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_2009969() {
        assert!(DynOrigin::Braille.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_2009969() {
        assert!(DynOrigin::Braille.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_2009969() {
        assert!(DynOrigin::Braille.try_polar_radius().is_err());
        assert!(DynOrigin::Braille.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_2004015() {
        assert_eq!(WilsonHarrington.id().0, 2004015i32);
        assert_eq!(WilsonHarrington.to_string(), "Wilson-Harrington");
    }
    #[test]
    fn test_point_mass_2004015() {
        assert!(
            DynOrigin::WilsonHarrington
                .try_gravitational_parameter()
                .is_err()
        );
    }
    #[test]
    fn test_mean_radius_2004015() {
        assert!(DynOrigin::WilsonHarrington.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_2004015() {
        assert!(DynOrigin::WilsonHarrington.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_2004015() {
        assert!(DynOrigin::WilsonHarrington.try_polar_radius().is_err());
        assert!(DynOrigin::WilsonHarrington.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_origin_2004179() {
        assert_eq!(Toutatis.id().0, 2004179i32);
        assert_eq!(Toutatis.to_string(), "Toutatis");
    }
    #[test]
    fn test_point_mass_2004179() {
        assert!(DynOrigin::Toutatis.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_2004179() {
        assert!(DynOrigin::Toutatis.try_mean_radius().is_err());
    }
    #[test]
    fn test_spheroid_2004179() {
        assert!(DynOrigin::Toutatis.try_polar_radius().is_err());
        assert!(DynOrigin::Toutatis.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_tri_axial_2004179() {
        assert_eq!(
            Toutatis.radii(),
            (
                Distance::kilometers(2.13f64),
                Distance::kilometers(1.015f64),
                Distance::kilometers(0.85f64)
            )
        );
        assert_eq!(
            DynOrigin::Toutatis.try_radii(),
            Ok((
                Distance::kilometers(2.13f64),
                Distance::kilometers(1.015f64),
                Distance::kilometers(0.85f64)
            ))
        );
    }
    #[test]
    fn test_origin_2025143() {
        assert_eq!(Itokawa.id().0, 2025143i32);
        assert_eq!(Itokawa.to_string(), "Itokawa");
    }
    #[test]
    fn test_point_mass_2025143() {
        assert!(DynOrigin::Itokawa.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_2025143() {
        assert!(DynOrigin::Itokawa.try_mean_radius().is_err());
    }
    #[test]
    fn test_spheroid_2025143() {
        assert!(DynOrigin::Itokawa.try_polar_radius().is_err());
        assert!(DynOrigin::Itokawa.try_equatorial_radius().is_err());
    }
    #[test]
    fn test_tri_axial_2025143() {
        assert_eq!(
            Itokawa.radii(),
            (
                Distance::kilometers(0.268f64),
                Distance::kilometers(0.147f64),
                Distance::kilometers(0.104f64)
            )
        );
        assert_eq!(
            DynOrigin::Itokawa.try_radii(),
            Ok((
                Distance::kilometers(0.268f64),
                Distance::kilometers(0.147f64),
                Distance::kilometers(0.104f64)
            ))
        );
    }
    #[test]
    fn test_origin_2101955() {
        assert_eq!(Bennu.id().0, 2101955i32);
        assert_eq!(Bennu.to_string(), "Bennu");
    }
    #[test]
    fn test_point_mass_2101955() {
        assert!(DynOrigin::Bennu.try_gravitational_parameter().is_err());
    }
    #[test]
    fn test_mean_radius_2101955() {
        assert!(DynOrigin::Bennu.try_mean_radius().is_err());
    }
    #[test]
    fn test_tri_axial_2101955() {
        assert!(DynOrigin::Bennu.try_radii().is_err());
    }
    #[test]
    fn test_spheroid_2101955() {
        assert!(DynOrigin::Bennu.try_polar_radius().is_err());
        assert!(DynOrigin::Bennu.try_equatorial_radius().is_err());
    }
}
