/*
 * Copyright (c) 2023. Helge Eichhorn and the LOX contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */

use lazy_static::lazy_static;
use std::collections::HashSet;
use std::fs;
use std::path::{Path, PathBuf};
use std::process::Command;

use proc_macro2::{Ident, TokenStream};
use quote::{format_ident, quote};

use lox_io::spice::Kernel;
use naif_ids::{Body, BARYCENTERS, MINOR_BODIES, PLANETS, SATELLITES, SUN};

use crate::rotational_elements::{CoefficientKernel, RotationalElements};

mod naif_ids;
mod rotational_elements;

type Generator = fn(
    imports: &mut HashSet<Ident>,
    code: &mut TokenStream,
    tests: &mut TokenStream,
    ident: &Ident,
    id: &i32,
    data: &Data,
);

struct Data {
    pck: Kernel,
    gm: Kernel,
}

pub fn main() {
    let pck = Kernel::from_string(include_str!("../../../data/pck00011.tpc"))
        .expect("parsing should succeed");
    let gm = Kernel::from_string(include_str!("../../../data/gm_de440.tpc"))
        .expect("parsing should succeed");
    let data = Data { pck, gm };
    let bodies: [(&str, Vec<Body>, Vec<Generator>); 5] = [
        (
            "sun",
            Vec::from(SUN),
            vec![point_mass, spheroid, rotational_elements],
        ),
        ("barycenters", Vec::from(BARYCENTERS), vec![point_mass]),
        (
            "planets",
            Vec::from(PLANETS),
            vec![point_mass, spheroid, rotational_elements],
        ),
        (
            "satellites",
            Vec::from(SATELLITES),
            vec![point_mass, tri_axial, rotational_elements],
        ),
        (
            "minor",
            Vec::from(MINOR_BODIES),
            vec![point_mass, tri_axial, rotational_elements],
        ),
    ];
    bodies
        .iter()
        .for_each(|(file, bodies, generators)| write_file(file, bodies, generators, &data));
}

const COPYRIGHT_NOTICE: &str = "/*
 * Copyright (c) 2023. Helge Eichhorn and the LOX contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, you can obtain one at http://mozilla.org/MPL/2.0/.
 */\n\n";

const AUTO_GENERATION_NOTICE: &str = "// Auto-generated by `lox_gen`. Do not edit!\n\n";

lazy_static! {
    static ref TARGET_DIR: PathBuf = {
        let parent = Path::new(file!()).parent().unwrap();
        parent.join(Path::new("../../../crates/lox_core/src/bodies/generated/"))
    };
}

fn write_file(file: &str, bodies: &[Body], generators: &[Generator], data: &Data) {
    let mut code = String::from(COPYRIGHT_NOTICE);
    code.push_str(AUTO_GENERATION_NOTICE);
    code.push_str(&generate_code(bodies, generators, data));

    let out = TARGET_DIR.join(format!("{}.rs", file));
    fs::write(&out, code).expect("file should be writeable");

    Command::new("rustfmt")
        .args([out.to_str().unwrap()])
        .status()
        .expect("formatting should work");
}

fn generate_code(bodies: &[Body], generators: &[Generator], data: &Data) -> String {
    let mut imports: HashSet<Ident> = HashSet::new();
    let mut code = quote!();
    let mut tests = quote!();

    bodies.iter().for_each(|(id, name)| {
        let ident = format_ident!("{}", name);
        generators
            .iter()
            .for_each(|generator| generator(&mut imports, &mut code, &mut tests, &ident, id, data))
    });

    let imports_iter = imports.iter();
    let module = quote! {
        use crate::bodies::{#(#imports_iter),*};

        #code

        #[cfg(test)]
        #[allow(clippy::approx_constant)] // at least one parsed constant is close to TAU
        mod tests {
            use crate::bodies::*;

            #tests
        }
    };
    module.to_string()
}

fn spheroid(
    imports: &mut HashSet<Ident>,
    code: &mut TokenStream,
    tests: &mut TokenStream,
    ident: &Ident,
    id: &i32,
    data: &Data,
) {
    let radii = format!("BODY{id}_RADII");
    if let Some(radii) = data.pck.get_double_array(&radii) {
        let equatorial = radii.first().expect("radius should be here");
        let polar = radii.get(2).expect("radius should be here");
        let mean = (2.0 * equatorial + polar) / 3.0;

        *code = quote! {
            #code

            impl Ellipsoid for #ident {
                fn polar_radius() -> f64 {
                    #polar
                }
                fn mean_radius() -> f64 {
                    #mean
                }
            }

            impl Spheroid for #ident {
                fn equatorial_radius() -> f64 {
                    #equatorial
                }
            }
        };

        let test_name = format_ident!("test_spheroid_{}", *id as u32);

        *tests = quote! {
            #tests

            #[test]
            fn #test_name() {
                assert_eq!(#ident::polar_radius(), #polar);
                assert_eq!(#ident::mean_radius(), #mean);
                assert_eq!(#ident::equatorial_radius(), #equatorial);
            }
        };

        // Imports are added after any early returns or panics, guaranteeing that the trait is
        // implemented for ident and avoiding unused imports.
        imports.extend([
            ident.clone(),
            format_ident!("Ellipsoid"),
            format_ident!("Spheroid"),
        ]);
    }
}

fn tri_axial(
    imports: &mut HashSet<Ident>,
    code: &mut TokenStream,
    tests: &mut TokenStream,
    ident: &Ident,
    id: &i32,
    data: &Data,
) {
    let radii = format!("BODY{id}_RADII");
    if let Some(radii) = data.pck.get_double_array(&radii) {
        let subplanetary = radii.first().expect("radius should be here");
        let along_orbit = radii.get(1).expect("radius should be here");
        let polar = radii.get(2).expect("radius should be here");
        let mean = (subplanetary + along_orbit + polar) / 3.0;

        *code = quote! {
            #code

            impl Ellipsoid for #ident {
                fn polar_radius() -> f64 {
                    #polar
                }
                fn mean_radius() -> f64 {
                    #mean
                }
            }

            impl TriAxial for #ident {
                fn subplanetary_radius() -> f64 {
                    #subplanetary
                }
                fn along_orbit_radius() -> f64 {
                    #along_orbit
                }
            }
        };

        let test_name = format_ident!("test_tri_axial_{}", *id as u32);

        *tests = quote! {
            #tests

            #[test]
            fn #test_name() {
                assert_eq!(#ident::polar_radius(), #polar);
                assert_eq!(#ident::mean_radius(), #mean);
                assert_eq!(#ident::subplanetary_radius(), #subplanetary);
                assert_eq!(#ident::along_orbit_radius(), #along_orbit);
            }
        };

        // Imports are added after any early returns or panics, guaranteeing that the trait is
        // implemented for ident and avoiding unused imports.
        imports.extend([
            ident.clone(),
            format_ident!("Ellipsoid"),
            format_ident!("TriAxial"),
        ]);
    }
}

fn point_mass(
    imports: &mut HashSet<Ident>,
    code: &mut TokenStream,
    tests: &mut TokenStream,
    ident: &Ident,
    id: &i32,
    data: &Data,
) {
    let key = format!("BODY{id}_GM");
    if let Some(gm) = data.gm.get_double_array(&key) {
        let gm = gm.first().unwrap();
        *code = quote! {
            #code

            impl PointMass for #ident {
                fn gravitational_parameter() -> f64 {
                    #gm
                }
            }
        };

        let test_name = format_ident!("test_point_mass_{}", *id as u32);

        *tests = quote! {
            #tests

            #[test]
            fn #test_name() {
                assert_eq!(#ident::gravitational_parameter(), #gm);
            }
        };

        // Imports are added after any early returns or panics, guaranteeing that the trait is
        // implemented for ident and avoiding unused imports.
        imports.extend([ident.clone(), format_ident!("PointMass")]);
    };
}

/// Generates implementations for [lox_core::bodies::RotationalElements].
fn rotational_elements(
    imports: &mut HashSet<Ident>,
    code: &mut TokenStream,
    tests: &mut TokenStream,
    ident: &Ident,
    id: &i32,
    data: &Data,
) {
    let elements = match RotationalElements::parse(*id as u32, ident, CoefficientKernel(&data.pck))
    {
        Ok(elements) => elements,
        Err(err) => panic!("failed to parse rotational elements for {}: {}", ident, err),
    };

    // Imports are added after any early returns or panics, guaranteeing that the trait is
    // implemented for ident and avoiding unused imports.
    imports.extend([
        ident.clone(),
        format_ident!("RotationalElements"),
        format_ident!("PolynomialCoefficients"),
        format_ident!("NutationPrecessionCoefficients"),
    ]);
    code.extend(elements.code_tokens());
    tests.extend(elements.test_tokens());
}
