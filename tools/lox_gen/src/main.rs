use std::fs;
use std::path::Path;
use std::process::Command;

use proc_macro2::{Ident, TokenStream};
use quote::{format_ident, quote};

use lox_io::spice::Kernel;
use naif_ids::{BARYCENTERS, PLANETS, SATELLITES};

mod naif_ids;

type Generator = fn(&Kernel, &Kernel) -> TokenStream;

pub fn main() {
    let pck = Kernel::from_string(include_str!("../../../data/pck00011.tpc"))
        .expect("parsing should succeed");
    let gm = Kernel::from_string(include_str!("../../../data/gm_de440.tpc"))
        .expect("parsing should succeed");
    let bodies: [(&str, Generator); 3] = [
        ("barycenters", barycenters),
        ("planets", planets),
        ("satellites", satellites),
    ];
    bodies.map(|(src, func)| {
        let path = format!("../../../crates/lox_core/src/bodies/{src}.rs");
        let mut code = String::from("// Auto-generated by `lox_gen`. Do not edit!\n");
        code.push_str(&func(&pck, &gm).to_string());
        let file = Path::new(file!());
        let out = file.parent().unwrap().join(path);
        fs::write(&out, code).expect("file should be writeable");
        Command::new("rustfmt")
            .args([out.to_str().unwrap()])
            .status()
            .expect("formatting should work");
    });
}

fn barycenters(_pck: &Kernel, gm: &Kernel) -> TokenStream {
    let tokens = BARYCENTERS.iter().map(|(id, name)| {
        let ident = format_ident!("{}", name);
        let mut tokens = quote! {
            pub struct #ident;
        };
        naif_id(&mut tokens, &ident, id);
        grav_param(&mut tokens, &ident, id, gm);

        tokens
    });

    quote! {
        use super::{NaifId,PointMass};
        #(#tokens)*
    }
}

fn planets(pck: &Kernel, gm: &Kernel) -> TokenStream {
    let tokens = PLANETS.iter().map(|(id, name)| {
        let ident = format_ident!("{}", name);
        let mut tokens = quote! {
            pub struct #ident;
        };
        naif_id(&mut tokens, &ident, id);
        spheroid(&mut tokens, &ident, id, pck);
        grav_param(&mut tokens, &ident, id, gm);

        tokens
    });

    quote! {
        use super::{NaifId,Ellipsoid,Spheroid,PointMass};
        #(#tokens)*
    }
}

fn satellites(pck: &Kernel, gm: &Kernel) -> TokenStream {
    let tokens = SATELLITES.iter().map(|(id, name)| {
        let ident = format_ident!("{}", name);
        let mut tokens = quote! {
            pub struct #ident;
        };
        naif_id(&mut tokens, &ident, id);
        ellipsoid(&mut tokens, &ident, id, pck);
        grav_param(&mut tokens, &ident, id, gm);

        tokens
    });

    quote! {
        use super::{NaifId,Ellipsoid,TriAxial,PointMass};
        #(#tokens)*
    }
}

fn naif_id(tokens: &mut TokenStream, ident: &Ident, id: &i32) {
    *tokens = quote! {
        #tokens

        impl NaifId for #ident {
            fn id() -> i32 {
                #id
            }
        }
    }
}

fn spheroid(tokens: &mut TokenStream, ident: &Ident, id: &i32, pck: &Kernel) {
    let radii = format!("BODY{id}_RADII");
    if let Some(radii) = pck.get_double_array(&radii) {
        let equatorial = radii.first().expect("radius should be here");
        let polar = radii.get(2).expect("radius should be here");
        let mean = (2.0 * equatorial + polar) / 3.0;
        *tokens = quote! {
            #tokens

            impl Ellipsoid for #ident {
                fn polar_radius() -> f64 {
                    #polar
                }
                fn mean_radius() -> f64 {
                    #mean
                }
            }

            impl Spheroid for #ident {
                fn equatorial_radius() -> f64 {
                    #equatorial
                }
            }
        }
    }
}

fn ellipsoid(tokens: &mut TokenStream, ident: &Ident, id: &i32, pck: &Kernel) {
    let radii = format!("BODY{id}_RADII");
    if let Some(radii) = pck.get_double_array(&radii) {
        let subplanetary = radii.first().expect("radius should be here");
        let along_orbit = radii.get(1).expect("radius should be here");
        let polar = radii.get(2).expect("radius should be here");
        let mean = (subplanetary + along_orbit + polar) / 3.0;
        *tokens = quote! {
            #tokens

            impl Ellipsoid for #ident {
                fn polar_radius() -> f64 {
                    #polar
                }
                fn mean_radius() -> f64 {
                    #mean
                }
            }

            impl TriAxial for #ident {
                fn subplanetary_radius() -> f64 {
                    #subplanetary
                }
                fn along_orbit_radius() -> f64 {
                    #along_orbit
                }
            }
        }
    }
}

fn grav_param(tokens: &mut TokenStream, ident: &Ident, id: &i32, gm: &Kernel) {
    let key = format!("BODY{id}_GM");
    if let Some(gm) = gm.get_double_array(&key) {
        let gm = gm.first().unwrap();
        *tokens = quote! {
            #tokens

            impl PointMass for #ident {
                fn gravitational_parameter() -> f64 {
                    #gm
                }
            }
        }
    }
}
