mod naif_ids;

use crate::naif_ids::BARYCENTERS;
use lox_io::spice::Kernel;
use naif_ids::PLANETS;
use proc_macro2::{Ident, TokenStream};
use quote::{format_ident, quote};
use std::fs;
use std::path::Path;
use std::process::Command;

type Generator = fn(&Kernel, &Kernel) -> TokenStream;

pub fn main() {
    let pck = Kernel::from_string(include_str!("../../../data/pck00011.tpc"))
        .expect("parsing should succeed");
    let gm = Kernel::from_string(include_str!("../../../data/gm_de440.tpc"))
        .expect("parsing should succeed");
    let bodies: [(&str, Generator); 2] = [("barycenters", barycenters), ("planets", planets)];
    bodies.map(|(src, func)| {
        let path = format!("../../../crates/lox_core/src/bodies/{src}.rs");
        let mut code = String::from("// Auto-generated by `lox_gen`. Do not edit!\n");
        code.push_str(&func(&pck, &gm).to_string());
        let file = Path::new(file!());
        let out = file
            .parent()
            .unwrap()
            .join("../../../crates/lox_core/src/bodies/planets.rs");
        fs::write(&out, code).expect("file should be writeable");
        Command::new("rustfmt")
            .args([out.to_str().unwrap()])
            .status()
            .expect("formatting should work");
    });
}

fn barycenters(pck: &Kernel, gm: &Kernel) -> TokenStream {
    let tokens = BARYCENTERS.iter().map(|(id, name)| {
        let ident = format_ident!("{}", name);
        let mut tokens = quote! {
            pub struct #ident;
        };
        naif_id(&mut tokens, &ident, id);
        grav_param(&mut tokens, &ident, id, gm);

        tokens
    });

    quote! {
        use super::{NaifId,PointMass};
        #(#tokens)*
    }
}

fn planets(pck: &Kernel, gm: &Kernel) -> TokenStream {
    let tokens = PLANETS.iter().map(|(id, name)| {
        let ident = format_ident!("{}", name);
        let mut tokens = quote! {
            pub struct #ident;
        };
        naif_id(&mut tokens, &ident, id);
        ellipsoid(&mut tokens, &ident, id, pck);
        grav_param(&mut tokens, &ident, id, gm);

        tokens
    });

    quote! {
        use super::{NaifId,Ellipsoid,PointMass};
        #(#tokens)*
    }
}

fn naif_id(tokens: &mut TokenStream, ident: &Ident, id: &i32) {
    *tokens = quote! {
        #tokens

        impl NaifId for #ident {
            fn id() -> i32 {
                #id
            }
        }
    }
}

fn ellipsoid(tokens: &mut TokenStream, ident: &Ident, id: &i32, pck: &Kernel) {
    let radii = format!("BODY{id}_RADII");
    if let Some(radii) = pck.get_double_array(&radii) {
        let max_eq = radii.first().expect("radius should be here");
        let min_eq = radii.get(1).expect("radius should be here");
        let polar = radii.get(2).expect("radius should be here");
        let mean = (max_eq + min_eq + polar) / 3.0;
        *tokens = quote! {
            #tokens

            impl Ellipsoid for #ident {
                fn max_equatorial_radius() -> f64 {
                    #max_eq
                }
                fn min_equatorial_radius() -> f64 {
                    #min_eq
                }
                fn polar_radius() -> f64 {
                    #polar
                }
                fn mean_radius() -> f64 {
                    #mean
                }
            }
        }
    }
}

fn grav_param(tokens: &mut TokenStream, ident: &Ident, id: &i32, gm: &Kernel) {
    let key = format!("BODY{id}_GM");
    if let Some(gm) = gm.get_double_array(&key) {
        let gm = gm.first().unwrap();
        *tokens = quote! {
            #tokens

            impl PointMass for #ident {
                fn gravitational_parameter() -> f64 {
                    #gm
                }
            }
        }
    }
}
